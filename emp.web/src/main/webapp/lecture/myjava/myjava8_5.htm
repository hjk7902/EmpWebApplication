<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<ul>
		<P class="TitleNumber" align="center">8.5</P></td>
        <td width="518">
        <p class="TitleTitle">Serialization</td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<P class="TSubmenu">&nbsp;8.5.1 Serializable 인터페이스
		<ul>
		<P>이제 파일입출력의 마지막 부분에 대해 설명하기로 한다. 많이 사용되는 Serialization은 생성된 객체가 스트림을 통해 이동하는 것을 말한다. 특히 객체가 스트림을 통해 기억장치에 저장되는 것을 영속성(persistent)이라고 한다. 부언하면 메모리에서 생성된 객체를 파일에 저장하는 것을 영속성(일종의 serialization임)라고 한다. 중요한 점은, 이렇게 Serialization되는 클래스는 Serializable이라는 인터페이스를 반드시 implements해야 하지만 이 인터페이스에는 구현할 메소드가 하나도 없다. 따라서 Serializable을 implements하는 것은, 이 클래스가 Serialization이 가능함을 나타내는 표시일 뿐이다. 
		<P>다음 프로그램은 Person클래스의 객체를 저장하기 위해 Serializable인터페이스를 구현한 예이다.
		<P>
		<table CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Person.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.io.*;
			<P class="CStep1">public class Person <B>implements Serializable</B> {
			<P class="CStep2">String name;
			<P class="CStep2">int age;
			<P class="CStep2">String password;
			<P class="CStep2">public Person(String name, int age, String password) {
			<P class="CStep3">this.name = name;
			<P class="CStep3">this.age = age;
			<P class="CStep3">this.password = password;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>중요한 점은 실제 객체가 Serialization될 때, 데이터부분만 Serialization된다는 것이다. 즉, 앞의 Person클래스 객체를 파일로 저장할 때, 실제로 저장되는 것은 멤버 변수 name, age, password같은 데이터만 저장되고, Person()같은 생성자나 메소드코드는 저장되지 않는다는 점이다.
		<P>좀더 구체적인 예를 통해 Serialization에 대해서 알아보자. 앞에서 언급한 Person클래스의 객체를 파일에 저장하는 예제와 다시 파일로부터 읽는 예제를 살펴보자.
		<P>다음 프로그램은 앞의 SerialExample클래스의 객체를 생성하여 파일에 저장하는 예를 보인 것이다.
		<P>
		<table CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>WriteMyObject.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">&nbsp;
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.io.*;
			<P class="CStep1">public class WriteMyObject {
			<P class="CStep2">public static void main(String [] args) throws Exception {
			<P class="CStep3">Person p1 = new Person(&quot;홍길동&quot;, 32, &quot;hongkd&quot;);
			<P class="CStep3">Person p2 = new Person(&quot;이순신&quot;, 54, &quot;lss5402&quot;);
			<P class="CStep3">FileOutputStream fos = new FileOutputStream
			<P class="CStep3">(&quot;myObject.ser&quot;);
			<P class="CStep3"><B>ObjectOutputStream oos = new ObjectOutputStream(fos);</B>
			<P class="CStep3"><B>oos.writeObject(p1)</B>;
			<P class="CStep3"><B>oos.writeObject(p2)</B>;
			<P class="CStep3">oos.close();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">Person p1 = new Person(&quot;홍길동&quot;, 32, &quot;hongkd&quot;);
			<P class="CStep1">Person p2 = new Person(&quot;이순신&quot;, 54, &quot;lss5402&quot;);</TD>
		</tr>
		</TABLE>
		<P>Person클래스의 객체를 선언하고 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">8:
			<P class="CNumber">&nbsp;
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">FileOutputStream fos = new FileOutputStream
			<P class="CStep1">(&quot;myObject.ser&quot;);
			<P class="CStep1"><B>ObjectOutputStream oos = new ObjectOutputStream(fos);</B></TD>
		</tr>
		</TABLE>
		<P>8 : 파일에 출력하기 위해 FileOutputStream객체를 생성한다. 
		<P>9 : 객체를 저장하기 위해 필터스트림인 ObjectOutputStream객체를 생성한다. 
		<P>11 : 객체를 저장할 수 있는 writeObject() 메소드는 필터스트림인 ObjectOutputStream에 있다. 따라서 메소드를 사용하려면 필터스트림을 적용할 수밖에 없다. (입출력 클래스의 적용은 대부분 이런 방법으로 이루어진다.)
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber">11:
			<p class="CNumber">12:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">oos.writeObject(p1);
			<P class="CStep1">oos.writeObject(p2);</TD>
		</tr>
		</TABLE>
		<P>ObjectOutputStream에 Person클래스의 객체인 p1과 p2를 저장한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">13:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">oos.close();</TD>
		</tr>
		</TABLE>
		<P>출력 스트림을 닫아준다.
		<P>다음 프로그램은 앞의 WriteMyObject 프로그램을 실행했을 때 나타나는 myObject.ser파일에 저장되어 있는 Person클래스 객체를 읽어들이는 예제이다.
		<P>
		<table CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ReadMyObject.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">&nbsp;
			<p class="CNumber">4:
			<p class="CNumber">&nbsp;
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">&nbsp;
			<p class="CNumber">9:
			<p class="CNumber">&nbsp;
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.io.*;
			<P class="CStep1">public class ReadMyObject {
			<P class="CStep2">public static void main(String [] args) throws Exception
			<P class="CStep2">{
			<P class="CStep3">FileInputStream fis = new FileInputStream
			<P class="CStep3">(&quot;myObject.ser&quot;);
			<P class="CStep3"><B>ObjectInputStream ois = new ObjectInputStream(fis);</B>
			<P class="CStep3">Person p1 = (Person)<B>ois.readObject()</B>;
			<P class="CStep3">Person p2 = (Person)<B>ois.readObject()</B>;
			<P class="CStep3">System.out.println(p1.name + &quot;\t&quot; + p1.age +
			<P class="CStep3">&quot;\t&quot; + p1.password);
			<P class="CStep3">System.out.println(p2.name + &quot;\t&quot; + p2.age +
			<P class="CStep3">&quot;\t&quot; + p2.password);
			<P class="CStep3">ois.close();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">FileInputStream fis = new FileInputStream(&quot;myObject.ser&quot;)
			<P class="CStep1"><B>ObjectInputStream ois = new ObjectInputStream(fis);</B></TD>
		</tr>
		</TABLE>
		<P>5 : 파일로부터 읽기 위해 FileInputStream객체를 생성한다. 
		<P>6 : 객체를 읽기 위해 필터스트림인 ObjectInputStream객체를 생성하나. 객체를 읽을 수 있는 메소드인 8번째 줄과 9번째 줄의 readObject() 메소드는 필터스트림인 ObjectInputStream에 있다. 따라서 메소드를 사용하려면 필터스트림을 적용해야 한다. 
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">Person p1 = (Person)<B>ois.readObject()</B>;
			<P class="CStep1">Person p2 = (Person)<B>ois.readObject()</B>;</TD>
		</tr>
		</TABLE>
		<P>8 : ∼ 9 : Person 객체에 myObject.ser파일의 객체를 불러들인다. Person형으로 형 변환하고 있는데, 이는 readObject() 메소드의 반환형이 Object형이기 때문에 실제 객체형인 Person형으로 형 변환이 필요한 것이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">13:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">ois.close();</TD>
		</tr>
		</TABLE>
		<P>입력 스트림을 닫아준다.
		</ul>
		<P class="TSubmenu">8.5.2 transient
		<ul>
		<P>이 키워드는 Serializable과 함께 알아 두면 유용하다. 3장에서 잠깐 언급했지만 쓰레드 클래스 객체처럼 serialization 되지 않는 객체변수를 포함한 클래스를 serialization시킬 때나 특정변수를 serialization에서 제외시키고자 할 때 사용하는 제한자이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class MyClass implements Serializable {
			<P class="CStep2">public <B>transient</B> Thread myThread;
			<P class="CStep2">private String customerID;
			<P class="CStep2">private int total;
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>이 예에서 쓰레드 객체는 원래 serialization이 불가능하므로 transient키워드로 선언한 것이다. 만일 transient가 빠지면 MyClass 클래스는 serialization 되지 않는다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class MyClass implements Serializable {
			<P class="CStep2">public transient Thread myThread;
			<P class="CStep2">private<B> transient </B>String customerID;
			<P class="CStep2">private int total;
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>이 예에서는 MyClass의 객체를 serialization시킬 때 customerID는 serialization에서 제외한다는 뜻이다. String클래스는 원래 serialization이 가능하므로 transient를 제외시켜도 MyClass는 serialization이 된다.
		</ul></td>
    </tr>
	</table>
</body>
</html>