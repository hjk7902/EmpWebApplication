<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>8.1 스트림(Streams) </title>
<meta name="generator" content="Namo WebEditor v5.0">
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<P>
&nbsp;<P>
<IMG SRC="file:///C|/지빠귀/FYXIV310.GIF" BORDER=0 ALIGN=LEFT>
<P><FONT SIZE=5 COLOR=PURPLE><SPAN STYLE="font-size:20pt;"><B><FONT FACE="Bookman Old Style">8.1   </FONT><FONT FACE="바탕">스트림</FONT><FONT FACE="Bookman Old Style">(Streams)</FONT></B></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">먼저 입출력을 이해하기 전에 스트림이라는 용어부터 알아보자. 스트림은 source에서, sink로의 데이터 흐름을 말한다. source는 데이터 흐름의 출발점으로 입력 스트림이라고도 하며, sink는 데이터 흐름이 끝나는 지점으로 출력 스트림이라고 한다. 예를 들어 c:\temp\in.txt 파일을 읽어들이는 프로그램을 개발하려면 in.txt 파일이 입력 스트림이 되고, 반대로 out.txt 파일에 무언가를 쓰려고 하면 이 파일이 출력 스트림이 되는 것이다. source와 sink를 합해서 노드라고 하는데, 노드의 종류로는 디스크상의 파일, 메모리, 또는 쓰레드나 프로세스 사이에서 채널역할을 하는 파이프 등이 있다. 이 같은 디스크 파일이나 메모리 영역과 같은 노드에서 읽거나 쓰는 스트림을 노드 스트림(Node Stream)이라 한다. 일단 스트림에서 데이터를 읽으려면 노드 스트림이 필요한데, 노드 스트림을 통해서만 노드로부터 데이터를 읽거나 쓸 수 있기 때문이다.</FONT>
<BR>
<P><FONT FACE="바탕">자바는 입출력을 수행할 때 문자단위 스트림과 바이트단위 스트림 형식을 지원하는데 다음 표와 같이 문자자료의 입출력은 Reader와 Writer에 의해 이루어지고, 바이트자료의 입출력은 InputStream과 OutputStream에 의해 이루어진다.</FONT>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=539 HEIGHT=86>
<TD VALIGN=MIDDLE WIDTH=30%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=34%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Byte Streams</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=34%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Character Streams</FONT></B></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=30%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Source Streams</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=34%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">InputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=34%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">Reader</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=30%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Sink Streams</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=34%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">OutputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=34%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">Writer</FONT></SPAN></FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:16pt;"><FONT FACE="HY부활M">8.1.1 </FONT><FONT FACE="바탕">노드스트림</FONT></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">앞에서도 잠깐 언급한바와 같이 자바에서는 3가지 종류의 노드(파일, 메모리, 파이프)를 지원하는데 각 노드와 연결될 수 있는 클래스는 다음 표와 같다. 
</FONT><P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=636 HEIGHT=224>
<TD VALIGN=MIDDLE WIDTH=25%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Byte Streams</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Character Streams</FONT></B></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">File</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">FileInputStream</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">FileOutputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">FileReader</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">FileWriter</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Memory : Array</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">ByteArrayInputStream</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">ByteArrayOutputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">CharArrayReader</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">CharArrayWriter</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Memory : String</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">-</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">StringReader</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">StringWriter</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Pipe</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">PipedInputStream</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">PipedOutputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">PipedReader</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">PipedWriter</FONT></SPAN></FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT FACE="바탕">입출력 수행을 위해 노드와 연결하려면 앞의 표에있는 클래스의 객체를 생성하면 된다. 그 다음 각 클래스에 정의되어 있는 메소드를 이용하여 원하는 작업을 수행한다. 
</FONT><BR>
<P><FONT FACE="바탕">다음은 노드스트림의 사용 예를 보인 것이다.</FONT>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=660 HEIGHT=48>
<TD VALIGN=TOP WIDTH=2%>
<BR></TD>
<TD VALIGN=TOP WIDTH=97%>
<P><B><FONT FACE="Courier New">FileReader</FONT></B><FONT FACE="Courier New"> input = new FileReader(&quot;c:\in.txt&quot;);</FONT>
<P><FONT FACE="Courier New">input.</FONT><B><FONT FACE="Courier New">read()</FONT></B><FONT FACE="Courier New">;</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT FACE="바탕">앞의 예를 보면 &quot;c:\in.txt&quot; 파일을 읽기 위해 노드스트림인 FileReader객체를 생성했는데 이 객체를 통해 파일에서 데이터를 읽을 수 있다. 예를 들어 FileReader 클래스에는 read() 메소드가 있는데, 이를 호출하면 한 문자를 읽어올 수 있다.</FONT>
<BR>
<P><FONT FACE="바탕">다음 프로그램은 첫 번째 명령행 인자로 입력된 이름의 파일에서 문자를 읽어들여 두 번째 명령행 인자로 입력된 파일에 문자를 쓰는 예제이다. 즉, 파일을 복사하는 예를 보인 것이다.</FONT>
<BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=231>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">NodeStreamExample.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">public class NodeStreamExample {</FONT>
<P>	<FONT FACE="Courier New">public static void main(String[] args) {</FONT>
<P>		<FONT FACE="Courier New">try {</FONT>
<P>			<B><FONT FACE="Courier New">FileReader</FONT></B><FONT FACE="Courier New"> input = new FileReader(args[0]);</FONT>
<P>			<B><FONT FACE="Courier New">FileWriter </FONT></B><FONT FACE="Courier New">output = new FileWriter(args[1]);</FONT>
<P>			<FONT FACE="Courier New">char[] buffer = new char[128];</FONT>
<P>			<FONT FACE="Courier New">int charsRead;</FONT>
<P>			<FONT FACE="Courier New">charsRead = input.</FONT><B><FONT FACE="Courier New">read(buffer)</FONT></B><FONT FACE="Courier New">;</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=276>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">NodeStreamExample.java(</FONT><FONT FACE="바탕">계속</FONT><FONT FACE="HY타자B">)</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT>
<P><FONT FACE="Courier New">14:</FONT>
<P><FONT FACE="Courier New">15:</FONT>
<P><FONT FACE="Courier New">16:</FONT>
<P><FONT FACE="Courier New">17:</FONT>
<P><FONT FACE="Courier New">18:</FONT>
<P><FONT FACE="Courier New">19:</FONT>
<P><FONT FACE="Courier New">20:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P>			<FONT FACE="Courier New">while ( charsRead != -1 ) {</FONT>
<P>				<FONT FACE="Courier New">output.</FONT><B><FONT FACE="Courier New">write(buffer, 0, charsRead)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>				<FONT FACE="Courier New">charsRead = input.read(buffer);</FONT>
<P>			<FONT FACE="Courier New">}</FONT>
<P>			<FONT FACE="Courier New">input.close();</FONT>
<P>			<FONT FACE="Courier New">output.close();</FONT>
<P>		<FONT FACE="Courier New">} catch (IOException e) {</FONT>
<P>			<FONT FACE="Courier New">e.printStackTrace();</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:16pt;"><FONT FACE="HY부활M">8.1.2 </FONT><FONT FACE="바탕">필터스트림</FONT></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">필터스트림(Filter Stream)은 처리스트림(Processing Stream)이라고도 하며 다른 객체를 둘러싸는 역할을 한다.</FONT>
<P ALIGN=CENTER>
<IMG SRC="file:///C|/지빠귀/FYXIV311.GIF" BORDER=0 WIDTH=548 HEIGHT=106 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
<BR>
<P><FONT FACE="바탕">필터스트림들을 사용하는 이유는 노드스트림의 부족한 기능을 보완하여 좀더 정밀한 입출력을 하기 위해서다. 예들 들어 FileReader클래스의 노드스트림은 파일에서 텍스트를 읽어올 때 한 문자씩 읽는 낮은 수준의 메소드(read() 메소드)만 가지고 있는 반면, BufferedReader클래스 등의 필터스트림은 줄 단위로 읽어 String으로 반환하는 고급 메소드(readLine() 메소드)를 포함하고 있기 때문에 좀더 편리하게 입출력 작업을 할 수 있는 것이다.</FONT>
<BR>
<P><FONT FACE="바탕">다음 표는 필터스트림 클래스를 나타낸 것이다.</FONT>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=636 HEIGHT=175>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Type</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Byte Streams</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Character Streams</FONT></B></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Buffering</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">BufferedInputStream</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">BufferedOutputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">BufferedReader</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">BufferedWriter</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Filtering</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">FilterInputStream</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">FilterOutputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">FilterReader</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">FilterWriter</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Converting </FONT></B></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">bytes↔character</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">-</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">InputStreamReader</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">OutputStreamWriter</FONT></SPAN></FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=636 HEIGHT=213>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Type</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Byte Streams</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Character Streams</FONT></B></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Object</FONT></B></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Serialization</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">ObjectInputStream</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">ObjectOutputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">-</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Data conversion</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">DataInputStream</FONT></SPAN></FONT>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">DataOutputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">-</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Counting</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">LineNumberInputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">LineNumberReader</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Peeking ahead</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">PushbackInputStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">PushbackReader</FONT></SPAN></FONT></TD>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=25%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><B><FONT FACE="바탕">Printing</FONT></B></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">PrintStream</FONT></SPAN></FONT></TD>
<TD VALIGN=MIDDLE WIDTH=37%>
<P ALIGN=CENTER><FONT SIZE=2><SPAN STYLE="font-size:10pt;"><FONT FACE="바탕">PrintWriter</FONT></SPAN></FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT COLOR=PURPLE><SPAN STYLE="font-size:12pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT FACE="바탕"> FilterXxx 클래스는 abstract클래스로 사용자가 임의의 필터스트림을 만들 때 사용한다.</FONT>
<BR>
<P><FONT FACE="바탕">다음은 필터 스트림의 사용 예를 보인 것이다.</FONT>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=660 HEIGHT=70>
<TD VALIGN=TOP WIDTH=2%>
<BR></TD>
<TD VALIGN=TOP WIDTH=97%>
<P><FONT FACE="Courier New">FileReader input = new FileReader(&quot;c:\in.txt&quot;);</FONT>
<P><B><FONT FACE="Courier New">BufferedReader</FONT></B><FONT FACE="Courier New"> bufInput = new BufferedReader(input);</FONT>
<P><FONT FACE="Courier New">bufInput.</FONT><B><FONT FACE="Courier New">readLine()</FONT></B><FONT FACE="Courier New">;</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT FACE="바탕">앞의 예에서 BufferedReader클래스의 인자로 FileReader클래스의 객체가 사용되었다. 이렇게 Buffered -Reader클래스를 사용하면 readLine() 메소드를 이용하여  데이터를 줄 단위로 읽어들일 수가 있다.</FONT>
<BR>
<P><FONT FACE="바탕">다음 프로그램은 앞의 예제와 같이 파일을 복사하는 프로그램이다. 앞 프로그램과 다른 점은 문자단위로 읽지않고, BufferedStream을 이용하여 줄 단위로 처리한다.</FONT>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=447>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">FilterStreamExample.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT>
<P><FONT FACE="Courier New">14:</FONT>
<P><FONT FACE="Courier New">15:</FONT>
<P><FONT FACE="Courier New">16:</FONT>
<P><FONT FACE="Courier New">17:</FONT>
<P><FONT FACE="Courier New">18:</FONT>
<P><FONT FACE="Courier New">19:</FONT>
<P><FONT FACE="Courier New">20:</FONT>
<P><FONT FACE="Courier New">21:</FONT>
<P><FONT FACE="Courier New">22:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">public class FilterStreamExample {</FONT>
<P>	<FONT FACE="Courier New">public static void main(String[] args) {</FONT>
<P>		<FONT FACE="Courier New">try {</FONT>
<P>			<FONT FACE="Courier New">FileReader input = new FileReader(args[0]);</FONT>
<P>			<B><FONT FACE="Courier New">BufferedReader</FONT></B><FONT FACE="Courier New"> bufInput = new BufferedReader(input);</FONT>
<P>			<FONT FACE="Courier New">FileWriter output = new FileWriter(args[1]);</FONT>
<P>			<B><FONT FACE="Courier New">BufferedWriter </FONT></B><FONT FACE="Courier New">bufOutput = new BufferedWriter(output);</FONT>
<P>			<FONT FACE="Courier New">String line;</FONT>
<P>			<FONT FACE="Courier New">line = bufInput.</FONT><B><FONT FACE="Courier New">readLine()</FONT></B><FONT FACE="Courier New">;</FONT>
<P>			<FONT FACE="Courier New">while ( line != null ) {</FONT>
<P>				<FONT FACE="Courier New">bufOutput.</FONT><B><FONT FACE="Courier New">write(line, 0, line.length())</FONT></B><FONT FACE="Courier New">;</FONT>
<P>				<FONT FACE="Courier New">bufOutput.newLine();</FONT>
<P>				<FONT FACE="Courier New">line = bufInput.readLine();</FONT>
<P>			<FONT FACE="Courier New">}</FONT>
<P>			<FONT FACE="Courier New">bufInput.close();</FONT>
<P>			<FONT FACE="Courier New">bufOutput.close();</FONT>
<P>		<FONT FACE="Courier New">} catch (IOException e) {</FONT>
<P>			<FONT FACE="Courier New">e.printStackTrace();</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">이 예제에서는 FileReader와 FileWriter클래스 외에 BufferedReader와 BufferedWriter클래스가 사용되었는데 BufferedReader와 BufferedWriter클래스가 필터스트림이다.</FONT>
<BR>
<P><FONT FACE="바탕">사용자가 원하는 필터스트림 클래스를 만들려면 FilterXxx(예 : FilterReader)형식의 abstract 클래스를 상속받아 구현한다.</FONT>
<P><FONT FACE="바탕">자바에서의 입출력은 노드스트림이나 필터스트림 중에서 상황에 맞는 스트림을 선택하여 사용한다. 특히 자바에서는 다양한 입출력 API를 제공하기 때문에 자주 API 문서를 참고해야 한다. 또, 어떤 클래스가 노드스트림이고 어떤 클래스가 필터스트림인지 암기할 필요는 없고 API문서에서 사용할 클래스 생성자가 노드스트림 역할을 하는지 필터스트림 역할을 하는지를 구별하면 된다.</FONT>
<BR>
<P><FONT FACE="바탕">다음 표는 두 생성자의 특징을 요약한 것이다.</FONT>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=655 HEIGHT=261>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=WHITE><SPAN STYLE="font-size:13pt;"><FONT FACE="바탕">생성자 요약 </FONT></SPAN></FONT></TD>
    <td></td>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">FileInputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> (</FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">File</FONT></U></SPAN></FONT><FONT FACE="바탕"> file)</FONT>
<P>          <FONT FACE="바탕">Creates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system.</FONT></TD>
    <td></td>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">FileInputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> (</FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">FileDescriptor</FONT></U></SPAN></FONT><FONT FACE="바탕"> fdobj)</FONT>
<P>          <FONT FACE="바탕">Creates a FileInputStream by using the file descriptor fdObj, which represents an existing connection to an actual file in the file system.</FONT></TD>
    <td></td>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">FileInputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> (</FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">String</FONT></U></SPAN></FONT><FONT FACE="바탕"> name)</FONT>
<P>          <FONT FACE="바탕">Creates a FileInputStream by opening a connection to an actual file, the file named by the path name name in the file system.</FONT></TD>
    <td>FileInputStream<FONT FACE="바탕">클래스의 생성자</FONT></CAPTION></td>
<CAPTION ALIGN=BOTTOM>
<P ALIGN=LEFT><FONT FACE="Courier New">
</tr>


</TABLE> 
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=655 HEIGHT=108>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=WHITE><SPAN STYLE="font-size:13pt;"><FONT FACE="바탕">생성자 요약 </FONT></SPAN></FONT></TD>
    <td></td>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">DataInputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> (</FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> in)</FONT>
<P>          <FONT FACE="바탕">Creates a FilterInputStream and saves its argument, the input stream in, for later use.</FONT></TD>
    <td>DataInputStream<FONT FACE="바탕">클래스의 생성자</FONT></CAPTION></td>
<CAPTION ALIGN=BOTTOM>
<P ALIGN=LEFT><FONT FACE="Courier New">
</tr>


</TABLE>
<BR>
<P><FONT FACE="바탕">앞의 FileInputStrem클래스의 경우 3개의 생성자가 있는데, 첫 번째와 두 번째 생성자에서 파일을 접근할 수 있으므로 노드스트림임을 알 수 있다. 그러나 DataInputStream클래스의 생성자는 필터스트림임을 쉽게 알 수 있다. 생성자의 인자로 노드스트림인 InputStream클래스의 객체가 사용되었는데, 이렇게 필터스트림의 생성인자로 올 수 있는 것은 노드스트림이나 또 다른 필터스트림 만이 가능하고, 파일 같은 스트림은 지정할 수 없다.</FONT>
<BR>
<BR>
<P>
<IMG SRC="file:///C|/지빠귀/FYXIV312.GIF" BORDER=0 ALIGN=LEFT>
<P><FONT SIZE=5 COLOR=PURPLE><SPAN STYLE="font-size:20pt;"><B><FONT FACE="Bookman Old Style">8.2   </FONT><FONT FACE="바탕">스트림</FONT><FONT FACE="Bookman Old Style"> </FONT><FONT FACE="바탕">클래스의</FONT><FONT FACE="Bookman Old Style"> </FONT><FONT FACE="바탕">개요</FONT></B></SPAN></FONT>
<BR>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:16pt;"><FONT FACE="HY부활M">8.2.1 </FONT><FONT FACE="바탕">바이트스트림</FONT><FONT FACE="HY부활M"> </FONT><FONT FACE="바탕">클래스</FONT></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">다음 그림은 자주 사용되는 바이트스트림을 나타낸 것이다.</FONT>
<P ALIGN=CENTER>
<IMG SRC="file:///C|/지빠귀/FYXIV313.GIF" BORDER=0 WIDTH=555 HEIGHT=238 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
<P ALIGN=CENTER>
<IMG SRC="file:///C|/지빠귀/FYXIV314.GIF" BORDER=0 WIDTH=556 HEIGHT=171 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> FileInputStream과 FileOutputStream</FONT></SPAN></FONT>
<P><FONT FACE="바탕">- 이들 클래스는 노드스트림으로 디스크 파일에 사용된다. 객체를 생성할 때 FileInputStream클래스는 파일이 읽기 가능한 상태여야하며, FileOutputStream클래스는 파일이 없으면 파일을 생성하고, 있으면 겹쳐 Tm게 된다.</FONT>
<BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=631 HEIGHT=43>
<TD VALIGN=MIDDLE WIDTH=2%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=97%>
<P><FONT FACE="Courier New">FileInputStream infile = new FileInputStream(&quot;in.txt&quot;);</FONT>
<P><FONT FACE="Courier New">FileOutputStream outfile = new FileOutputStream(&quot;out.txt&quot;);</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> BufferedInputStream과 BufferedOutputStream</FONT></SPAN></FONT>
<P><FONT FACE="바탕">- 이 클래스는 필터스트림으로 입출력 효율을 증대시켜준다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> DataInputStream과 DataOutputStream</FONT></SPAN></FONT>
<P><FONT FACE="바탕">- 이 클래스는 필터스트림으로 Primitive 형 데이터를 읽거나 쓸 때 사용한다. 또, 서로 다른 Primitive 형 데이터 처리를 위해 많은 메소드를 가지고 있다. 
</FONT><BR>
<P><FONT FACE="바탕">다음 프로그램은 앞의 파일복사 예제를 FileInpuStream과 FileOutPutStream 클래스를 사용하여 작성한 것이다.</FONT>
<BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=430>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">CopyFile.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT>
<P><FONT FACE="Courier New">14:</FONT>
<P><FONT FACE="Courier New">15:</FONT>
<P><FONT FACE="Courier New">16:</FONT>
<P><FONT FACE="Courier New">17:</FONT>
<P><FONT FACE="Courier New">18:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">public class CopyFile {</FONT>
<P>	<FONT FACE="Courier New">public static void main(String [] args) throws Exception {</FONT>
<P>		<FONT FACE="Courier New">if (args.length &lt; 2) {</FONT>
<P>			<FONT FACE="Courier New">System.out.println(&quot;Usage : java CopyFile </FONT><I><FONT FACE="Courier New">file1 file2</FONT></I><FONT FACE="Courier New">&quot;);</FONT>
<P>			<FONT FACE="Courier New">return;</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>		<FONT FACE="Courier New">FileInputStream fis = new </FONT><B><FONT FACE="Courier New">FileInputStream</FONT></B><FONT FACE="Courier New">(args[0]);</FONT>
<P>		<FONT FACE="Courier New">FileOutputStream fos = new </FONT><B><FONT FACE="Courier New">FileOutputStream</FONT></B><FONT FACE="Courier New">(args[1]);</FONT>
<P>		<FONT FACE="Courier New">int readByte = 0;</FONT>
<P>		<FONT FACE="Courier New">while ((readByte = </FONT><B><FONT FACE="Courier New">fis.read()</FONT></B><FONT FACE="Courier New">) != -1) {</FONT>
<P>			<B><FONT FACE="Courier New">fos.write(readByte)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>		<FONT FACE="Courier New">fis.close();</FONT>
<P>		<FONT FACE="Courier New">fos.close();</FONT>
<P>		<FONT FACE="Courier New">System.out.println(args[0] + &quot; copied to &quot; + args[1]);</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<BR>
<P><FONT FACE="바탕">이 예제 프로그램은 노드스트림인 FileInputStream과 FileOuputStream만을 사용하고 있는데, read()와 write() 메소드는 1 바이트를 읽고 쓰는 메소드이다. (여기서 read()와 write() 메소드는 int형을 사용하지만 내부적으로는 바이트 단위로 읽고 쓴다.)</FONT>
<P> 
<P><FONT FACE="바탕">다음 프로그램은 DataInputStream클래스를 이용하여 파일에 &quot;이름&quot;, &quot;사번&quot;, &quot;나이&quot;를 읽고 쓰는 예이다.</FONT>
<BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=585>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">FileIOExample.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT>
<P><FONT FACE="Courier New">14:</FONT>
<P><FONT FACE="Courier New">15:</FONT>
<P><FONT FACE="Courier New">16:</FONT>
<P><FONT FACE="Courier New">17:</FONT>
<P><FONT FACE="Courier New">18:</FONT>
<P><FONT FACE="Courier New">19:</FONT>
<P><FONT FACE="Courier New">20:</FONT>
<P><FONT FACE="Courier New">21:</FONT>
<P><FONT FACE="Courier New">22:</FONT>
<P><FONT FACE="Courier New">23:</FONT>
<P><FONT FACE="Courier New">24:</FONT>
<P><FONT FACE="Courier New">25:</FONT>
<P><FONT FACE="Courier New">26:</FONT>
<P><FONT FACE="Courier New">27:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">public class FileIOExample {</FONT>
<P>	<FONT FACE="Courier New">public static void main(String [] args) throws Exception {</FONT>
<P>		<FONT FACE="Courier New">if (args.length &lt; 1 ) {</FONT>
<P>			<FONT FACE="Courier New">System.out.println(&quot;Usage : java FielIOExample </FONT><I><FONT FACE="Courier New">file</FONT></I><FONT FACE="Courier New">&quot;);</FONT>
<P>			<FONT FACE="Courier New">return;</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>		<B><FONT FACE="Courier New">FileOutputStream fos = new FileOutputStream(args[0]);</FONT></B>
<P>		<B><FONT FACE="Courier New">DataOutputStream dos = new DataOutputStream(fos);</FONT></B>
<P>		<FONT FACE="Courier New">dos.</FONT><B><FONT FACE="Courier New">writeUTF(&quot;</FONT><FONT FACE="바탕">홍길동</FONT><FONT FACE="Courier New">&quot;)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">dos.writeUTF(&quot;41456&quot;);</FONT>
<P>		<FONT FACE="Courier New">dos.</FONT><B><FONT FACE="Courier New">writeInt(30)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">dos.writeUTF(&quot;</FONT><FONT FACE="바탕">이기동</FONT><FONT FACE="Courier New">&quot;);</FONT>
<P>		<FONT FACE="Courier New">dos.writeUTF(&quot;41457&quot;);</FONT>
<P>		<FONT FACE="Courier New">dos.writeInt(31);</FONT>
<P>		<FONT FACE="Courier New">dos.close();</FONT>
<P>		<B><FONT FACE="Courier New">FileInputStream fis = new FileInputStream(args[0]);</FONT></B>
<P>		<B><FONT FACE="Courier New">DataInputStream dis = new DataInputStream(fis);</FONT></B>
<P>		<FONT FACE="Courier New">System.out.println(&quot;</FONT><FONT FACE="바탕">이름</FONT><FONT FACE="Courier New"> : &quot; + </FONT><B><FONT FACE="Courier New">dis.readUTF()</FONT></B><FONT FACE="Courier New">);</FONT>
<P>		<FONT FACE="Courier New">System.out.println(&quot;</FONT><FONT FACE="바탕">사번</FONT><FONT FACE="Courier New"> : &quot; + dis.readUTF());</FONT>
<P>		<FONT FACE="Courier New">System.out.println(&quot;</FONT><FONT FACE="바탕">나이</FONT><FONT FACE="Courier New"> : &quot; + </FONT><B><FONT FACE="Courier New">dis.readInt()</FONT></B><FONT FACE="Courier New">);</FONT>
<P>		<FONT FACE="Courier New">System.out.println(&quot;</FONT><FONT FACE="바탕">이름</FONT><FONT FACE="Courier New"> : &quot; + dis.readUTF());</FONT>
<P>		<FONT FACE="Courier New">System.out.println(&quot;</FONT><FONT FACE="바탕">사번</FONT><FONT FACE="Courier New"> : &quot; + dis.readUTF());</FONT>
<P>		<FONT FACE="Courier New">System.out.println(&quot;</FONT><FONT FACE="바탕">나이</FONT><FONT FACE="Courier New"> : &quot; + dis.readInt());</FONT>
<P>		<FONT FACE="Courier New">dis.close();</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">이 예제 프로그램은 DataInputStream클래스와 DataOutputStream클래스의 사용형태를 잘 보여주고 있다. 이처럼 기본자료의 입출력에는 주로 DataInputStream클래스와 DataOutputStream클래스이다.</FONT>
<P><FONT FACE="바탕">앞에서 설명한 InputStream, OutputStream은 바이트 단위로 입출력 동작을 수행하지만 한글의 경우 2바이트이기 때문에 글자가 깨질 위험이 있다. 따라서 이러한 문제점을 없애기 위해 자바에서는 문자나 문자열을 다룰 때, 유니코드(16bit-Unicode)방식을 제공한다. 유니코드를 사용하는 입출력 클래스를 Reader와 Writer라고 부르며, 이렇게 하면 자동으로 바이트가 유니코드화 되므로 한글같은 2 바이트 문자도 깨지지 않는다.</FONT>
<BR>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:16pt;"><FONT FACE="HY부활M">8.2.2 </FONT><FONT FACE="바탕">문자</FONT><FONT FACE="HY부활M"> </FONT><FONT FACE="바탕">스트림</FONT><FONT FACE="HY부활M"> </FONT><FONT FACE="바탕">클래스</FONT></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">다음 그림은 자주 사용되는 문자 스트림 클래스를 나타낸 것이다.</FONT>
<P ALIGN=CENTER>
<IMG SRC="file:///C|/지빠귀/FYXIV315.GIF" BORDER=0 WIDTH=554 HEIGHT=202 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
<P ALIGN=CENTER>
<IMG SRC="file:///C|/지빠귀/FYXIV316.GIF" BORDER=0 WIDTH=556 HEIGHT=239 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> InputStreamReader와 OutputStreamWriter</FONT></SPAN></FONT>
<P><FONT FACE="바탕">- 이 클래스는 바이트 스트림과 Character reader/writer 사이의 인터페이스 역할을 한다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> FileReader와 FileWriter</FONT></SPAN></FONT>
<P><FONT FACE="바탕">- 이 클래스는 노드스트림으로 FileInputStream이나 FileOutputStream과 같은 역할을 하는데, 바이트단위가 아닌 유니코드 문자단위로 처리한다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> BufferedReader와 BufferedWriter</FONT></SPAN></FONT>
<P><FONT FACE="바탕">- 이 클래스는 필터스트림으로 입출력 효율을 증대시켜준다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> StringReader와 StringWriter</FONT></SPAN></FONT>
<P><FONT FACE="바탕">- 이 클래스는 노드스트림으로 문자열객체를 읽고 쓰는데 사용한다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> PipedReader와 PipedWriter</FONT></SPAN></FONT>
<P><FONT FACE="바탕">- 이 클래스는 쓰래드 사이의 통신을 위한 연결 통로로 사용된다.</FONT>
<BR>
<P><FONT FACE="바탕">다음 프로그램은 키보드에서 문자열을 입력받아 파일에 저장하는 예이다.</FONT>
<BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=766 HEIGHT=474>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">StringInput.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT>
<P><FONT FACE="Courier New">14:</FONT>
<P><FONT FACE="Courier New">15:</FONT>
<P><FONT FACE="Courier New">16:</FONT>
<P><FONT FACE="Courier New">17:</FONT>
<P><FONT FACE="Courier New">18:</FONT>
<P><FONT FACE="Courier New">19:</FONT>
<P><FONT FACE="Courier New">20:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">public class StringInput {</FONT>
<P>	<FONT FACE="Courier New">public static void main(String [] args) throws Exception {</FONT>
<P>		<FONT FACE="Courier New">if (args.length &lt; 1 ) {</FONT>
<P>			<FONT FACE="Courier New">System.out.println(&quot;Usage : java StringInput </FONT><I><FONT FACE="Courier New">file</FONT></I><FONT FACE="Courier New">&quot;);</FONT>
<P>			<FONT FACE="Courier New">return;</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>		<FONT FACE="Courier New">String inputString;</FONT>
<P>		<FONT FACE="Courier New">InputStreamReader isr = new </FONT><B><FONT FACE="Courier New">InputStreamReader(System.in)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">BufferedReader br = new </FONT><B><FONT FACE="Courier New">BufferedReader(isr)</FONT></B><FONT FACE="Courier New">;</FONT>
<P> 		<FONT FACE="Courier New">FileOutputStream fos = new </FONT><B><FONT FACE="Courier New">FileOutputStream(args[0])</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">OutputStreamWriter osr = new </FONT><B><FONT FACE="Courier New">OutputStreamWriter(fos)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">BufferedWriter bw = 			new </FONT><B><FONT FACE="Courier New">BufferedWriter(osr)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">while((inputString = </FONT><B><FONT FACE="Courier New">br.readLine()</FONT></B><FONT FACE="Courier New">) != null) {</FONT>
<P>			<B><FONT FACE="Courier New">bw.write(inputString + &quot;\n&quot;)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>		<FONT FACE="Courier New">bw.close();</FONT>
<P>		<FONT FACE="Courier New">br.close();</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT FACE="바탕">이 프로그램이 실행될 때 저장할 문장을 입력한 다음 유닉스에서는 Ctrl+D를 누르고 윈도우에서는 Ctrl+Z를 눌러 스트림의 끝을 알려준다.</FONT>
<P><FONT FACE="바탕">9 : InputStreamReader가 사용되었는데, 다음 그림을 통하여 이 클래스의 생성자를 살펴보자.</FONT>
<BR>
<P>  
<TABLE BORDER=1 CELLPADDING=2 WIDTH=655 HEIGHT=248>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=WHITE><SPAN STYLE="font-size:13pt;"><FONT FACE="바탕">Constructor Summary</FONT></SPAN></FONT></TD>
    <td></td>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStreamReader</FONT></U></SPAN></FONT><FONT FACE="바탕"> (</FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> in)</FONT>
<P>          <FONT FACE="바탕">Create an InputStreamReader that uses the default charset.</FONT></TD>
    <td></td>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStreamReader</FONT></U></SPAN></FONT><FONT FACE="바탕"> (</FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> in, </FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">Charset</FONT></U></SPAN></FONT><FONT FACE="바탕"> cs)</FONT>
<P>          <FONT FACE="바탕">Create an InputStreamReader that uses the given charset.</FONT></TD>
    <td></td>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStreamReader</FONT></U></SPAN></FONT><FONT FACE="바탕"> (</FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> in, </FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">CharsetDecoder</FONT></U></SPAN></FONT><FONT FACE="바탕"> dec)</FONT>
<P>          <FONT FACE="바탕">Create an InputStreamReader that uses the given charset decoder.</FONT></TD>
    <td></td>
</tr>
<TR>
<TD VALIGN=MIDDLE WIDTH=100%>
<P><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStreamReader</FONT></U></SPAN></FONT><FONT FACE="바탕"> (</FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">InputStream</FONT></U></SPAN></FONT><FONT FACE="바탕"> in, </FONT><FONT COLOR=BLUE><SPAN STYLE="font-size:11pt;"><U><FONT FACE="바탕">String</FONT></U></SPAN></FONT><FONT FACE="바탕"> caarsetName)</FONT>
<P>          <FONT FACE="바탕">Create an InputStreamReader that uses the named charset.</FONT></TD>
    <td>InputStreamReader<FONT FACE="바탕">클래스의 생성자</FONT></CAPTION></td>
<CAPTION ALIGN=BOTTOM>
<P ALIGN=LEFT><FONT FACE="Courier New">
</tr>


</TABLE>
<BR>
<P><FONT FACE="바탕">이 클래스는 필터스트림이다. 따라서 InputStreamReader의 인자로 System.in을 넘겼다. API문서를 살펴보면 System.in이 InputStream임을 알 수 있다.(앞에서 설명했지만, InputStream은 노드스트림이다.)</FONT>
<BR>
<P><FONT FACE="바탕">10 : BufferedReader클래스는 내부적으로 버퍼를 이용해서 입출력의 성능을 극대화시킨다. 
</FONT><P><FONT FACE="바탕">14 : readLine() 메소드는 엔터키를 누르기 전까지 사용자가 입력한 내용을 한꺼번에 읽어오는 메소드인데, 사용자의 입력을 한번에 읽어오고 입출력 성능을 높이기 위해 BufferedReader클래스를 사용한다. 
</FONT><P><FONT FACE="바탕">11 : ∼ 13 : 이 부분은 다음과 같이 표현할 수도 있다.</FONT>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=660 HEIGHT=48>
<TD VALIGN=TOP WIDTH=2%>
<BR></TD>
<TD VALIGN=TOP WIDTH=97%>
<P><FONT FACE="Courier New">BufferedWriter bw = new </FONT><B><FONT FACE="Courier New">BufferedWriter</FONT></B><FONT FACE="Courier New">(new </FONT>
<P>	<B><FONT FACE="Courier New">OutputStreamWriter</FONT></B><FONT FACE="Courier New">(new </FONT><B><FONT FACE="Courier New">FileOutputStream</FONT></B><FONT FACE="Courier New">(args[0])));</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">입력한 문자열을 파일에 저장하기 위해 파일을 open한다. (C언어에서는 open()같은 메소드를 사용해서 입출력 동작을 실행시키지만 자바에서는 필요한 객체를 생성함으로써 입출력 동작이 이루어진다. 
</FONT><P><FONT FACE="바탕">17 : ∼ 18 : close() 메소드는 open된 파일을 닫아준다. (11번째 줄과 12번째 줄에서 생성한 모든 스트림 객체를 close할 필요는 없고, 스트림 객체만 close하면 된다.)</FONT>
<P> 
<P><FONT FACE="바탕">이 외에도 많은 입/출력 API들이 있으나, 사용방법은 위에서 설명한 내용과 크게 다르지 않다. 
</FONT><BR>
<BR>
<P>
<IMG SRC="file:///C|/지빠귀/FYXIV317.GIF" BORDER=0 ALIGN=LEFT>
<P><FONT SIZE=5 COLOR=PURPLE><SPAN STYLE="font-size:20pt;"><B><FONT FACE="Bookman Old Style">8.3   </FONT><FONT FACE="바탕">파일과</FONT><FONT FACE="Bookman Old Style"> URL </FONT><FONT FACE="바탕">객체</FONT></B></SPAN></FONT>
<BR>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:16pt;"><FONT FACE="HY부활M">8.3.1 </FONT><FONT FACE="바탕">파일객체</FONT></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">이제 구체적으로 지역 pc의 파일을 다루는 법에 대해서 알아보자.</FONT>
<P><FONT FACE="바탕">앞의 예에서는 파일을 지정할 때, 파일이름을 문자열 형태로 주었다. 물론 그런 방법으로 파일을 지정할 수도 있지만, 자바에서 제공하는 File클래스를 이용할 수도 있다.</FONT>
<P><FONT FACE="바탕">파일클래스는 단순하게 파일을 지정하는 목적으로만 사용되는 것은 아니고 매우 다양한 API가 있는데, 이를 이용하면 파일과 관련된 대부분 작업을 수행할 수 있다. 
</FONT><BR>
<P><FONT FACE="바탕">다음 예제는 File객체를 생성하는 방법을 기술한 것이다.</FONT>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=660 HEIGHT=97>
<TD VALIGN=TOP WIDTH=2%>
<BR></TD>
<TD VALIGN=TOP WIDTH=97%>
<P><B><FONT FACE="Courier New">File </FONT></B><FONT FACE="Courier New">someFile, someDir, otherFile;</FONT>
<P><FONT FACE="Courier New">someFile = new </FONT><B><FONT FACE="Courier New">File</FONT></B><FONT FACE="Courier New">(&quot;c:\autoexec.bat&quot;);</FONT>
<P><FONT FACE="Courier New">someDir = new </FONT><B><FONT FACE="Courier New">File</FONT></B><FONT FACE="Courier New">(&quot;c:\&quot;);</FONT>
<P><FONT FACE="Courier New">otherFile = new </FONT><B><FONT FACE="Courier New">File</FONT></B><FONT FACE="Courier New">(someDir, &quot;config.sys&quot;);</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">파일객체가 파일만 가리키는 것은 아니고 위와 같이 디렉토리도 지칭할 수 있음을 기억하기 바란다. 파일클래스에 있는 많은 유용한 API는 API 문서를 통해 직접 찾아보기 바란다.</FONT>
<P> 
<P><FONT FACE="바탕">다음 프로그램은 C드라이브의 루트 디렉토리 내에 있는 파일 및 디렉토리 목록을 보여주는 예제이다.</FONT>
<BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=320>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">FileList.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<BR>
<P><FONT FACE="Courier New">public class FileList {</FONT>
<BR>
<P>	<FONT FACE="Courier New">public static void main(String[] args) {</FONT>
<P>		<FONT FACE="Courier New">File myFile = new File(&quot;c:/&quot;);</FONT>
<P>		<FONT FACE="Courier New">String[] listing = myFile.list();</FONT>
<BR>
<P>		<FONT FACE="Courier New">for (int i=0; i&lt;listing.length ;i++ ) 		{</FONT>
<P>			<FONT FACE="Courier New">System.out.println(listing[i]);</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT FACE="바탕">다음은 파일클래스의 유용한 메소드를 나타낸 것이다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> 파일이름과 관련된 메소드</FONT></SPAN></FONT>
<P> <FONT FACE="돋움">∘ String getName() : 파일이름을 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ String getPath() : 파일경로를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ String getAbsolutePath() : 파일의 절대경로를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ String getParent() : 파일이 속한 경로를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ boolean renameTo(File newName) : 파일명을 변경한다. 변경하고자 하는 파일이 이미 존재할 경우나, 접근권한 등의 이유로 파일명이 변경되지 않으면 false를 반환한다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> 파일정보를 알아내는 메소드</FONT></SPAN></FONT>
<P> <FONT FACE="돋움">∘ long lastModified() : 마지막으로 수정된 날짜를 long형으로 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ long length() : 파일길이를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ boolean delete() : 파일을 삭제한다. 삭제되지 않으면 false를 반환한다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> 파일을 테스트하는 메소드</FONT></SPAN></FONT>
<P> <FONT FACE="돋움">∘ boolean exist() : 파일의 존재여부를 알아낸다. 파일이 있으면 true, 없으면 false를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ boolean canWrite() : 쓰기 권한을 가졌는지 알아본다. 쓰기 가능하면 true를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ boolean canRead() : 읽을 권한이 있는지를 알아본다.</FONT>
<P> <FONT FACE="돋움">∘ boolean isFile() : 파일인지 알아본다. 파일이면 true를 반환하고, 디렉토리 폴더이면 false를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ boolean isDirectory() : 디렉토리인지 알아본다. 디렉토리이면 true를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ boolean isAbsolute() : 절대경로를 가졌는지 알아본다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕">▒</FONT></SPAN></FONT><FONT SIZE=4><SPAN STYLE="font-size:15pt;"><FONT FACE="바탕"> 디렉토리 관련 메소드</FONT></SPAN></FONT>
<P> <FONT FACE="돋움">∘ boolean mkdir() : 새로운 디렉토리를 만든다. 디렉토리 생성에 실패하면 false를 반환한다.</FONT>
<P> <FONT FACE="돋움">∘ String[] list() : 디렉토리 내의 파일 또는 디렉토리를 반환한다.</FONT>
<BR>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:16pt;"><FONT FACE="HY부활M">8.3.2 URL </FONT><FONT FACE="바탕">객체</FONT></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">파일클래스가 로컬컴퓨터에 있는 파일을 참조한다면 인터넷상에 있는 주소(URL)를 참조할 수 있는 클래스도 있는데 바로 URL 클래스이다. 
</FONT><BR>
<P><FONT FACE="바탕">다음 프로그램은 URL 클래스를 이용하여 인터넷상의 원하는 페이지를 읽어오는 예를 보인 것이다.</FONT>
<BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=408>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">GetIndexHtml.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT>
<P><FONT FACE="Courier New">14:</FONT>
<P><FONT FACE="Courier New">15:</FONT>
<P><FONT FACE="Courier New">16:</FONT>
<P><FONT FACE="Courier New">17:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">import java.net.*;</FONT>
<P><FONT FACE="Courier New">public class GetIndexHtml {</FONT>
<P>	<FONT FACE="Courier New">public static void main(String [] args) throws Exception {</FONT>
<P>		<FONT FACE="Courier New">if (args.length &lt; 2 ) {</FONT>
<P>			<FONT FACE="Courier New">System.out.println(&quot;Usage : java GetIndexHtml </FONT><I><FONT FACE="Courier New">URL file</FONT></I><FONT FACE="Courier New">&quot;);</FONT>
<P>			<FONT FACE="Courier New">return;</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>		<FONT FACE="Courier New">byte [] inputString = new byte[1024];</FONT>
<P>		<B><FONT FACE="Courier New">InputStream is = (new URL(args[0])).openStream();</FONT></B>
<P>		<FONT FACE="Courier New">FileOutputStream fos = new FileOutputStream(args[1]);</FONT>
<P>		<FONT FACE="Courier New">while(is.read(inputString,0,inputString.length) != -1) {</FONT>
<P>			<FONT FACE="Courier New">fos.write(inputString);</FONT>
<P>		<FONT FACE="Courier New">}</FONT>
<P>		<FONT FACE="Courier New">fos.close();</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">10 : URL 클래스의 객체를 생성한다. 생성된 객체의 openStream() 메소드를 호출하면 InputStream객체가 반환된다. 따라서, 인터넷상의 URL을 마치 로컬 컴퓨터의 파일처럼 다룰 수 있다. 
</FONT><BR>
<P><FONT FACE="바탕">앞의 프로그램을 실행시키는 방법은 다음과 같다.</FONT>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=539 HEIGHT=39>
<TD VALIGN=MIDDLE WIDTH=100%>
<P> <FONT FACE="바탕">&gt; java GetIndexHtml  http://java.sun.com  index.html</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P>
<IMG SRC="file:///C|/지빠귀/FYXIV318.GIF" BORDER=0 ALIGN=LEFT><FONT SIZE=5 COLOR=PURPLE><SPAN STYLE="font-size:20pt;"><B><FONT FACE="Bookman Old Style">8.4   RandomAccessFile</FONT></B></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">지금까지 살펴본 입출력 클래스는 순차적으로 데이터를 읽어들인다. 즉, 데이터를 읽다가 다시 앞으로 돌아가서 같은 데이터를 읽는 등의 작업을 할 수 없다. 그런데 이러한 방법을 제공하는 입출력 클래스가 바로 RandomAccessFile이다. 사용법은 다음과 같다.</FONT>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=31>
<TD VALIGN=TOP WIDTH=2%>
<BR></TD>
<TD VALIGN=TOP WIDTH=97%>
<P><FONT FACE="Courier New">RandomAccessFile raf = new RandomAccessFile(&quot;c:\config.sys&quot;, &quot;rw&quot;);</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT FACE="바탕">생성자의 첫 번째 인자는 열고자하는 파일명이다. 이때 파일이름은 문자열형태로 사용할 수도 있지만, 앞에서 설명한 파일객체 형태로 사용할 수도 있다. 두 번째 인자는 open한 파일을 어떻게 접근할 것인가 하는 접근모드를 나타낸다. &quot;r&quot;과 &quot;rw&quot;를 사용할 수 있으며 &quot;r&quot;은 읽기 전용, &quot;rw&quot;는 읽기와 쓰기가 가능한 형태를 나타낸다. 
</FONT><BR>
<P><FONT FACE="바탕">RandomAccessFile가 제공하는 유용한 메소드는 다음과 같다.</FONT>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=75>
<TD VALIGN=TOP WIDTH=2%>
<BR></TD>
<TD VALIGN=TOP WIDTH=97%>
<P><FONT FACE="Courier New">long getFilePointer()  // </FONT><FONT FACE="바탕">현재의</FONT><FONT FACE="Courier New"> file pointer</FONT><FONT FACE="바탕">의</FONT><FONT FACE="Courier New"> </FONT><FONT FACE="바탕">위치를</FONT><FONT FACE="Courier New"> </FONT><FONT FACE="바탕">알아냄</FONT><FONT FACE="Courier New">.</FONT>
<P><FONT FACE="Courier New">void seek(long pos)    // </FONT><FONT FACE="바탕">원하는</FONT><FONT FACE="Courier New"> </FONT><FONT FACE="바탕">위치로</FONT><FONT FACE="Courier New"> file pointer</FONT><FONT FACE="바탕">를</FONT><FONT FACE="Courier New"> </FONT><FONT FACE="바탕">움직임</FONT><FONT FACE="Courier New">.</FONT>
<P><FONT FACE="Courier New">long length()          // file</FONT><FONT FACE="바탕">의</FONT><FONT FACE="Courier New"> size</FONT><FONT FACE="바탕">를</FONT><FONT FACE="Courier New"> </FONT><FONT FACE="바탕">알아냄</FONT><FONT FACE="Courier New">.</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P> 
<P><FONT FACE="바탕">다음 프로그램은 순차파일이 아닌 임의의 파일관리를 위한 예를 보인 것이다. 
</FONT><BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=253>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">WriteLog.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">import java.util.*;</FONT>
<P><FONT FACE="Courier New">public class WriteLog {</FONT>
<P>	<FONT FACE="Courier New">public static void main(String [] args) throws Exception {</FONT>
<P>		<B><FONT FACE="Courier New">RandomAccessFile</FONT></B><FONT FACE="Courier New"> raf = 				new </FONT><B><FONT FACE="Courier New">RandomAccessFile(&quot;myLog.log&quot;, &quot;rw&quot;)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">raf.</FONT><B><FONT FACE="Courier New">seek</FONT></B><FONT FACE="Courier New">(raf.</FONT><B><FONT FACE="Courier New">length()</FONT></B><FONT FACE="Courier New">);</FONT>
<P>		<FONT FACE="Courier New">raf.</FONT><B><FONT FACE="Courier New">writeUTF</FONT></B><FONT FACE="Courier New">(new Date().toString());</FONT>
<P>		<FONT FACE="Courier New">raf.close();</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">5 : RandomAccessFile객체를 만든다. 접근 모드는 &quot;rw&quot;이다. 
</FONT><P><FONT FACE="바탕">6 : 파일포인터를 파일의 맨 뒤로 보낸다. 파일이름에서 알 수 있듯이, 이 파일은 로그(log) 파일이다. 즉, 파일의 뒷부분에 데이터가 계속 기록되는 형태이다. 
</FONT><P><FONT FACE="바탕">8 : 현재시간을 알아내서 그 시간을 파일에 저장한다. writeUTF() 메소드는 16 비트 유니코드 문자를 8 비트 문자로 변경하여 저장하는 메소드로, 메모장에서 열면 내용을 알 수 없으나 한글 등의 문서 편집기를 이용하여 한글 완성형으로 열면 그 내용을 확인할 수 있다.</FONT>
<P>
<IMG SRC="file:///C|/지빠귀/FYXIV319.GIF" BORDER=0 ALIGN=LEFT><FONT SIZE=5 COLOR=PURPLE><SPAN STYLE="font-size:20pt;"><B><FONT FACE="Bookman Old Style">8.5   Serialization</FONT></B></SPAN></FONT>
<BR>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:16pt;"><FONT FACE="HY부활M">8.5.1 Serializable </FONT><FONT FACE="바탕">인터페이스</FONT></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">이제 파일입출력의 마지막 부분에 대해 설명하기로 한다. 많이 사용되는 Serialization은 생성된 객체가 스트림을 통해 이동하는 것을 말한다. 특히 객체가 스트림을 통해 기억장치에 저장되는 것을 영속성(persistent)이라고 한다. 부언하면 메모리에서 생성된 객체를 파일에 저장하는 것을 영속성(일종의 serialization임)라고 한다. 중요한 점은, 이렇게 Serialization되는 클래스는 Serializable이라는 인터페이스를 반드시 implements해야 하지만 이 인터페이스에는 구현할 메소드가 하나도 없다. 따라서 Serializable을 implements하는 것은, 이 클래스가 Serialization이 가능함을 나타내는 표시일 뿐이다. 
</FONT><BR>
<P><FONT FACE="바탕">다음 프로그램은 Person클래스의 객체를 저장하기 위해 Serializable인터페이스를 구현한 예이다.</FONT>
<BR>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=298>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">Person.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">public class Person </FONT><B><FONT FACE="Courier New">implements Serializable</FONT></B><FONT FACE="Courier New"> {</FONT>
<P>	<FONT FACE="Courier New">String name;</FONT>
<P>	<FONT FACE="Courier New">int age;</FONT>
<P>	<FONT FACE="Courier New">String password;</FONT>
<BR>
<P>	<FONT FACE="Courier New">public Person(String name, int age, String password) {</FONT>
<P>		<FONT FACE="Courier New">this.name = name;</FONT>
<P>		<FONT FACE="Courier New">this.age = age;</FONT>
<P>		<FONT FACE="Courier New">this.password = password;</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P><FONT FACE="바탕">중요한 점은 실제 객체가 Serialization될 때, 데이터부분만 Serialization된다는 것이다. 즉, 앞의 Person클래스 객체를 파일로 저장할 때, 실제로 저장되는 것은 멤버 변수 name, age, password같은 데이터만 저장되고, Person()같은 생성자나 메소드코드는 저장되지 않는다는 점이다.</FONT>
<P><FONT FACE="바탕">좀더 구체적인 예를 통해 Serialization에 대해서 알아보자. 앞에서 언급한 Person클래스의 객체를 파일에 저장하는 예제와 다시 파일로부터 읽는 예제를 살펴보자.</FONT>
<BR>
<BR>
<BR>
<BR>
<BR>
<P><FONT FACE="바탕">다음 프로그램은 앞의 SerialExample클래스의 객체를 생성하여 파일에 저장하는 예를 보인 것이다.</FONT>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=364>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">WriteMyObject.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT>
<P><FONT FACE="Courier New">14:</FONT>
<P><FONT FACE="Courier New">15:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">public class WriteMyObject {</FONT>
<BR>
<P>	<FONT FACE="Courier New">public static void main(String [] args) throws Exception {</FONT>
<P>		<FONT FACE="Courier New">Person p1 = new Person(&quot;</FONT><FONT FACE="바탕">홍길동</FONT><FONT FACE="Courier New">&quot;, 32, &quot;hongkd&quot;);</FONT>
<P>		<FONT FACE="Courier New">Person p2 = new Person(&quot;</FONT><FONT FACE="바탕">이순신</FONT><FONT FACE="Courier New">&quot;, 54, &quot;lss5402&quot;);</FONT>
<BR>
<P>		<FONT FACE="Courier New">FileOutputStream fos = new FileOutputStream(&quot;myObject.ser&quot;);</FONT>
<P>		<B><FONT FACE="Courier New">ObjectOutputStream oos = new ObjectOutputStream(fos);</FONT></B>
<BR>
<P>		<B><FONT FACE="Courier New">oos.writeObject(p1)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<B><FONT FACE="Courier New">oos.writeObject(p2)</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">oos.close();</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=48>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P>		<FONT FACE="Courier New">Person p1 = new Person(&quot;</FONT><FONT FACE="바탕">홍길동</FONT><FONT FACE="Courier New">&quot;, 32, &quot;hongkd&quot;);</FONT>
<P>		<FONT FACE="Courier New">Person p2 = new Person(&quot;</FONT><FONT FACE="바탕">이순신</FONT><FONT FACE="Courier New">&quot;, 54, &quot;lss5402&quot;);</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">Person클래스의 객체를 선언하고 생성한다.</FONT>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=53>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P>		<FONT FACE="Courier New">FileOutputStream fos = new FileOutputStream(&quot;myObject.ser&quot;);</FONT>
<P>		<B><FONT FACE="Courier New">ObjectOutputStream oos = new ObjectOutputStream(fos);</FONT></B></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">8 : 파일에 출력하기 위해 FileOutputStream객체를 생성한다. 
</FONT><P><FONT FACE="바탕">9 : 객체를 저장하기 위해 필터스트림인 ObjectOutputStream객체를 생성한다. 
</FONT><P><FONT FACE="바탕">11 : 객체를 저장할 수 있는 writeObject() 메소드는 필터스트림인 ObjectOutputStream에 있다. 따라서 메소드를 사용하려면 필터스트림을 적용할 수밖에 없다. (입출력 클래스의 적용은 대부분 이런 방법으로 이루어진다.)</FONT>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=48>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P>		<FONT FACE="Courier New">oos.writeObject(p1);</FONT>
<P>		<FONT FACE="Courier New">oos.writeObject(p2);</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">ObjectOutputStream에 Person클래스의 객체인 p1과 p2를 저장한다.</FONT>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=31>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">13:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P>		<FONT FACE="Courier New">oos.close();</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">출력 스트림을 닫아준다.</FONT>
<P><FONT FACE="바탕">다음 프로그램은 앞의 WriteMyObject 프로그램을 실행했을 때 나타나는 myObject.ser파일에 저장되어 있는 Person클래스 객체를 읽어들이는 예제이다.</FONT>
<P>
<TABLE BORDER=0 CELLPADDING=2 WIDTH=771 HEIGHT=364>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=92%>
<P><FONT FACE="HY타자B">ReadMyObject.java</FONT></TD>
</tr>
<TR>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT>
<P><FONT FACE="Courier New">7:</FONT>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT>
<P><FONT FACE="Courier New">10:</FONT>
<P><FONT FACE="Courier New">11:</FONT>
<P><FONT FACE="Courier New">12:</FONT>
<P><FONT FACE="Courier New">13:</FONT>
<P><FONT FACE="Courier New">14:</FONT>
<P><FONT FACE="Courier New">15:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">import java.io.*;</FONT>
<P><FONT FACE="Courier New">public class ReadMyObject {</FONT>
<BR>
<P>	<FONT FACE="Courier New">public static void main(String [] args) throws Exception {</FONT>
<P>		<FONT FACE="Courier New">FileInputStream fis = new FileInputStream(&quot;myObject.ser&quot;);</FONT>
<P>		<B><FONT FACE="Courier New">ObjectInputStream ois = new ObjectInputStream(fis);</FONT></B>
<BR>
<P>		<FONT FACE="Courier New">Person p1 = (Person)</FONT><B><FONT FACE="Courier New">ois.readObject()</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">Person p2 = (Person)</FONT><B><FONT FACE="Courier New">ois.readObject()</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">System.out.println(p1.name + &quot;\t&quot; + p1.age + &quot;\t&quot; + p1.password);</FONT>
<P>		<FONT FACE="Courier New">System.out.println(p2.name + &quot;\t&quot; + p2.age + &quot;\t&quot; + p2.password);</FONT>
<BR>
<P>		<FONT FACE="Courier New">ois.close();</FONT>
<P>	<FONT FACE="Courier New">}</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=48>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">5:</FONT>
<P><FONT FACE="Courier New">6:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P>		<FONT FACE="Courier New">FileInputStream fis = new FileInputStream(&quot;myObject.ser&quot;)</FONT>
<P>		<B><FONT FACE="Courier New">ObjectInputStream ois = new ObjectInputStream(fis);</FONT></B></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">5 : 파일로부터 읽기 위해 FileInputStream객체를 생성한다. 
</FONT><P><FONT FACE="바탕">6 : 객체를 읽기 위해 필터스트림인 ObjectInputStream객체를 생성하나. 객체를 읽을 수 있는 메소드인 8번째 줄과 9번째 줄의 readObject() 메소드는 필터스트림인 ObjectInputStream에 있다. 따라서 메소드를 사용하려면 필터스트림을 적용해야 한다. 
</FONT><BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=48>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">8:</FONT>
<P><FONT FACE="Courier New">9:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P>		<FONT FACE="Courier New">Person p1 = (Person)</FONT><B><FONT FACE="Courier New">ois.readObject()</FONT></B><FONT FACE="Courier New">;</FONT>
<P>		<FONT FACE="Courier New">Person p2 = (Person)</FONT><B><FONT FACE="Courier New">ois.readObject()</FONT></B><FONT FACE="Courier New">;</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">8 : ∼ 9 : Person 객체에 myObject.ser파일의 객체를 불러들인다. Person형으로 형 변환하고 있는데, 이는 readObject() 메소드의 반환형이 Object형이기 때문에 실제 객체형인 Person형으로 형 변환이 필요한 것이다.</FONT>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=31>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">13:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P>		<FONT FACE="Courier New">ois.close();</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">입력 스트림을 닫아준다.</FONT>
<BR>
<P><FONT SIZE=4 COLOR=PURPLE><SPAN STYLE="font-size:16pt;"><FONT FACE="HY부활M">8.5.2 transient</FONT></SPAN></FONT>
<BR>
<P><FONT FACE="바탕">이 키워드는 Serializable과 함께 알아 두면 유용하다. 3장에서 잠깐 언급했지만 쓰레드 클래스 객체처럼 serialization 되지 않는 객체변수를 포함한 클래스를 serialization시킬 때나 특정변수를 serialization에서 제외시키고자 할 때 사용하는 제한자이다.</FONT>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=114>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">public class MyClass implements Serializable {</FONT>
<P>	<FONT FACE="Courier New">public </FONT><B><FONT FACE="Courier New">transient</FONT></B><FONT FACE="Courier New"> Thread myThread;</FONT>
<P>	<FONT FACE="Courier New">private String customerID;</FONT>
<P>	<FONT FACE="Courier New">private int total;</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">이 예에서 쓰레드 객체는 원래 serialization이 불가능하므로 transient키워드로 선언한 것이다. 만일 transient가 빠지면 MyClass 클래스는 serialization 되지 않는다.</FONT>
<BR>
<P>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=771 HEIGHT=114>
<TD VALIGN=TOP WIDTH=7%>
<P><FONT FACE="Courier New">1:</FONT>
<P><FONT FACE="Courier New">2:</FONT>
<P><FONT FACE="Courier New">3:</FONT>
<P><FONT FACE="Courier New">4:</FONT>
<P><FONT FACE="Courier New">5:</FONT></TD>
<TD VALIGN=TOP WIDTH=92%>
<P><FONT FACE="Courier New">public class MyClass implements Serializable {</FONT>
<P>	<FONT FACE="Courier New">public transient Thread myThread;</FONT>
<P>	<FONT FACE="Courier New">private</FONT><B><FONT FACE="Courier New"> transient </FONT></B><FONT FACE="Courier New">String customerID;</FONT>
<P>	<FONT FACE="Courier New">private int total;</FONT>
<P><FONT FACE="Courier New">}</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</tr>
</TABLE>
<P><FONT FACE="바탕">이 예에서는 MyClass의 객체를 serialization시킬 때 customerID는 serialization에서 제외한다는 뜻이다. String클래스는 원래 serialization이 가능하므로 transient를 제외시켜도 MyClass는 serialization이 된다.</FONT>
<BR>
<P>
<IMG SRC="file:///C|/지빠귀/FYXIV320.GIF" BORDER=0 ALIGN=LEFT>
<IMG SRC="file:///C|/지빠귀/FYXIV321.GIF" BORDER=0 ALIGN=LEFT>
<IMG SRC="file:///C|/지빠귀/FYXIV322.GIF" BORDER=0 ALIGN=LEFT>
<P ALIGN=RIGHT><FONT SIZE=7 COLOR=WHITE><SPAN STYLE="font-size:35pt;"><FONT FACE="바탕">[네트워크 프로그래밍]</FONT></SPAN></FONT>
<P>
<P>
<BR>
<P><FONT FACE="바탕">네트워크에는 소켓(Socket)이 있는데 소켓은 다음 그림에서처럼 어떤 프로그래밍 모델에서 프로세스 사이의 통신 종단점을 가리킨다. 
</FONT><P ALIGN=CENTER>
<IMG SRC="file:///C|/지빠귀/FYXIV324.GIF" BORDER=0 WIDTH=528 HEIGHT=169 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
<BR>
<P><FONT FACE="바탕">통신이 이루어지려면 먼저 연결설정을 하고 주소를 지정해야 한다. 연결을 설정하려면 한쪽 컴퓨터(서버)는 연결을 대기하는 프로그램을 실행해야 하고, 다른 쪽 컴퓨터(클라이언트)는 서버로 연결을 시도해야 한다. 이때 클라이언트가 서버에 연결되려면 서버주소와 포트번호를 알아야 한다(포트 : 하나의 서버에서 다른 네트워크 서비스를 제공하기 위해서 사용). 포트번호는 TCP/IP시스템에서는 16비트 크기를 가지며 범위는 0∼65535이지만 1023번 이하의 포트(0∼1023) 번호는 시스템이 미리 지정된 서비스용(http : 80, ftp : 21 등)으로 사용하기 때문에 1023번 이하의 포트번호는 사용하지 않는 것이 좋다.</FONT>
<P><FONT FACE="바탕">통신방법은 여러 가지가 있지만 자바에서는 크게 TCP 통신과 UDP통신으로 나눈다.</FONT>
<BR>
<BR>
</body>

</html>
