<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">2.1</P></td>
        <td width="518">
        <p class="TitleTitle">기본 구성 요소</td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>
		<P>여기서는 프로그램의 실행에는 전혀 영향을 미치지 않고 프로그램을 이해하는데 도움을 주는 주석문과 키워드, 그리고 8개의 기본데이터 유형과 한 개의 참조 데이터 유형에 대해 알아보기로 한다.
		<P>모든 프로그램 언어에서와 마찬가지로 매우 중요하게 사용되는 배열에 대해서도 상술하고자 한다.
		</ul>
		<P class="TSubmenu">2.1.1 주석문과 기본 원칙
		<ul>
		<P>주석문을 잘 사용하면 추후 프로그램을 분석하는데 매우 유익하다. 일반적으로 프로그램을 작성할 때는 알고리즘을 분석한 상태이기 때문에 프로그램의 모든 부분을 상세히 파악하고 있지만 시간이 지나고 업무가 달라진 상태에서 예전에 작성한 프로그램을 빠른 시간내에 이해하기는 매우 어려워진다. 따라서, 가능한한 프로그램을 작성할 때 많은 주석문을 만들어 주는 기본 원칙을 지키는 것이 시간과 노력을 절감하는 지름길인 것이다.
		<P>2.1.1.1 주석문(Comment)
		<P>주석문은 프로그램의 실행에는 전혀 영향을 미치지 않는 문장으로서, 프로그램의 이해를 도와주는데 주로 사용된다. 주석문을 사용하는 방법은 다음 세 가지가 있다.
		<P>▶  // 한 줄 주석
		<P>▶  /* 한 줄 또는 여러 줄 주석 */
		<P>▶  /** document 생성용 주석 */
		<P>//는 주석 내용이 한 줄일 때 편리하다. //는 줄의 어느 위치에나 올 수 있으며, 이 부호 바로 다음부터 그 줄의 끝까지의 내용이 주석으로 간주된다.
		<P>/* */는 주로 여러 줄의 주석문을 만들 때 사용된다. 즉, /*와 */ 사이에 있는 모든 내용이 주석으로 간주된다.
		<P>/** */는 온라인 설명서용 주석인데 일반적으로 변수나 메소드 등의 선언문 바로 앞에 오며, javadoc 명령에 의해 자동으로 생성되는 설명서용 html 파일에 주석 내용이 포함된다. javadoc은 JDK 안에 들어있는 utility로 패키지, 클래스 등의 설명서를 만들 때 사용된다.
		<P>2.1.1.2 세미콜론(;), 블록(Block), 공백(Whitespace)
		<P> ▶ 논리적인 한 문장이 끝날 때 반드시 세미콜론(;)을 붙여준다.  이는 파스칼과 동일하다.
		<P> ▶ 블록은 괄호(curly brace), 즉 &quot;{&quot; 와 &quot;}&quot;로 묶여진 부분을 말하며, 복합문을 구성하는 요소이다.
		<P> &nbsp;&nbsp; 즉, 종속된 문장이 다수개일 때 &quot;{&quot;로 시작하고 &quot;}&quot; 닫아준다. 이는 파스칼의 begin∼end와 같다. 
		<P> ▶ 공백(Whitespace)은 빈칸, 탭, 빈 줄 등이 있으며, 이러한 공백은 소스 코드를 보기 좋게 하고 알아보기 쉽게 하는데 사용된다. 즉, 프로그램을 구조화 형태로 표현하는데 유용하다.
		<P>2.1.1.3 식별자(Identifier)
		<P>자바 언어에서 식별자는 클래스 명, 메소드 명, 변수 명 등 사용자가 만들어 이용하는 고유한 이름을 식별자라고 하며 다음과 같은 몇 가지 규칙을 반드시 지켜야 한다.
		<P> ▶ 대.소문자를 구분하고, 길이에는 제한이 없다.
		<P> ▶ 유니코드 문자나 &quot;_(underscore)&quot;, &quot;$&quot;로 시작한다. 즉, 숫자로 시작하면 안 되며,  특수문자(!, @, # 등...) 중에서는 &quot;_&quot;과 &quot;$&quot;만 시작할 때 사용할 수 있다. 그러나 &quot;_&quot;와 &quot;$&quot;의 경우는 식별자에 이 기호를 포함시키라는 로컬 시스템의 규칙이 있거나 부득이한 경우가 아니면 사용하지 않는 것이 좋다. 또한 유니코드를 지원하기 때문에 한글 사용이 가능하지만 ASCII 코드를 사용하는 것이 좋다.
		<P> ▶ 첫 문자 외에는 문자, 숫자, 밑줄, 달러기호 등을 임의의 순서로 사용할 수 있다.
		<P> ▶ 키워드는 식별자로 사용할 수 없다.
		<P>다음은 잘못된 식별자의 예로서 컴파일 시 오류가 발생한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=17%>
			<P class="TStep1" ALIGN=CENTER>잘못된 예
			<TD WIDTH=83%>
			<P class="TStep1" ALIGN=CENTER>설    명</TD>
		</tr>
		<TR>
			<TD WIDTH=17%>
			<P class="TStep1" ALIGN=CENTER>3test
			<P class="TStep1" ALIGN=CENTER>@test
			<P class="TStep1" ALIGN=CENTER>this</TD>
			<TD WIDTH=83%>
			<p class="TStep1">식별자는 숫자로 시작하면 안 된다.
			<p class="TStep1">식별자의 첫 문자에 올 수 있는 특수문자는 &quot;_&quot;와 &quot;$&quot;뿐이다.
			<p class="TStep1">this는 키워드이다. 키워드는 식별자로 사용할 수 없다.</TD>
		</tr>
		</TABLE>
		<P>다음은 올바른 사용 예를 보인 것이다.
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=17%>
			<P class="TStep1" ALIGN=CENTER>바른 예
			<TD WIDTH=83%>
			<P class="TStep1" ALIGN=CENTER>설    명</TD>
		</tr>
		<TR>
			<TD WIDTH=17%>
			<P class="TStep1" ALIGN=CENTER>test3
			<P class="TStep1" ALIGN=CENTER>_test
			<P class="TStep1" ALIGN=CENTER>This</TD>
			<TD WIDTH=83%>
			<p class="TStep1">숫자는 식별자의 첫 문자만 아니면 어느 곳이나 올 수 있다.
			<p class="TStep1">&quot;_&quot;는 식별자의 첫 문자로 사용할 수 있다.
			<p class="TStep1">This는 자바에서 사용되는 this와는 다르다.(대/소문자 구분)</TD>
		</tr>
		</TABLE>
		<P>2.1.1.4 코딩 규칙(Naming Conventions)
		<P>코딩을 할 때 식별자에 관련된 아래와 같은 몇 가지 규정이 있다. 꼭 아래와 같은 형식을 따르라는 것은 아니고 이는 프로그램의 이해도를 높이기 위한 프로그래머들간의 규칙이라고 생각하면 된다. 가능하면 클래스 이름이나 변수 이름, 메소드 이름 등을 만들 때에 이러한 규칙으로 만들기를 권장한다.
		<P>  ▶ 클래스 이름/인터페이스 이름
		<P>- 명사나 형용사를 서술적으로 연결하여 사용한다.
		<P>- 첫 글자는 대문자로 표기한다.
		<P>- 연결된 단어의 첫 글자도 대문자로 표기한다.
		<P>- 나머지 문자는 소문자로 표기한다.
		<P>- &quot;$&quot;은 내부 클래스에서 특별한 의미가 있기 때문에 사용을 권장하지 않는다.
		<P>이상의 규칙을 적용한 예를 들면 다음과 같다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<p class="TStep1">class ClassOne { }
			<p class="TStep1">class MyCalss { }
			<p class="TStep1">interface Account { }</TD>
		</tr>
		</TABLE>
		<P>  ▶ 변수 이름
		<P>- 명사적 의미를 갖게 한다.
		<P>- 첫 글자는 소문자, 연결 단어의 첫 글자는 대문자로 표기한다.
		<P>- 일반적으로 변수 이름에서는 &quot;_(underscore character)&quot;를 사용하지 않는다.
		<P>이상의 규칙을 적용한 예를 들면 다음과 같다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<p class="TStep1">int variableOne;
			<p class="TStep1">String customerName;</TD>
		</tr>
		</TABLE>
		<P>    ▶ 메소드 이름
		<P>- 동사적 의미를 갖게 한다.
		<P>- 첫 글자는 소문자, 연결 단어의 첫 글자는 대문자로 표기한다.
		<P>- 메소드 이름 뒤에는 한 쌍의 괄호&quot;()&quot;　가 온다.
		<P>- 일반적으로 메소드 이름에서는 &quot;_(underscore character)&quot;를 사용하지 않는다.
		<P>이상의 규칙을 적용한 예를 들면 다음과 같다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<p class="TStep1">int methodOne() { }
			<p class="TStep1">void printTheResults() { }</TD>
		</tr>
		</TABLE>
		<P>  ▶ 상수 이름
		<P>- 모든 문자는 대문자로 표기한다.
		<P>- 단어와 단어 사이는 &quot;_&quot;(underscore characters)로 연결한다.
		<P>이상의 규칙을 적용한 예를 들면 다음과 같다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<p class="TStep1">final int CONSTANT_ONE = 1234;
			<p class="TStep1">final double PI = 3.141592;</TD>
		</tr>
		</TABLE>
		<P>  ▶ 제어문
		<P>- if∼else 문이나 for 문과 같은 제어문은 단일 명령문이라 하더라도 괄호({ }) 안에 넣는다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<p class="TStep1">if (condition) {
			<p class="TStep2">do something1;
			<p class="TStep1">} else {
			<p class="TStep2">do something2;
			<p class="TStep1">}</TD>
		</tr>
		</TABLE>
		<P>  ▶ 빈칸
		<P>- 하나의 줄에는 하나의 명령문만 기술하고 4칸 또는 탭으로 들여 쓰기를 하면 코드를 알아보기 쉽다.
		<P>  ▶ 주석
		<P>- 의미가 분명하지 않은 코드 부분에 주석을 사용한다.
		<P>- 한 줄에 해당하는 주석을 넣을 때는 주석 구분 기호 //를 사용한다.
		<P>- 여러 줄의 주석을 사용할 때는 주석 구분 기호 /* ... */를 사용한다.
		<P>- 온라인 설명서용 주석을 넣을 때에 /** ... */를 구분 문자로 사용하면 나중에 유지 보수 작업을 하는 사람들이 javadoc으로 만든 API를 사용할 수 있다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<p class="TStep1">// 한 라인 차지하는 주석
			<p class="TStep1">/* 길이가 한 라인 이상 길어져서
			<p class="TStep1">&nbsp;&nbsp;&nbsp;여러 라인의 공간을 차지하는 주석 */
			<p class="TStep1">/** 온라인 설명서(API Document)용 주석 */</TD>
		</tr>
		</TABLE>
		<P>다음의 예제를 보자
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=9%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:</TD>
			<TD WIDTH=90%>
			<P class="CStep1">public class <B>WizardBank</B> {
			<P class="CStep2">public static void <B>main</B> (String[] args) {
			<P class="CStep3">int <B>customerAccount</B> = 10;
			<P class="CStep2">} // end main method
			<P class="CStep1">} // end class</TD>
		</tr>
		</TABLE>
		<P>위의 예에서 WizardBank는 클래스 명, main은 메소드 명, customerAccount는 변수 명을 나타낸다.
		</ul>
		<P class="TSubmenu">2.1.2 키워드와 리터럴(Literal)
		<ul>
		<P>다음은 자바에서 사용되는 키워드를 나타낸 것이다. 식별자에 키워드를 넣을 수는 있지만 그렇다고 키워드를 식별자로 사용해서는 안 된다. 예를 들어 &quot;finalSample&quot;은 유효한 식별자이지만 &quot;final&quot;은 그렇지 않다.
		<P>아래의 목록에서 true, false, null 등이 있지만 엄격히 말해서 이러한 것은 키워드가 아니라 리터럴이다. 자바에서 true, false, null 등의 리터럴은 C언어의 리터럴과 같은 대문자가 아니라 소문자이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=19%>
			<P ALIGN=CENTER>abstract
			<P ALIGN=CENTER>assert
			<P ALIGN=CENTER>boolean
			<P ALIGN=CENTER>break
			<P ALIGN=CENTER>byte
			<P ALIGN=CENTER>case
			<P ALIGN=CENTER>catch
			<P ALIGN=CENTER>char
			<P ALIGN=CENTER>class
			<P ALIGN=CENTER>continue</TD>
			<TD WIDTH=19%>
			<P ALIGN=CENTER>default
			<P ALIGN=CENTER>do
			<P ALIGN=CENTER>double
			<P ALIGN=CENTER>else
			<P ALIGN=CENTER>extends
			<P ALIGN=CENTER>false
			<P ALIGN=CENTER>final
			<P ALIGN=CENTER>finally
			<P ALIGN=CENTER>float
			<P ALIGN=CENTER>for</TD>
			<TD WIDTH=20%>
			<P ALIGN=CENTER>if
			<P ALIGN=CENTER>implement
			<P ALIGN=CENTER>import
			<P ALIGN=CENTER>instanceof
			<P ALIGN=CENTER>int
			<P ALIGN=CENTER>interface
			<P ALIGN=CENTER>long
			<P ALIGN=CENTER>native
			<P ALIGN=CENTER>new
			<P ALIGN=CENTER>null	</TD>
			<TD WIDTH=20%>
			<P ALIGN=CENTER>package
			<P ALIGN=CENTER>private
			<P ALIGN=CENTER>protected
			<P ALIGN=CENTER>public
			<P ALIGN=CENTER>return
			<P ALIGN=CENTER>short
			<P ALIGN=CENTER>static
			<P ALIGN=CENTER>strictfp
			<P ALIGN=CENTER>super
			<P ALIGN=CENTER>switch</TD>
			<TD WIDTH=19%>
			<P ALIGN=CENTER>synchronized
			<P ALIGN=CENTER>this
			<P ALIGN=CENTER>throw
			<P ALIGN=CENTER>throws
			<P ALIGN=CENTER>transient
			<P ALIGN=CENTER>true
			<P ALIGN=CENTER>try
			<P ALIGN=CENTER>void
			<P ALIGN=CENTER>volatile
			<P ALIGN=CENTER>while</TD>
		</tr>
		</TABLE>
		<P>* const와 goto는 키워드이지만 자바에서는 사용하지 않는다.
		</ul>
		<P class="TSubmenu">2.1.3 자료형
		<ul>
		<P>자바는 8개의 기본데이터 유형과 한 개의 참조(Reference) 데이터 유형을 사용한다. 이 유형의 데이터들은 리터럴 값이나 변수로 사용될 수 있다. 이 중 기본 데이터 유형은 네 가지 종류, 즉 논리형(Logical), 텍스트형(Textual), 정수형(Integral), 부동 소수점형(Floating point) 등으로 구분할 수 있다. 
		<P>다음 표에 나와 있는 유형 중에서 String을 제외하고는 모두 기본 데이터 유형에 속한다. String은 Reference형으로 문자열을 표현할 때 문자열 객체를 사용하여 처리할 수 있도록 String 클래스를 따로 지원하고 있다. 
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=18%></td>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>유 형</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>크 기</TD>
			<TD WIDTH=46%>
			<P ALIGN=CENTER>범 위</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>초기값</TD>
		</tr>
		<TR>
			<TD ROWSPAN=4 WIDTH=18%>
			<P ALIGN=CENTER>정수형
			<P ALIGN=CENTER>Integral</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>byte</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>1 byte</TD>
			<TD WIDTH=46%>
			<P>&nbsp;-2^7 SIM 2^7 -1<P>(-128 ~ 127)</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>short</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>2 byte</TD>
			<TD WIDTH=46%>
			<P>
			&nbsp;-2^15 SIM 2^15 -1<P>(-32,768 ~ 32,767)</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>int</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>4 byte</TD>
			<TD WIDTH=46%>
			<P>&nbsp;-2^31 SIM 2^31 -1<P>(-2,147,483,648 ~ 2,147,483,647)</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>long</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>8 byte</TD>
			<TD WIDTH=46%>
			<P>&nbsp;-2^63 SIM 2^63 -1<P>(-9,223,372,036,854,775,808 ~
			<P>  9,223,372,036,854,775,807)</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>0L</TD>
		</tr>
		<TR>
			<TD ROWSPAN=2 WIDTH=18%>
			<P ALIGN=CENTER>실수형
			<P ALIGN=CENTER>Floating-Point</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>float</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>4 byte</TD>
			<TD WIDTH=46%>
			<P>&plusmn;(1.401e-45F ~ 3.402e+38F)
			<P>(7자리의 소수)</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>0.0F</TD>
		</tr>
		<TR>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>double</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>8 byte</TD>
			<TD WIDTH=46%>
			<P>&plusmn;(4.940e-324 ~ 1.797e+308)
			<P>(15자리의 소수)</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>0.0D</TD>
		</tr>
		<TR>
			<TD WIDTH=18%>
			<P ALIGN=CENTER>논리형
			<P ALIGN=CENTER>Logical</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>boolean</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>1 bit</TD>
			<TD WIDTH=46%>
			<P>true 또는 false</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>false</TD>
		</tr>
		<TR>
			<TD ROWSPAN=2 WIDTH=18%>
			<P ALIGN=CENTER>문자형
			<P ALIGN=CENTER>Textual</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>char</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>2 byte</TD>
			<TD WIDTH=46%>
			<P>\u0000 ∼ \uFFFF</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>'\u0000'</TD>
		</tr>
		<TR>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>String</TD>
			<TD WIDTH=11%>
			<P ALIGN=CENTER>variable</TD>
			<TD WIDTH=46%>
			<P>각 위치에서 \u0000 ∼ \uFFFF</TD>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>null</TD>
		</tr>
		<TR>
			<TD COLSPAN=2 WIDTH=30%>
			<P ALIGN=CENTER>All reference type</TD>
			<TD WIDTH=11%>
			</td>
			<TD WIDTH=46%>
			</td>
			<TD WIDTH=12%>
			<P ALIGN=CENTER>null</TD>
		</tr>
		</TABLE>
		<P>2.1.3.1 정수형
		<P>정수형에는 4가지 유형이 있는데, byte, short, int, long 등의 키워드를 사용하여 선언한다. 정수형은 10진수, 8진수, 16진수 등의 형태로 표현한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>IntegerExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class IntegerExample {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">int decimalValue = 7;
			<P class="CStep3">int octalValue = 077;
			<P class="CStep3">int hexaValue = 0xFEFE;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">3:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">int decimalValue = 17;</TD>
		</tr>
		</TABLE>
		<P>십진수 7을 대입한 것이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">4:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">int octalValue = 077;</TD>
		</tr>
		</TABLE>
		<P>첫 머리에 붙은 0(Zero)은 8진수 값임을 표시하는 것이다. 실제로 octalValue에는 8진수 77의 십진수 값인 63이 저장된다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">int hexaValue = 0xFEFE;</TD>
		</tr>
		</TABLE>
		<P>첫 머리에 붙은 0x는 16진수 값임을 표시하는 것이다. hexaValue에는 16진수 FEFE의 십진수 값인 65278값이 저장된다.
		<P>다음은 4가지 정수형의 크기와 범위를 타나낸 것이다. 범위는 2의 보수로 정의되며, 플랫폼에 관계없이 사용할 수 있다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=558>
			<TD WIDTH=13%>
			<P ALIGN=CENTER>유형</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>저장크기</TD>
			<TD WIDTH=57%>
			<P ALIGN=CENTER>범위</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>초기값</TD>
		</tr>
		<TR>
			<TD WIDTH=13%>
			<P ALIGN=CENTER>byte</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>1 byte</TD>
			<TD WIDTH=57%>
			<P ALIGN=CENTER>
			&nbsp;-2^7 SIM 2^7 -1<P ALIGN=CENTER>(-128 ~ 127)</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=13%>
			<P ALIGN=CENTER>short</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>2 byte</TD>
			<TD WIDTH=57%>
			<P align="center">-2^15 SIM 2^15 -1&nbsp;<P ALIGN=CENTER>(-32,768 ~ 32,767)</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=13%>
			<P ALIGN=CENTER>int</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>4 byte</TD>
			<TD WIDTH=57%>
			<P align="center">-2^31 SIM 2^31 -1&nbsp;<P ALIGN=CENTER>(-2,147,483,648 ~ 2,147,483,647)</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=13%>
			<P ALIGN=CENTER>long</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>8 byte</TD>
			<TD WIDTH=57%>
			<P align="center">-2^63 SIM 2^63 -1&nbsp;<P ALIGN=CENTER>(-9,223,372,036,854,775,808 ~
			<P ALIGN=CENTER>  9,223,372,036,854,775,807)</TD>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>0L</TD>
		</tr>
		</TABLE>
		<P>다음의 예를 보자
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>IntegerTypeExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class IntegerTypeExample {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">byte b = 214748364;
			<P class="CStep3">short s = 214748364;
			<P class="CStep3">int i = 214748364;
			<P class="CStep3">long l = 214748364;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>정수형 다음에 &quot;L&quot;자가 붙지 않으면 모두 int형이며, 대문자 &quot;L&quot;이나 소문자 &quot;l&quot;을 붙여 주면 long형 값임을 표시하는 것으로, 대문자와 소문자 모두 사용할 수 있지만 소문자를 사용하면 숫자 1과 구분하기 어렵기 때문에 사용하지 않는 것이 좋다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">3:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">byte b = 214748364;</TD>
		</tr>
		</TABLE>
		<P>컴파일 시 오류가 발생한다. byte형 변수 b에 넣을 값인 214748364가 최대 범위를 벗어나기 때문이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">4:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">short s = 214748364;</TD>
		</tr>
		</TABLE>
		<P>컴파일 시 오류가 발생한다. short형 변수 s에 넣을 값 214748364이 byte형의 최대 범위를 벗어나기 때문이다.
		<P>3번째 줄과 4번째 줄의 경우 오류가 발생하지 않게 하려면 숫자 앞에 (byte)와 (short)를 넣어서 강제로 숫자를 캐스팅(Casting)해서 범위를 축소시켜야 한다. 물론 값을 출력하면 전혀 다른 값이 나올 수 있다. 캐스팅에 관해서는 뒤에서 자세히 설명하기로 한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">3:
			<P class="CNumber">4:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">byte b = <B>(byte)</B>214748364;
			<P class="CStep1">short s = <B>(short)</B>214748364;</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">int i = 214748364;</TD>
		</tr>
		</TABLE>
		<P>정상적으로 컴파일 된다. int형 변수의 i에 넣고자 값인 214748364가 int형의 표현 범위에 맞기 때문이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">long l = 214748364;</TD>
		</tr>
		</TABLE>
		<P>정상적으로 컴파일 된다. long형 변수의 l에 넣고자 하는 값 214748364가 long형의 표현 범위에 맞기 때문이다. 위의 경우 보다 올바른 표기법은 숫자 뒤에 long형임을 나타내는 &quot;L&quot;을 붙여 주는 것이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">long l = 214748364<B>L</B>;</TD>
		</tr>
		</TABLE>
		<P>정수형은 8진수, 10진수, 16진수를 사용하여 입력할 수 있다. 10진수의 경우 앞에 0(Zero)이 아닌 숫자로 시작하여 표기하고 0∼9까지의 숫자를 사용한다. 8진수는 숫자 앞에 0을 붙이고, 0∼7까지의 숫자를 사용한다. 16진수는 16진수 숫자 앞에 0x 또는 0X를 붙이고, 숫자 표기를 위한 알파벳은 대/소문자를 구분하지 않는다. 16진수는 0∼9, A∼F까지의 숫자를 사용한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=33%>
			<P ALIGN=CENTER>10진수</TD>
			<TD WIDTH=33%>
			<P ALIGN=CENTER>8진수</TD>
			<TD WIDTH=33%>
			<P ALIGN=CENTER>16진수</TD>
		</tr>
		<TR>
			<TD WIDTH=33%>
			<P ALIGN=CENTER>int i = 65</TD>
			<TD WIDTH=33%>
			<P ALIGN=CENTER>int i = 0101</TD>
			<TD WIDTH=33%>
			<P ALIGN=CENTER>int i = 0x41
			<P ALIGN=CENTER>int i = 0X41</TD>
		</tr>
		<TR>
			<TD WIDTH=33%>
			<P ALIGN=CENTER>int i = 97</TD>
			<TD WIDTH=33%>
			<P ALIGN=CENTER>int i = 0141</TD>
			<TD WIDTH=33%>
			<P ALIGN=CENTER>int i = 0x61
			<P ALIGN=CENTER>int i = 0X61</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<p class="TStep1">정수형 변수의 연산</TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<p class="TStep1">정수형 변수에 있어서 int형 보다 작은 자료형(byte, short)의 연산은 int형
			<p class="TStep1">으로의 묵시적 형 변환이 일어난다. 다음의 예는 컴파일시 오류가 발생한다.
			<p class="TStep1">	short a, b, c;
			<p class="TStep1">	a = 1;
			<p class="TStep1">	b = 2;
			<p class="TStep1">	c = a + b;	//Error
			<p class="TStep1">위의 예에서는 변수 a와 b의 연산 결과를 다음과 같이
			<p class="TStep1">캐스팅(Casting)해 주어야 한다.
			<p class="TStep1">	c = (short)(a + b);</TD>
		</tr>
		</TABLE>
		<P>2.1.3.2 실수형
		<P>실수형에는 2가지가 있는데, float, double 키워드를 사용하여 선언하며  IEEE754 표준을 따르는 근사값을 사용하여 표현된다. 실수형은 디폴트형이 double이므로 float형으로 지정하려면 숫자 뒤에 &quot;F&quot; 또는 &quot;f&quot;를 붙여준다. 또한 정확히 하기 위해 double형 뒤에 &quot;D&quot;또는 &quot;d&quot;를 붙여 주기도 하는데, 소수점 표현 방식인 10진수형 표현방식과, 과학 기술용 지수함수 표기법인 의사코드(Pseudo-scientific) 방식이 있다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=539>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>유형</TD>
			<TD WIDTH=13%>
			<P ALIGN=CENTER>크기</TD>
			<TD WIDTH=56%>
			<P ALIGN=CENTER>범    위</TD>
			<TD WIDTH=15%>
			<P ALIGN=CENTER>초기값</TD>
		</tr>
		<TR>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>float</TD>
			<TD WIDTH=13%>
			<P ALIGN=CENTER>4 byte</TD>
			<TD WIDTH=56%>
			<P ALIGN=CENTER>&plusmn;(1.401e-45F ~ 3.402e+38F)
			<P ALIGN=CENTER>(7자리의 소수)</TD>
			<TD WIDTH=15%>
			<P ALIGN=CENTER>0.0F</TD>
		</tr>
		<TR>
			<TD WIDTH=14%>
			<P ALIGN=CENTER>double</TD>
			<TD WIDTH=13%>
			<P ALIGN=CENTER>8 byte</TD>
			<TD WIDTH=56%>
			<P ALIGN=CENTER>&plusmn;(4.940e-324 ~ 1.797e+308)
			<P ALIGN=CENTER>(15자리의 소수)</TD>
			<TD WIDTH=15%>
			<P ALIGN=CENTER>0.0D</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>RealExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class RealExample {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">float f = 1.1;	//Error
			<P class="CStep3">double d = 1.1;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">3:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">float f = 1.1;	//Error</TD>
		</tr>
		</TABLE>
		<P>컴파일 시 오류가 발생한다. 실수의 상수 표현형은 무조건 double형인데, float형 변수에 double형 값을 넣으려고 했기 때문에 발생한 것이다. 3번째 줄의 경우에 오류가 발생하지 않게 하려면 다음과 같이 숫자 뒤에 float형 숫자임을 명시해 주는 &quot;F&quot; 또는 &quot;f&quot;를 넣어야 한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">3:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">float f = 1.1<B>F</B>;</TD>
		</tr>
		</TABLE>
		<P>2.1.3.3 논리형
		<P>논리형 값에는 &quot;true&quot;와 &quot;false&quot; 두 가지 상태가 있는데 이를 boolean형이라고 한다. 정수형과 논리형은 서로 캐스팅 처리할 수 없으며, C언어에서는 숫자 값을 논리 값으로 해석하여, 0을 false로 다루고 0이 아닌 값은 true로 다루지만 자바에서는 허용되지 않는다. 
		<P>다음은 boolean 변수 선언문과 대입문의 예이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>BooleanExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class BooleanExample {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">boolean one = false;
			<P class="CStep3">boolean two = False;		//Error
			<P class="CStep3">boolean three = &quot;false&quot;;	//Error
			<P class="CStep3">boolean four = 1;			//Error
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">3:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">boolean one = false;</TD>
		</tr>
		</TABLE>
		<P>올바른 대입문이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">4:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">boolean two = False;		//Error</TD>
		</tr>
		</TABLE>
		<P>잘못된 대입문이다. 리터럴(literal)은 모두 소문자여야 한다. False는 false와 엄연히 다른데, 대문자와 소문자를 확실히 구분하기 때문이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">boolean three = &quot;false&quot;;	//Error</TD>
		</tr>
		</TABLE>
		<P>잘못된 대입문이다. 6번째 줄은 &quot;false&quot;라는 문자열 값을 boolean형 변수에 대입하려고 하기 때문에 컴파일 오류가 발생한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">boolean four = 1;			//Error</TD>
		</tr>
		</TABLE>
		<P>잘못된 대입문이다. C언어에서는 가능하지만 자바에서는 boolean형 변수에는 오로지 true 또는 false 중 하나만 대입이 가능하다.
		<P>다음은 각 데이터 타입별 최소값과 최대값을 알아보기 위한 예이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>DataTypeSize.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">16:
			<P class="CNumber">17:
			<P class="CNumber">18:
			<P class="CNumber">19:
			<P class="CNumber">20:
			<P class="CNumber">21:
			<P class="CNumber">22:
			<P class="CNumber">23:
			<P class="CNumber">24:
			<P class="CNumber">25:
			<P class="CNumber">26:
			<P class="CNumber">27:
			<P class="CNumber">28:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class DataTypeSize {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">System.out.println(&quot;\n byte type&quot;);
			<P class="CStep3">System.out.println(&quot;\tMin : &quot; + Byte.MIN_VALUE);
			<P class="CStep3">System.out.println(&quot;\tMax : &quot; + Byte.MAX_VALUE);
			<P class="CStep3">System.out.println(&quot;\n short type&quot;);
			<P class="CStep3">System.out.println(&quot;\tMin : &quot; + Short.MIN_VALUE);
			<P class="CStep3">System.out.println(&quot;\tMax : &quot; + Short.MAX_VALUE);
			<P class="CStep3">System.out.println(&quot;\n int type&quot;);
			<P class="CStep3">System.out.println(&quot;\tMin : &quot; + Integer.MIN_VALUE);
			<P class="CStep3">System.out.println(&quot;\tMax : &quot; + Integer.MAX_VALUE);
			<P class="CStep3">System.out.println(&quot;\n long type&quot;);
			<P class="CStep3">System.out.println(&quot;\tMin : &quot; + Long.MIN_VALUE);
			<P class="CStep3">System.out.println(&quot;\tMax : &quot; + Long.MAX_VALUE);
			<P class="CStep3">System.out.println(&quot;\n float type&quot;);
			<P class="CStep3">System.out.println(&quot;\tMin : &quot; + Float.MIN_VALUE);
			<P class="CStep3">System.out.println(&quot;\tMax : &quot; + Float.MAX_VALUE); 
			<P class="CStep3">System.out.println(&quot;\n double type&quot;);
			<P class="CStep3">System.out.println(&quot;\tMin : &quot; + Double.MIN_VALUE);
			<P class="CStep3">System.out.println(&quot;\tMax : &quot; + Double.MAX_VALUE);
			<P class="CStep3">System.out.println(&quot;\n char type&quot;);
			<P class="CStep3">System.out.println(&quot;\tMin : &quot; + Character.MIN_VALUE);
			<P class="CStep3">System.out.println(&quot;\tMax : &quot; + Character.MAX_VALUE); 
			<P class="CStep3">System.out.println();
			<P class="CStep3">System.out.println(&quot; boolean : &quot; + Boolean.TRUE); 
			<P class="CStep3">System.out.println(&quot; boolean : &quot; + Boolean.FALSE);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>2.1.3.4 문자(char)형 및 문자열(String)형
		<P>단일 문자는 char형으로 표현한다. char형은 0∼216의 범위 내에서 부호가 없는 16비트(2바이트) 숫자를 사용하여 유니 코드 문자를 표현한다. 리터럴 char형은 홑 따옴표(' ')안에 넣어야 한다.
		<P>String형은 하나의 클래스이며, 일련의 문자열을 표현하는데 사용된다. 문자 자체는 유니 코드지만, char형으로 되어 있는 탈출시퀸스(escape sequence) 스타일도 String형에서 사용할 수 있다. String형은 겹 따옴표(&quot; &quot;)안에 넣는다.
		<P>다음은 문자 선언문과 대입문의 예를 보인 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TextualExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TextualExample {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">char one = 'A';
			<P class="CStep3">char two = '\t';
			<P class="CStep3">char three = '\u????';  //????대신 16진수 4자리 입력
			<P class="CStep3">String four = &quot;\u???? \u????&quot;;
			<P class="CStep3">String five = &quot;dream&quot;;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">3:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">char ont = 'A';</TD>
		</tr>
		</TABLE>
		<P>일반적인 아스키문자를 대입한 예이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">4:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">char two = '\t';</TD>
		</tr>
		</TABLE>
		<P>탭과 같은 특수문자는 탈출시퀀스로 표현할 수 있다.
		<P>다음은 탈출 시퀀스를 나타낸 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=558>
			<TD WIDTH=10%>
			<P ALIGN=CENTER>\n</TD>
			<TD WIDTH=39%>
			<P ALIGN=CENTER>New Line(\u000A)</TD>
			<TD WIDTH=10%>
			<P ALIGN=CENTER>\f</TD>
			<TD WIDTH=39%>
			<P ALIGN=CENTER>Form Feed(\u000C)</TD>
		</tr>
		<TR>
			<TD WIDTH=10%>
			<P ALIGN=CENTER>\t</TD>
			<TD WIDTH=39%>
			<P ALIGN=CENTER>Tab(\u0009)</TD>
			<TD WIDTH=10%>
			<P ALIGN=CENTER>\\</TD>
			<TD WIDTH=39%>
			<P ALIGN=CENTER>Backslash(\u005C)</TD>
		</tr>
		<TR>
			<TD WIDTH=10%>
			<P ALIGN=CENTER>\b</TD>
			<TD WIDTH=39%>
			<P ALIGN=CENTER>Backspace(\u0008)</TD>
			<TD WIDTH=10%>
			<P ALIGN=CENTER>\'</TD>
			<TD WIDTH=39%>
			<P ALIGN=CENTER>Single Quote(\u0027)</TD>
		</tr>
		<TR>
			<TD WIDTH=10%>
			<P ALIGN=CENTER>\r</TD>
			<TD WIDTH=39%>
			<P ALIGN=CENTER>Return(\u000D)</TD>
			<TD WIDTH=10%>
			<P ALIGN=CENTER>\&quot;</TD>
			<TD WIDTH=39%>
			<P ALIGN=CENTER>Double Quote(\u0022)</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">char three = '\u????';</TD>
		</tr>
		</TABLE>
		<P>유니코드를 이용하여 문자를 나타낸 것이다. ???? 는 4개의 16진수 숫자로 표현된다. 예를 들어 '\u03A6'을 입력하면 Φ(phi)를 나타낸다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">String four = &quot;\u???? \u????&quot;;</TD>
		</tr>
		</TABLE>
		<P>유니코드를 이용하여 연속된 문자열을 문자를 나타내는 것이다. ???? 는 4개의 16진수 숫자로 표현된다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">String five = &quot;dream&quot;;</TD>
		</tr>
		</TABLE>
		<P>일반적인 문자열의 할당문이다. char형이 아스키를 포함한 유니코드를 지원하는 16비트(2바이트) 크기를 차지하기 때문에 String에서도 각각의 문자는 영문자라 할 지라도 16비트(2바이트) 크기를 차지한다. String은 C나 C++과는 달리 끝에 null 문자('\0')가 포함되지 않는다. 그러므로 7번째 줄의 String값은 영문자 다섯 글자이지만 10바이트를 차지한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<p class="TStep1">유니코드(16비트-유니코드)</TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<p class="TStep1">&bull; 공식적으로는 &quot;세계문자 표준 - 유니코드&quot;라고 불리며, 이 코드체계는 세계
        <p class="TStep1"> 각국의 다양한 언어로 작성된 문자에 대해 상호교환, 처리, 및 표현을 용이
        <p class="TStep1">하게 하기 위한 시스템이다. 유니코드는 16비트로 표현되며, 현재 유니코드 
        <p class="TStep1">표준은 24개 언어를 지원하기 위해 34,168개의 개별 코드문자를 담고 있는데,
        <p class="TStep1"> 이 문자는 세계 주요 언어로 작성된 문서를 모두 표현하기에 충분하며, 여러
        <p class="TStep1"> 가지 언어로 작성된 고문서(古文書)까지도 지원할 수 있다.
 </TD>
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">2.1.4 배열(array)
		<ul>
		<P>배열은 데이터형이 아닌 객체이기 때문에 C언어와 같이 배열에서 각각의 배열 요소를 포인터로 취급하여 연산할 수 없다. 이는 자바를 더욱 견고하고, 신뢰할 수 있는 코드를 만들 수 있도록 한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=418>
			<TD WIDTH=2%></td>
			<TD WIDTH=97%>
			<p class="TStep1"><I>type name</I>[];
			<p class="TStep1"><I>name</I> = new <I>type</I>[<I>array_size</I>];
			<p class="TStep1">  또는
			<p class="TStep1"><I>type</I>[]<I> name</I> = new <I>type</I>[<I>array_size</I>];</TD>
		</tr>
		</TABLE>
		<P>자바에서는 배열도 일종의 자료형이기 때문에 대괄호(&quot;[]&quot;)가 배열 이름의 앞에 오는 것이 가능하다. 이후의 배열은 대괄호(&quot;[]&quot;)를 배열 이름 앞에 표기하기로 한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=418>
			<TD WIDTH=2%></td>
			<TD WIDTH=97%>
			<p class="TStep1"><I>type</I><B>[]</B><I> name</I>;
			<p class="TStep1">  또는
			<p class="TStep1"><I>type</I><B>[]</B><I> name</I> = new <I>type</I>[<I>array_size</I>];</TD>
		</tr>
		</TABLE>
		<P>배열은 기본 데이터형, 객체 참조형, 또는 다른 배열의 순차적인 집합체라고 할 수 있으며, 반드시 한 가지 형으로 지정해야 하며 이는 다른 언어에서도 마찬가지다. 즉 여러 데이터 형을 혼합하여 사용할 수 없다.
		<P>배열은 다음과 같이 선언, 생성, 초기화의 과정을 통하여 만들어진다.
		<P>▶ 1 단계 : 선언
		<P>▶ 데이터형이나 객체 참조형을 배열 변수를 지정함으로써 배열을 선언한다.
		<P>      
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<p class="TStep1">int[] aa;		// int형으로 배열 선언
			<p class="TStep1">int aa[];		// int[] aa; 와 같다.
			<p class="TStep1">float[] bb;		// float형으로 배열 선언
			<p class="TStep1">Point[] cc;		// 객체 참조형으로 배열 선언</TD>
		</tr>
		</TABLE>
		<P>    ▶ 선언시에는 배열의 크기를 명시할 수 없다.
		<P>      
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<p class="TStep1">int[6] aa;		// 선언시에 크기를 지정하면 컴파일 오류발생</TD>
		</tr>
		</TABLE>
		<P>  ▶ 2 단계 : 생성
		<P>    ▶ 생성은 new 키워드를 이용, 배열의 크기를 명시하여 지정된 크기만큼의 배열을 메모리에 생성시킨다. 배열의 생성과정은 런타임(runtime) 시에 일어난다.
		<P>      
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<p class="TStep1">int[] aa;		// int형으로 배열 선언
			<p class="TStep1">aa = new int[10];	// 배열 변수에 크기를 명시하여 객체 생성</TD>
		</tr>
		</TABLE>
		<P>      위의 배열 aa의 경우 aa[0] ∼ aa[9]까지 모두 10개의 공간을 생성한다.
		<P>    ▶ 배열의 생성 과정은 선언과정과 함께 긴 줄로 지정이 가능하다. 위의 문장은 다음과 같이 표현 할 수 있다.
		<P>      
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<p class="TStep1">int[] aa = new int[10];	//선언과 동시 배열 선언</TD>
		</tr>
		</TABLE>
		<P>    ▶ 다차원 배열의 경우 배열을 생성할 때 주의해야 한다.
		<P>      
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<p class="TStep1">올바른 예</TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<p class="TStep1">int[][] aa;		// int[] 배열형에 대한 크기가 명시되어 
			<p class="TStep1">aa = new int[10][];	// 있으므로 컴파일이 잘 된다.</TD>
		</tr>
		</TABLE>
		<P>      
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<p class="TStep1">잘못된 예 - 컴파일 오류</TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<p class="TStep1">int[][] aa;		// int[10] 배열형에 대한 크기가 명시되어
			<p class="TStep1">aa = new int[][10];	// 있지 않으므로 인스턴스 생성이 안 된다.</TD>
		</tr>
		</TABLE>
		<P>▶ 3 단계 : 초기화
		<P>▶ 배열의 초기화 과정은 배열의 생성과 동시에 자동으로 일어난다. 다음 표는 각 배열의 초기화 값을 나타내고 있다.
		<P>      
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=404>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>배열 변수형</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>초기 값</TD>
		</tr>
		<TR>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>byte</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>short</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>int</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>0</TD>
		</tr>
		<TR>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>long</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>0L</TD>
		</tr>
		<TR>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>float</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>0.0F</TD>
		</tr>
		<TR>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>double</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>0.0D</TD>
		</tr>
		<TR>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>boolean</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>false</TD>
		</tr>
		<TR>
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>char</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>'\u0000'</TD>
		</tr>
		<TR>	
			<TD WIDTH=48%>
			<P class="TStep1" ALIGN=CENTER>object reference</TD>
			<TD WIDTH=51%>
			<P class="TStep1" ALIGN=CENTER>null</TD>
		</tr>
		</TABLE>
		<P>▶ 사용자가 직접 배열을 초기화시킬 수 도 있다. 사용자가 초기화 작업을 하면 배열의 선언, 생성, 초기화 과정을 한 줄로 지정할 수 있다. 다차원 배열의 경우 같은 단위의 값끼리 중괄호 &quot;{&quot;와 &quot;}&quot;로 묶어주면 된다.
		<P>      
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<p class="TStep1">int[] aa = {10, 20, 30, 40, 50}	// 1차원 배열(크기 5)
			<p class="TStep1">float[][] bb = { {0.5f, 1.3f, 1.8f}, {2.3, 3.6, 5.2} };
			<p class="TStep1">// 2차원 배열(2행 3열)</TD>
		</tr>
		</TABLE>
		<P>다음은 배열 사용 예를 나타낸 것이다.
		<P>  
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>PrimitiveArrayExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class PrimitiveArrayExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">char[] s;	//Primivive형 배열 선언
			<P class="CStep1">// char[5] s2;	//오류 - 선언시 크기 명시 못함
			<P class="CStep3">s = new char[5];	//Primivive형 배열 생성
			<P class="CStep3">s[0] = 'A';	//Primitive형 배열은 생성 후 바로 값 할당
			<P class="CStep3">s[1] = 'B';
			<P class="CStep3">s[2] = 'C';
			<P class="CStep3">s[3] = 'D';
			<P class="CStep3">s[4] = 'E';
			<P class="CStep3">for(int i=0; i&lt;s.length; i++) {
			<P class="CStep4">System.out.print(&quot;\t&quot; + s[i]);
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult"><B>실행 결과</B></td>
		</tr>
		<tr>
			<td width="242">
			<P class="Result">A B C D E</td>
		</tr>
		</table>
		<P>다음은 Reference 타입 배열 사용 예를 보이고 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ReferenceArrayExample.java</TD>
		</tr>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">16:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class ReferenceArrayExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">java.awt.Point[] p;	//Reference형 배열 선언
			<P class="CStep1">//java.awt.Point[5] p2; //오류발생 - 선언시 크기 명시 못함
			<P class="CStep3">p = new java.awt.Point[5];	//Reference형 배열 생성
			<P class="CStep3">p[0] = new java.awt.Point(0, 1);
			<P class="CStep3">p[1] = new java.awt.Point(7, 6);
			<P class="CStep3">p[2] = new java.awt.Point(9, 6);
			<P class="CStep3">p[3] = new java.awt.Point(0, 8);
			<P class="CStep3">p[4] = new java.awt.Point(2, 3);
			<P class="CStep1">//Reference형 배열은 생성 후 객체를 생성하여 값을 할당
			<P class="CStep3">for(int i=0; i&lt;p.length; i++) {
			<P class="CStep4">System.out.println(p[i]);
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult"><B>실행 결과</B></td>
		</tr>
		<tr>
			<td width="242">	
			<P class="Result">java.awt.Point[x=0,y=1]
			<P class="Result">java.awt.Point[x=7,y=6]
			<P class="Result">java.awt.Point[x=9,y=6]
			<P class="Result">java.awt.Point[x=0,y=8]
			<P class="Result">java.awt.Point[x=2,y=3]</td>
		</tr>
		</table>
		<P>다음은 두 개 이상의 배열이 같은 배열 요소를 참조하고 있는 예를 보인 것이다. 8번째 줄에서는 배열 array2에 array1의 reference를 갖게 한 다음 array2의 0번째 배열 값과 2번째 배열 값을 각각 0과 2로 바꾸었다. 그런 다음 array2를 출력하는 것이 아니고 array1을 다시 출력하였을 때 결과를 보면 array1의 배열 내용도 바뀐 것을 알 수 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ArrayReferExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">16:
			<P class="CNumber">17:
			<P class="CNumber">18:
			<P class="CNumber">19:
			<P class="CNumber">20:
			<P class="CNumber">21:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class ArrayReferExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int[] array1 = { 2, 3, 5, 7, 11, 13, 17, 19 };
			<P class="CStep3">int[] array2;
			<P class="CStep3">printArray(array1);
			<P class="CStep3">array2 = array1;
			<P class="CStep3">array2[0] = 0;
			<P class="CStep3">array2[2] = 2;
			<P class="CStep3">printArray(array1);
			<P class="CStep2">}
			<P class="CStep2">public static void printArray(int[] array) {
			<P class="CStep3">System.out.print('&lt;');
			<P class="CStep3">for ( int i=0; i&lt;array.length; i++ ) {
			<P class="CStep4">System.out.print(array[i]);
			<P class="CStep4">if( i+1 &lt; array.length) {
			<P class="CStep5">System.out.print(&quot; , &quot;);
			<P class="CStep4">}
			<P class="CStep3">}
			<P class="CStep3">System.out.println('&gt;');
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="350" cellpadding="0" cellspacing="0">
		<tr>
			<td width="300"><P class="RResult"><B>실행 결과</B></td>
		</tr>
		<tr>
			<td width="300">
			<P class="Result">&lt;2 , 3 , 5 , 7 , 11 , 13 , 17 , 19&gt;
			<P class="Result">&lt;0 , 3 , 2 , 7 , 11 , 13 , 17 , 19&gt;</td>
		</tr>
		</table>
		<P><B>실행 결과</B>
		<P>다음은 배열 요소를 복사하는 예를 나타낸 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ArrayCopyExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class ArrayCopyExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep2">int source[] = { 1, 2, 3, 4, 5, 6 };
			<P class="CStep2">int destin[] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
			<P class="CStep2">System.arraycopy(source, 0, destin, 0, source.length);
			<P class="CStep2">for( int i=0; i&lt;destin.length; i++)
			<P class="CStep3">System.out.print(destin[i] + &quot;\t&quot;);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="300"><P class="RResult"><B>실행 결과</B></td>
		</tr>
		<tr>
			<td width="300">
			<P class="Result">1 2 3 4 5 6 3 2 1 &nbsp;&nbsp; 0</td>
		</tr>
		</table>
		<p>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<P class="TStep1">배열에서 사용할 수 있는 유용한 내용</TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<p class="TStep1">&bull; 배열의 길이를 알 수 있는 .length
			<p class="TStep1">배열 이름 뒤에 .length를 붙이면 배열의 크기를 얻을 수 있다. .length()
        <p class="TStep1">처럼 뒤에 괄호가 붙으면 안된다. 예를 들어 위의 2차원 배열 크기를 알고 
        <p class="TStep1">싶을 때는 bb.length라고 하면된다. 물론 화면에 그 크기를 출력하려면 다
        <p class="TStep1">음과 같이한다.

			<p class="TStep1">	System.out.println(bb.length);
			<p class="TStep1">&bull; 배열값을 복사하는 System.arraycopy()
			<p class="TStep1">배열내용을 복사해 주는 메소드가 System 클래스 내에 static변수로 선언되어
        <p class="TStep1"> 있다. 메소드 선언은 다음과 같다.

			<p class="TStep1">	arraycopy(Object src, int src_position, 
			<p class="TStep1">		Object dst, int dst_position, int length)
			<p class="TStep1">다음의 예를 보자
			<p class="TStep1">	int[] source = { 1, 2, 3, 4, 5, 6 };
			<p class="TStep1">	int[] destin = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
			<p class="TStep1">	System.arraycopy(source, 0, destin, 3, 4);
			<p class="TStep1">이와 같이하면  source 배열의 0번째 이후 원소 4개를 destin 배열의 3번째
        <p class="TStep1"> 이후 원소에 복사하라는 뜻이다. 이후의 destin 배열값은 { 9, 8, 7, 1, 2,
        <p class="TStep1"> 3, 4, 2, 1, 0 }이 된다.
   </TD>
		</tr>
		</TABLE>
		<P>  
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=100%>
			<P class="TStep1">System.out.println();</TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<p class="TStep1">도스 창에 문자열을 출력하고 줄을 바꾸는 기능을 한다. 나중에 알겠지만 여
	        <p class="TStep1">기에서 System은 클래스 이름이고, out은 변수 이름, 그리고 println은 메
		    <p class="TStep1">소드 이름을 나타낸다. println() 메소드는 PrintStream 클래스에 선언되어
			<p class="TStep1"> 있는 메소드로서 System 클래스의 out 변수타입이다.
			<p class="TStep1">&bull; 특정문자열을 출력하려면 출력할 문자열을 &quot; &quot;로 감싸준다. 
			<p class="TStep1">System.out.println(&quot;Hello. Java&quot;);
			<p class="TStep1">&bull; 변수값을 출력하려면 &quot; &quot;로 감싸지 않고 변수로 표기해준다.
			<p class="TStep1">int x = 10;
			<p class="TStep1">System.out.println(x);
			<p class="TStep1">&bull; 특정 문자열과 변수값을 동시에 출력하려면 둘 사이를 +(plus)로 연결해준다. 
			<p class="TStep1">int x = 10;
			<p class="TStep1">System.out.println(&quot;x의 값은 : &quot; + x + &quot;입니다&quot;);
			<p class="TStep1">&bull; 도스 창으로 문자열을 출력하고 줄을 바꾸는 기능을 하지 않으려면
			  <p class="TStep1"> System.out.print()를 이용한다. </TD>	
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">2.1.5 변수와 초기화
		<ul>
		<P>프로그램을 작성할 때 가장 많이 사용하는 것이 변수일 것이다. 자바에는 3가지 범위의 변수가 있는데, 변수가 있는 위치에 따라서 지역변수(Local variable)와 멤버변수(Member variable), 그리고 선언되는 형식에 의한 전역변수(Global variable)로 나눌 수 있다.
		<P>  ▶ 지역변수
		<P>    지역변수는 메소드 안에 선언된 변수를 말하며 사용자가 직접 초기화를 해주어야 한다. 지역변수를 선언하고 초기화를 하지 않으면 오류가 발생한다. 지역변수는 local 대신에 automatic, temporary 또는 stack이라고도 부른다.
		<P>지역변수의 생성 시점은 해당 메소드가 수행 될 때이며, 메소드 수행이 끝나면 변수는 메모리에서 없어진다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>LocalVariableExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class LocalVariableExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int a;
			<P class="CStep3">System.out.println(a); //Error
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">4:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">System.out.println(a);</TD>
		</tr>
		</TABLE>
		<P>2번째 줄에서 선언만 하고 초기화를 하지 않았으므로 컴파일시에 오류가 발생한다. 지역변수를 선언과 동시에 초기화 할 필요는 없으나 사용하기 전에는 반드시 초기화를 해 주어야 한다.
		<P>  ▶ 멤버변수
		<P>    멤버변수는 클래스 안에 선언된 변수를 말하며, 사용자가 초기화시키지 않아도 시스템에 의해서 자동으로 초기화된다. 하지만 프로그램의 정확성을 위해 직접 초기화하는 습관이 필요하다. 멤버변수가 자동으로 초기화될 때 초기값은 배열에서의 예와 같다. 멤버변수를 참조하기 위해 static으로 선언되어있지 않을 경우에는 객체를 생성한 후 참조해야 한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>MemberVariableExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class MemberVariableExample {
			<P class="CStep2">int a;
			<P class="CStep2">static int b;
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">System.out.println(a); //Error
			<P class="CStep3">System.out.println(b);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">2:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">int a;</TD>
		</tr>
		</TABLE>
		<P>멤버변수는 초기값을 지정하지 않아도 자동으로 초기화된다. 일반 멤버변수의 경우 클래스의 생성자가 실행되기 직전에 초기화가 이루어진다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">3:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">static int b;</TD>
		</tr>
		</TABLE>
		<P>멤버변수 중에서 static은 객체가 동일 데이터 공간을 참조하여 공유변수가 된다. 따라서, 변수나 메소드를 static으로 선언하면 객체를 생성하지 않고도 접근이 가능하다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">System.out.println(a); //Error
			<P class="CStep1">System.out.println(b);</TD>
		</tr>
		</TABLE>
		<P>5 : 오류가 발생하는데, 멤버변수의 경우 static으로 선언하지 않고 static으로 선언된 메소드 안에서 참조할 때는 반드시 객체를 생성한 후 참조해야한다. 
		<P>6 : 3번째 줄에서 선언된 변수 b가 static으로 선언되었기 때문에 바로 참조할 수 있다. 2번째 줄 2에서 선언된 변수 a를 참조하기 위해 5번째 줄을 다음과 같이 객체를 생성한 후 사용하여야 한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:	</td>
			<TD WIDTH=92%>
			<P class="CStep1">MemberVariableExample me;
			<P class="CStep1">me = new MemberVariableExample();
			<P class="CStep1">System.out.println(me.b);</TD>
		</tr>
		</TABLE>
</ul>
		<ul></td>
	</tr>
	</table>
</body>
</html>