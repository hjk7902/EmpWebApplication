<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">

	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">2.2</P></td>
        <td width="518">
        <p class="TitleTitle" align="left">&nbsp;연산자</p></td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>        
		<P>연산자는 변수의 값을 변경하거나 대입하는데 사용된다. 일반적인 연산과는 달리 연산자에 따라 연산 대상이 될 수 있는 데이터형이 정해져 있다. 예를 들면, 조건 연산자의 경우 논리형만을 사용할 수 있고, 비트 연산자인 경우에는 정수형만 사용할 수 있다.
		<P>범위를 벗어나는 연산 즉, 오버플로(overflow) 또는 언더플로(underflow)에 대해서는 오류가 나지 않고, 단지 연산 결과에 불필요한 값이 저장된다. 예를 들어 바이트형인 경우 127에 1을 더하면 128이 아니고 -127이 된다. 연산에서 오류가 발생하는 경우는 나눗셈이나 나머지 연산의 경우 분모가 0(Zero)이 될 때이다. 
		<P>다음은 자바에서 사용하는 연산자와 이들의 우선 순위를 나타낸 것이다. 우선 순위란 두개 이상의 연산이 결합된 복합연산의 경우 실행순서를 말하는 것으로, 다음 표에서는 위의 것일수록 우선 순위가 높은 것을 나타낸다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=13%>
			<P  class="TStep1" ALIGN=CENTER>우선
			<P  class="TStep1" ALIGN=CENTER>순위</TD>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>연산자</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>연산자 설명</TD>
		</tr>
		<TR>
			<TD ROWSPAN=10 WIDTH=13%>
			<P  class="TStep1" ALIGN=CENTER>높음↑
			<P  class="TStep1" ALIGN=CENTER>&nbsp;
			<P  class="TStep1" ALIGN=CENTER>&nbsp;
			<P  class="TStep1" ALIGN=CENTER>우
			<P  class="TStep1" ALIGN=CENTER>선
			<P  class="TStep1" ALIGN=CENTER>순
			<P  class="TStep1" ALIGN=CENTER>위
			<P  class="TStep1" ALIGN=CENTER>&nbsp;
			<P  class="TStep1" ALIGN=CENTER>&nbsp;
			<P  class="TStep1" ALIGN=CENTER>낮음↓</TD>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>( )  [ ]
			<P  class="TStep1" ALIGN=CENTER>.</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>괄호
			<P  class="TStep1" ALIGN=CENTER>소수점/참조 연산자</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>++, --
			<P  class="TStep1" ALIGN=CENTER>+, -
			<P  class="TStep1" ALIGN=CENTER>!
			<P  class="TStep1" ALIGN=CENTER>~
			<P  class="TStep1" ALIGN=CENTER>(type)</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>증/감 연산자(증가, 감소)
			<P  class="TStep1" ALIGN=CENTER>부호
			<P  class="TStep1" ALIGN=CENTER>논리 연산자(반전)
			<P  class="TStep1" ALIGN=CENTER>비트 연산자(반전)
			<P  class="TStep1" ALIGN=CENTER>형 변환</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>*, /, %</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>산술 연산자(곱셈,나눗셈,나머지)</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>+, -</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>산술 연산자(덧셈, 뺄셈)</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>&lt;&lt;, &gt;&gt;, &gt;&gt;&gt;</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>비트 이동 연산자
			<P  class="TStep1" ALIGN=CENTER>(좌, 우, 우(부호 포함))</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>&lt;, &lt;=, &gt;, &gt;=
			<P  class="TStep1" ALIGN=CENTER>==, !=
			<P  class="TStep1" ALIGN=CENTER>instanceof</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>비교 연산자(대/소 비교)
			<P  class="TStep1" ALIGN=CENTER>비교 연산자(동/이 비교)
			<P  class="TStep1" ALIGN=CENTER>type 연산자(객체 형 비교)</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>&amp;, |, ^</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>비트 연산자(AND, OR, XOR)
			<P  class="TStep1" ALIGN=CENTER>논리 연산자(AND, OR, XOR)</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>&amp;&amp;, ||</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>논리 연산자(Short Circuit)</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>?:</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>논리연산자(3항 연산자)</TD>
		</tr>
		<TR>
			<TD WIDTH=39%>
			<P  class="TStep1" ALIGN=CENTER>=
			<P  class="TStep1" ALIGN=CENTER>+=, -+, *=, /=, %=
			<P  class="TStep1" ALIGN=CENTER>&lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=
			<P  class="TStep1" ALIGN=CENTER>&amp;=, ^=, |=</TD>
			<TD WIDTH=47%>
			<P  class="TStep1" ALIGN=CENTER>대입 연산자
			<P  class="TStep1" ALIGN=CENTER>연산 후 대입 연산자
			<P  class="TStep1" ALIGN=CENTER>연산 후 대입 연산자
			<P  class="TStep1" ALIGN=CENTER>연산 후 대입 연산자</TD>
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">2.2.1 단항연산자(Unary operator)
		<ul>
		<P>단항연산자는 피 연산자가 하나인 연산자를 말한다. 단항연산자는 변수의 앞이나 뒤에 붙어서 변수 값을 하나 증가시키거나 감소시킬 때 사용하는 증가/감소 연산자와 양수와 음수를 나타내는 부호 연산자, 비트의 값을 바꾸어주는 비트 반전 연산자, 논리 대수의 값을 반전시켜주는 논리 반전 연산자, 그리고 형을 바꾸어주는 캐스트 연산자가 있다.
		<P>2.2.1.1 증가/감소 연산자(Increment and Decrement operaotor) : ++, --
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="350">
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>++</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>증가 연산자(값 1 증가)</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>--</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>감소 연산자(값 1 감소)</TD>
		</tr>
		</TABLE>
		<P>이 연산자는 변수의 앞이나 뒤에 붙어서 사용되는데, 연산자가 변수의 앞에 붙을 때는 변수 값이 증가 또는 감소 후 사용되고, 연산자가 변수의 뒤에 붙을 때에는 변수의 값이 사용된 후에 변수의 값이 증가 또는 감소한다.
		<P>다음 프로그램은 증가/감소 연산자의 사용 예를 나타낸 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>UnaryOperator.java</TD>
		</tr>
		</TABLE>
		<TABLE WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class UnaryOperator {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">int i=1, j=0;
			<P class="CStep3">j = i++;
			<P class="CStep3">System.out.println(&quot;후위 연산자&quot;);
			<P class="CStep3">System.out.println(&quot;i의 값은 &quot; + i);
			<P class="CStep3">System.out.println(&quot;j의 값은 &quot; + j);
			<P class="CStep3">int x=1, y=0;
			<P class="CStep3">y = ++x;
			<P class="CStep3">System.out.println(&quot;\n전위 연산자&quot;);
			<P class="CStep3">System.out.println(&quot;x의 값은 &quot; + x);
			<P class="CStep3">System.out.println(&quot;y의 값은 &quot; + y);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult"><B>실행 결과</B></td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">후위 연산자
			<P class="Result">i의 값은 2
			<P class="Result">j의 값은 1
			<P class="Result">전위 연산자
			<P class="Result">x의 값은 2
			<P class="Result">y의 값은 2</td>
		</tr>
		</table>
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">3:
			<P class="CNumber">4:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">int i=1, j=0;
			<P class="CStep1">j = i++;</TD>
		</tr>
		</TABLE>
		<P>증가/감소 연산자가 변수의 뒤에 왔으므로 변수 j에는 변수 i의 처음 값인 1이 입력된다. 그 후 i값이 증가하여 i값은 2가 된다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">7:
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">int x=1, y=0;
			<P class="CStep1">y = ++x;</TD>
		</tr>
		</TABLE>
		<P>증가/감소 연산자가 변수의 앞에 온 경우이다. 이 경우에는 변수 y에 값이 대입 되기 전에 x 값이 증가된다. 그러므로 x 값이 증가되어 2가 되고, 그 증가된 값이 대입 되므로 y는 2가 된다.
		<P>2.2.1.2 부호 연산자 : +, -
		<P>이 연산자는 피 연산자의 앞에 위치하여 양수인지 음수인지를 지정한다. +를 생략하면 기본 지정은 양수이다. 2항 연산자의 산술 연산을 하는 +, -와는 다르다.  
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="350">
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>+</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>양수 표현</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>-</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>음수 표현</TD>
		</tr>
		</TABLE>
		<P>2.2.1.3 비트 반전 과 논리 반전 연산자 : ~, !
		<P>먼저 비트 연산자인 ~는 피연산자의 앞에 사용되어 피연산자를 2진수로 바꾼 다음 2진수의 각 비트를 0은 1로, 1은 0으로 모두 반전시킨다. 그리고 !는 논리 대수를 반전시킨다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=356>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>~</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>2진수의 각 비트(0, 1)을 반전</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>!</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>논리 값(true, false)을 반전</TD>
		</tr>
		</TABLE>
		<P>2.2.1.4 캐스트 연산자 : (type)
		<P>캐스트 연산자는 괄호안에 바꾸고자 하는 데이터형을 지정함으로써 해당 데이터의 형으로 변환시키는 연산을 수행한다. 형변환을 수행하기 위해서는 변수나 값 앞에 새로운 자료형을 다음과 같이 지정한다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=356>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>(type)</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>데이터형을 강제로 바꿈</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>CastOperator1.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class CastOperator1 {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">byte a = 100;
			<P class="CStep3">int  b = a; //Promotion
			<P class="CStep3">byte c = <B>(byte)</B>b; //Type Casting
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>크기가 작은 데이터형을 크기가 큰 데이터형으로 변환할 때는 캐스트 연산자를 지정하지 않아도 컴파일러에 의해 자동으로 수행(묵시적 형 변환 : Promotion)이 가능하지만, 크기가 큰 데이터형을 크기가 작은 데이터형으로 변환할 때에는 반드시 캐스트 연산자를 사용하여 변환될 데이터형을 명시(명시적 형 변환 : Type Casting)해야 한다. 그렇지 않으면 컴파일시 오류가 발생한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>CastOperator2.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class CastOperator2 {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int  a = 1522;
			<P class="CStep3">byte b = (byte)a; //Type Casting
			<P class="CStep3">System.out.println( b ); //-14 출력됨
			<P class="CStep3">double d = 3.6;
			<P class="CStep3">a = (int)d;
			<P class="CStep3">System.out.println( a ); //3 출력됨
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">-14
			<P class="Result">3</td>
		</tr>
		</table>
		<P>형 변환시 크기가 작은 자료형에서 큰 자료형으로 변환할 때는 값이 손실되지 않지만, 크기자 작은 자료형에서 큰 자료형으로 변환할 때는 윗 부분(high order bit)이 잘려나가 값이 손실된다. 예를 들어 int값 5를 byte형으로 형 변환할 때 값의 손실이 발행하지 않지만, 256을 byte형으로 형 변환하면 범위를 벗어나므로 엉뚱한 값이 저장된다. 또 정수 자료형은 실수 자료형으로 형 변환이 가능하지만, 부동 소수점을 정수로 변환할 때는 소수점 첫째 자리에서 버림을 한다. 즉 1.5를 정수로 변환하면 1이 되고, -1.5를 정수로 변환하면 -1이 된다.
		<P>  
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<P class="TStep1">High order bit</TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<p class="TStep1">2진수를 표현했을 때 왼쪽 부분을 상위 비트(high order bit), 오른쪽 부
        <p class="TStep1">분을 하위 비트(low order bit)라 한다. 정수 5와 256을 byte형으로 형 </p>
        <p class="TStep1">변환하였을 경우</p>

			<p class="TStep1">&bull; 5를 int형으로 표현하면
			<p class="TStep1">	00000000 00000000 00000000 00000101 이 된다
			<p class="TStep1">여기서 byte형으로 형 변환하면 왼쪽 상위 비트 중 24비트가 잘려 나가는데,
        <p class="TStep1"> 이 경우 byte형으로 변환한 후에도</p>
 
			<p class="TStep1">	00000101 이 되어서 그대로 5의 값을 갖게 된다.
			<p class="TStep1">&bull; 256을 int형으로 표현하면
			<p class="TStep1">	00000000 00000000 00000001 00000000 이 된다
			<p class="TStep1">여기서 byte형으로 형 변환하면 왼쪽 상위 비트 중 24비트가 잘려 나가게 
        <p class="TStep1">되는데, byte형으로 변환한 후에는 00000000 이 되어서 전혀 다른 0의 값을</p>
        <p class="TStep1"> 갖게 된다.</p>
</TD>
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">2.2.2 2항 연산자(Binary operator)
		<ul>
		<P>2항 연산자는 피 연산자(operand)가 두 개인 연산자를 말한다. 연산자가 int형(4바이트) 보다 작은 크기의 데이터형일 경우 boolean형을 제외하고는 모두 int형으로 변환되어 연산을 수행한다.
		<P>2.2.2.1 산술 연산자(Arithmetic operator) : +, -, *, /, %
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=356>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>+</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>덧셈</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>-</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>뺄셈</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>*</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>곱셈</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>/</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>나눗셈</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>%</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>나머지 연산(결과는 항상 정수)</TD>
		</tr>
		</TABLE>
		<P>덧셈, 뺄셈, 곱셈, 나눗셈은 수학에서의 연산과 동일하고, 나머지 연산자는 피젯수를 젯수로 나눈 나머지 값을 구하는 연산이다. 나머지 연산의 실제 계산은 피젯수에서 젯수를 계속 빼서 피젯수의 값이 젯수의 값보다 작아질 때의 피젯수의 값이 최종적으로 나머지 연산의 값이 된다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<P class="TStep1">int a = 7;
			<P class="TStep1">int b = a % 3;</TD>
		</tr>
		</TABLE>
		<P>7을 3으로 나눈 나머지 값인 1이 된다.
		<P>원칙적으로 연산자 중복은 허용되지 않지만 +연산의 경우는 예외라고 할 수 있다. 덧셈 연산에서 String 객체의 경우 문자열을 연결하는 집합 연산자로 사용되는데, 이때 연산의 방향은 왼쪽에서 오른쪽으로 진행된다. 예를 들면 다음과 같다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>OperatorOverloading.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class OperatorOverloading {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">String s1 = &quot;Sun&quot;;
			<P class="CStep3">String s2 = &quot;day&quot;;
			<P class="CStep3">int a = 20;
			<P class="CStep3">int b = 30;
			<P class="CStep3">System.out.println(s1 + s2);
			<P class="CStep3">System.out.println(s1 + a);
			<P class="CStep3">System.out.println(a + b + s1 + s2);
			<P class="CStep3">System.out.println(s1 + s2 + a + b);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">Sunday
			<P class="Result">Sun20
			<P class="Result">50Sunday
			<P class="Result">Sunday2030</td>
		</tr>
		</table>
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">System.out.println(s1 + s2);</TD>
		</tr>
		</TABLE>
		<P>s1의 문자열인 &quot;Sun&quot;과 s2의 문자열인 &quot;day&quot;를 연결하여 출력한다. 
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">System.out.println(s1 + a);</TD>
		</tr>
		</TABLE>
		<P>문자열과 숫자를 + 연산하려고 한다. 문자열과 숫자의 +연산이 있을 경우 숫자가 문자열로 변하게 된다. 그러므로 a의 값 20은 숫자가 아닌 문자 20이 되고 출력 결과는 Sun20이 출력된다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">System.out.println(a + b + s1 + s2);</TD>
		</tr>
		</TABLE>
		<P>결과가 50Sunday라고 출력되는데, 이유는 같은 우선 순위를 가진 연산자가 있을 때는 연산순서가 왼쪽에서 오른쪽으로 진행되기 때문에 먼저 정수 a 값 20과 b 값 30이 먼저 계산되어 50이 되고, 그 다음 문자열과 더해진다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">System.out.println(s1 + s2 + a + b);</TD>
		</tr>
		</TABLE>
		<P>9번째 줄과는 반대로 문자열이 먼저 더해지므로 결과는 Sunday2030이 된다.
		<P>2.2.2.2 비교 연산자(Comparison operator) : &lt;, &lt;=, &gt;, &gt;=, ==, !=
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=525>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>a &lt; b</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>b가 a보다 크면 true</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>a &lt;= b</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>b가 a보다 크거나 같으면 true</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>a &gt; b</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>a가 b보다 크면 true</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>a &gt;= b</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>a가 b보다 크거나 같으면 true</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>a == b</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>a와 b가 같으면 true(조건문에서 유용)</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>a != b</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>a와 b가 같지 않으면 true</TD>
		</tr>
		<TR>
			<TD WIDTH=24%>
			<P class="TStep1" ALIGN=CENTER>instanceof</TD>
			<TD WIDTH=75%>
			<P class="TStep1" ALIGN=CENTER>왼쪽이 오른쪽 클래스의 인스턴스일 경우 true</TD>
		</tr>
		</TABLE>
		<P>비교 연산자의 결과 값은 크기 값을 비교하여 조건을 만족하면 true를, 맞지 않으면 false를 반환한다. 만약 비교되는 숫자의 자료형이 다를 경우 기본적으로 크기가 큰 자료형에 맞추어 비교 연산을 수행한다.
		<P>동등(equality) 연산자 '=='와 비동등(inequality) 연산자 '=='는 객체 참조 즉, 주소 값이 같은 지의 여부를 판단하여 true와 false를 반환한다. 객체 참조가 아닌 실제 값을 비교 판단하기 위해서는 equals 메소드를 이용해야 한다.
		<P>instanceof 연산자의 경우 런타임 시에 연산자의 왼쪽 항의 객체가 오른쪽 항 클래스의 인스턴스이면 true를 반환하고, 그렇지 않으면 false를 반환한다. 이 연산자를 이해하려면 클래스 개념이 있어야 하므로 여기서는 종류만을 이해하고 3장에서 자세히 설명하기로 한다.
		<P>2.2.2.3 비트 연산자(Bit operator) : &amp;, |, ^
		<P>비트 연산자는 두 수를 각각 2진수로 변환하여 두 수의 각 비트를 AND, OR, XOR 연산을 수행한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=361>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>&amp;</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>AND</TD>
		</tr>
		<TR>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>|</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>OR</TD>
		</tr>
		<TR>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>^</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>XOR</TD>
		</tr>
		</TABLE>
		<P>비트 연산자는 특정 비트를 0또는 1로 바꾸기 위한 마스크비트로 많이 사용된다. 
		<P>다음은 비트 연산자 예를 보인 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>BitOperator.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class BitOperator {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">byte a = 5; //00000101
			<P class="CStep3">byte b = 3; //00000011
			<P class="CStep3">System.out.println( a &amp; b ); //00000001
			<P class="CStep3">System.out.println( a | b ); //00000111
			<P class="CStep3">System.out.println( a ^ b ); //00000110
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">1
			<P class="Result">7
			<P class="Result">6</td>
		</tr>
		</table>
		<P>2.2.2.4 비트 이동연산자(Bit shift operator) : &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;
		<P>비트 이동 연산자는 피젯수를 2진수로 변환하여 젯수만큼 비트를 좌, 우로 이동시키는 연산을 수행한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=361>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>&lt;&lt;</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>왼쪽으로 비트 이동</TD>
		</tr>
		<TR>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>&gt;&gt;</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>오른쪽으로 비트 이동</TD>
		</tr>
		<TR>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>&gt;&gt;&gt;</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>오른쪽으로 비트 이동(비부호형)</TD>
		</tr>
		</TABLE>
		<P>'&lt;&lt;'는 2진수의 비트를 좌측으로 젯수의 수만큼 이동시키고, 오른쪽의 최하위 비트(LSB)에 0을 채운다. 이때 부호 비트는 변화가 없다. 이는 실제로
		<p style="line-height:50%;">&nbsp;&nbsp;&nbsp;피젯수<br>2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만큼 곱한 결과를 나타낸다.</p>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<P class="TStep1">int a = 192;
			<P class="TStep1">int b = a &lt;&lt; 3;</TD>
		</tr>
		</TABLE>
		<P>192를 2진수로 변환하면 00000000 00000000 00000000 11000000이 된다. 이 수를 왼쪽으로 3비트 이동시키면 00000000 00000000 00000110 00000000이 되어 192에<br>&nbsp;
		<p style="line-height:50%; margin-top:0; margin-bottom:0;">&nbsp;&nbsp;&nbsp;3</p>
		<p style="line-height:50%; margin-top:0; margin-bottom:0;">2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;를 곱한 1536이 된다.
		<P>'&gt;&gt;'는 2진수 비트를 오른쪽으로 젯수의 수만큼 이동시키고, 부호 비트에는 변화를 주지 않으며, 왼쪽의 최상위 비트(MSB)에 부호 비트의 수가 채워진다. 이는 실제로
		<p style="line-height:50%;">&nbsp;&nbsp;&nbsp;피젯수<br>2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만큼 나눈 결과를 나타낸다.</p>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<P class="TStep1">int a = 192;
			<P class="TStep1">int b = a &gt;&gt; 3;</TD>
		</tr>
		</TABLE>
		<P>192를 2진수로 변환하면 00000000 00000000 00000000 11000000이 된다. 이 수를 오른쪽으로 3비트 이동시키면 00000000 00000000 00000000 00011000이 되어 192를
		<p style="line-height:50%; margin-top:0; margin-bottom:0;"><br>&nbsp;&nbsp;&nbsp;3</p>
		<p style="line-height:50%; margin-top:0; margin-bottom:0;">2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;으로 
		나눈 24가 된다</p>
		<P>'&gt;&gt;&gt;'는 부호 없는 이동 연산자로고도 불리며, '&gt;&gt;'연산과 같지만, 최상위(MSB)비트에 부호 비트의 수가 채워지는 것이 아니고 무조건 0이 채워진다. 양수인 경우 나눗셈의 결과를 가져오지만 뺄셈의 경우는 전혀 다른 양수가 된다.
		<P>비트 이동 연산자는 오른쪽 항 즉 젯수에서 단축이 일어난다. 단축이란 비트 이동 연산자의 젯수 값이 자료형의 크기 이상일 때 젯수의 숫자를 자료형의 크기로 나눈 나머지를 젯수로 한다는 뜻이다. 예를 들면 int형의 경우 젯수의 수가 33이면 33비트만큼 이동하는 게 아니고 33을 32로 나눈 나머지인 1만큼 이동한다.
		<P>다음은 쉬프트 연산자 예를 보이고 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=8%></td>
			<TD WIDTH=91%>
			<P>ShiftOperator.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=8%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">16:
			<P class="CNumber">17:
			<P class="CNumber">&nbsp;
			<P class="CNumber">18:
			<P class="CNumber">19:
			<P class="CNumber">20:</TD>
			<TD WIDTH=91%>
			<P class="CStep1">public class ShiftOperator {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int a = 192;
			<P class="CStep3">System.out.println(&quot;a(192)\t&quot; + toBinaryString(a));
			<P class="CStep3">int b = a &lt;&lt; 3;
			<P class="CStep3">System.out.println(&quot;a&lt;&lt;3\t&quot; + toBinaryString(b));
			<P class="CStep3">int c = a &gt;&gt; 3;
			<P class="CStep3">System.out.println(&quot;a&lt;&lt;3\t&quot; + toBinaryString(c));
			<P class="CStep3">a = -192;
			<P class="CStep3">c = a &gt;&gt;&gt; 3;
			<P class="CStep3">System.out.println(&quot;a(-192)\t&quot; + toBinaryString(a));
			<P class="CStep3">System.out.println(&quot;a&gt;&gt;&gt;3\t&quot; + toBinaryString(c));
			<P class="CStep3">c = a &gt;&gt;&gt; 35;
			<P class="CStep3">System.out.println(&quot;a&gt;&gt;&gt;35\t&quot; + toBinaryString(c));
			<P class="CStep2">}
			<P class="CStep2">private static String toBinaryString(int num) {
			<P class="CStep3">String s = Long.toBinaryString( num | 
			<P class="CStep3">0xFFFFFFFF00000000L );
			<P class="CStep3">return s.substring(32);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400">
			<P class="Result">a(192)  00000000000000000000000011000000
			<P class="Result">a&lt;&lt;3    00000000000000000000011000000000
			<P class="Result">a&lt;&lt;3    00000000000000000000000000011000
			<P class="Result">a(-192) 11111111111111111111111101000000
			<P class="Result">a&gt;&gt;&gt;3   00011111111111111111111111101000
			<P class="Result">a&gt;&gt;&gt;35  00011111111111111111111111101000</td>
		</tr>
		</table>
		<P>이 예에서 10진수를 2진수로 출력하기 위해 Integer클래스의 toBinaryString() 메소드를 직접 사용할 수 있으나 그럴 경우에는 2진수의 앞부분 0이 출력되지 않으므로 임의로 toBinaryString() 메소드를 만든 것이다.
		<P>2.2.2.5 논리 연산자(Logical operator) : &amp;, ^, |, &amp;&amp;, ||
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=361>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>&amp;</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>AND</TD>
		</tr>
		<TR>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>|</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>OR</TD>
		</tr>
		<TR>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>^</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>XOR</TD>
		</tr>
		<TR>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>&amp;&amp;</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>AND(short circuit)</TD>
		</tr>
		<TR>
			<TD WIDTH=23%>
			<P class="TStep1" ALIGN=CENTER>||</TD>
			<TD WIDTH=76%>
			<P class="TStep1" ALIGN=CENTER>OR(short circuit)</TD>
		</tr>
		</TABLE>
		<P>&amp;, |, ^는 비트 연산자로 사용되지만 true와 false를 통해 논리 연산을 수행하는 논리 연산자로도 사용되며 &amp;, |, ^ 연산자의 경우는 양쪽 항 모두 수행하지만 &amp;&amp;, || 연산자는 short circuit operator라고 하여 오른쪽 항을 수행하지 않을 수 도 있다.
		<P>'&amp;&amp;' 연산자는 AND연산을 수행하여 양쪽 항이 모두 true일 때만 true를 반환한다. 만일 왼쪽이 false일 때는 오른쪽을 수행하지 않고 무조건 false를 반환한다.
		<P>'||' 연산자는 OR연산을 수행하여 양쪽 중 한쪽만 만족해도 true를 반환한다. 만일 왼쪽이 true이면 오른쪽을 수행하지 않고 무조건 true를 반환해도 결과는 같다.
		<P>다음은 논리 연산자 중에서 &amp;, | 연산자와 &amp;&amp;, ||연산자의 차이점을 예를 든 것인데, y 값은 증가해도 b 값은 증가하지 않는다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>LogicalOperator.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class LogicalOperator {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">int x=10, y=20;
			<P class="CStep3">if ((x != 10) <B>&amp;</B> (++y == 21))
			<P class="CStep4">System.out.println(x + &quot; &quot; + y);
			<P class="CStep3">if ((x == 10) <B>|</B> (++y == 21))
			<P class="CStep4">System.out.println(x + &quot; &quot; + y);
			<P class="CStep3">int a=10, b=20;
			<P class="CStep3">if ((a != 10) <B>&amp;&amp;</B> (++b == 21))
			<P class="CStep4">System.out.println(a + &quot; &quot; + b);
			<P class="CStep3">if ((a == 10) <B>||</B> (++a == 21))
			<P class="CStep4">System.out.println(a + &quot; &quot; + b);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">10 22
			<P class="Result">10 20</td>
		</tr>
		</table>
		</ul>
		<P class="TSubmenu">2.2.3 3항 연산자(Ternary operator)
		<ul>
		<P>피 연산자가 세 개인 연산자를 말하며, 조건 연산자인 ?: 가 있다.
		<P>2.2.3.1 조건 연산자(Conditional operator) : ? :
		<P>조건 연산자 사용법은 다음과 같다.
		<P>	a = x ? b : c;
		<P>x는 boolean형 조건 연산식으로 연산을 수행하여 x의 결과가 true이면 변수 a에 b 값이 대입되고, x의 결과가 false이면 a에 c 값이 대입된다.
		<P>다음은 조건 연산자를 이용하여 절대값을 구하는 식으로 실행시에 인자를 필요로 한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ConditionalOperator.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class ConditionalOperator {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int a = Integer.parseInt(args[0]);
			<P class="CStep3">int abs = (a &gt;= 0) <B>?</B> a <B>:</B> -a;
			<P class="CStep3">System.out.println(a + &quot;의 절대값은 : &quot; + abs);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400">
			<P class="RResult">실행 결과
			<p class="RResult">(실행 : java Conditional Operator -64)</td>
		</tr>
		</table>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P>-64의 절대값은 : 64</td>
		</tr>
		</table>
		</ul>
		<P class="TSubmenu">2.2.4 대입 연산자(Assignment operator)
		<ul>
		<P>대입 연산자의 기본 기호는 '='이고, 보다 발전된 대입 연산자는 x operand = a의 형태를 가지고 있으며 이는 x = x operand a 와 같은 역할을 한다.
		<P>대입 연산자에는 =, +=, -+, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=, &amp;=, ^=, |= 등이 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>AssignmentOperator.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">class AssignmentOperator {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int a=5;
			<P class="CStep3">int b=5;
			<P class="CStep3">a += 3; //a = a + 3;
			<P class="CStep3">b =+ 3; //b = +3;
			<P class="CStep3">System.out.println(a + &quot;\t&quot; + b);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">8 5</td>
		</tr>
		</table>
		<P>주의할 점은 복합대입연산자의 경우에는 '=' 기호가 연산자 뒤에 나온다는 것이다. 위의 예에서 6번째 줄에서처럼 '='을 앞에 두면 컴파일 오류가 발생하지 않더라도 원치 않는 결과 값을 갖게 될 수 있다.
		</ul></td>
    </tr>
	</table>
</body>
</html>