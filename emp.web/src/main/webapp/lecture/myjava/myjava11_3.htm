<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">11.3</P></td>
        <td width="518">
        <p class="TitleTitle">스윙의 레이아웃 관리자</p></td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>
		<P>&nbsp;스윙에는 ScrollPaneLayout, ViewportLayout, BoxLayout, OverlayLayout의 4가지 주요한 레이아웃 관리자가 있는데, 이들의 특징은 다음과 같다. 
		</ul>
		<P class="TSubmenu">11.3.1 BoxLayout
		<ul>
		<P>X축이나 Y축에 따라 컴포넌트를 배치할 수 있다. 예를 들면, Y축 BoxLayout을 사용하면 컴포넌트는 위에서부터 아래로 정렬되고, X축 BoxLayout을 사용하면 왼쪽에서 오른쪽으로 컴포넌트가 정렬된다.
		<P>GridLayout과는 달리 컴포넌트가 주어진 축을 기준으로 각기 다른 영역을 차지하게 되는데, Y축을 기준으로 한 BoxLayout에 사용된 JTextField는 작은 영역을 차지하게 된다.
		<P>좌우로 배치되는 경우는 너비가 가장 큰 컴포넌트에 맞춰지고, 상하로 배치되는 경우는 폭이 가장 큰 것에 맞추어져 표시된다.
		<P>두 개의 파라미터를 사용하는데, 첫 번째 파라미터는 컨테이너를 지시하고 두 번째 파라미터는 기준이 되는 축을 표시한다. 
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV389.GIF" BORDER=0 WIDTH=232 HEIGHT=237 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 프로그램은 BoxLayout 예를 나타낸 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>BoxLayoutExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">&nbsp;
			<P class="CNumber">16:
			<P class="CNumber">17:
			<P class="CNumber">18:
			<P class="CNumber">&nbsp;
			<P class="CNumber">19:
			<P class="CNumber">20:
			<P class="CNumber">21:
			<P class="CNumber">22:
			<P class="CNumber">23:
			<P class="CNumber">24:
			<P class="CNumber">25:
			<P class="CNumber">26:
			<P class="CNumber">27:
			<P class="CNumber">28:
			<P class="CNumber">29:
			<P class="CNumber">30:
			<P class="CNumber">31:
			<P class="CNumber">32:
			<P class="CNumber">33:
			<P class="CNumber">34:
			<P class="CNumber">35:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">import javax.swing.*;
			<P class="CStep1">public class BoxLayoutExample {
			<P class="CStep2">private JFrame f;
			<P class="CStep2">private JPanel panel;
			<P class="CStep2">private JTextField textField;
			<P class="CStep2">private JTextArea textArea;
			<P class="CStep2">private JButton button;
			<P class="CStep2">private Container con;
			<P class="CStep2">public BoxLayoutExample() {
			<P class="CStep3">f = new JFrame(&quot;BoxLayout Example&quot;);
			<P class="CStep3">panel = new JPanel();
			<P class="CStep3">textField = new JTextField();
			<P class="CStep3">textArea = new JTextArea(5, 20);
			<P class="CStep3">button = new JButton(&quot;Duke&quot;, new ImageIcon
			<P class="CStep3">(&quot;dukeicon.gif&quot;));
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">panel.<B>setLayout(new BoxLayout(panel,
			<P class="CStep3">BoxLayout.Y_AXIS)</B>);
			<P class="CStep3">panel.add(new JLabel(&quot;JTextField : &quot;));
			<P class="CStep3">panel.add(textField);
			<P class="CStep3">panel.add(new JLabel(&quot;JTextArea : &quot;));
			<P class="CStep3">panel.add(textArea);
			<P class="CStep3">panel.add(new JLabel(&quot;JButton : &quot;));
			<P class="CStep3">panel.add(button);
			<P class="CStep3">con = f.getContentPane();<P class="CStep1">		con.add(panel);
			<P class="CStep3">f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE );
			<P class="CStep3">f.pack();
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">BoxLayoutExample win = new BoxLayoutExample();
			<P class="CStep3">win.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>Box클래스
		<P>Box는 기본 레이아웃 매니저가 BoxLayout인 클래스로 BoxLayout 컨테이너와 더불어 컴포넌트 배열에 유용한 static 메소드를 가지고 있다.
		<P>다음은 Box클래스의 주요 메소드를 나타낸 것이다.
		<P>&middot; createVerticalStrut(int) : 간격을 위해 고정 높이 컴포넌트를 반환한다.
		<P>&middot; createHorizontalStrut(int) : 간격을 위해 고정 폭 컴포넌트를 반환한다.
		<P>&middot; createVerticalGlue() : 컴포넌트 사이의 초과된 공간을 흡수하기 위해 확장된 높이 컴포넌트를 반환한다.
		<P>&middot; createHorizontalGlue() : 컴포넌트 사이의 초과된 공간을 흡수하기 위해 확장된 폭 컴포넌트를 반환한다.
		<P>&middot; createGlue() : 높이는 Y축으로 확장되고 폭은 X축으로 확장된 컴포넌트를 반환한다.
		<P>&middot; createRigidArea(Dimension) : 고정 높이 고정 폭을 반환한다.
		</ul>
		<P class="TSubmenu">11.3.2 ScrollPaneLayout
		<ul>
		<P>ScrollPaneLayout은 JScrollPane에서 사용하는 레이아웃 관리자이다. 직접 만들지 않고 자동으로 생성된다. 이 레이아웃 방법은 JScrollPane에 9개의 다른 영역을 지정한다.
		<P>&middot; 하나의 JViewport : 내용의 중심에 지정한다.
		<P>&middot; 두 개의 JScrollBar 객체 : 수평과 수직 스크롤바에 지정한다.
		<P>&middot; 두 개의 JViewport 객체 : 행과 열에 지정한다.
		<P>&middot; 네 개의 Component 객체 : 각 모서리에 지정한다.
		<P>JScrollPane은 모서리를 LOWER_LEFT_CORNER, LOWER_RIGHT_CORNER, UPPER_LEFT_ CORNER, UPPER_RIGHT_CORNER로 지정한다.
		<P>JViewport는 자체 컴포넌트를 가질 수 있는 컨테이너로 매우 유연한 정렬기능을 갖고, 자신만의 레이아웃 관리자인 ViewportLayout을 사용한다.
		</ul>
		<P class="TSubmenu">11.3.3 ViewportLayout
		<ul>
		<P>ViewportLayout은  JViewport가 사용하는 레이아웃 매니저로 사용자가 직접 레이아웃을 사용하지 않고 JViewPort 객체와 자동으로 연결되어 JViewPort 속성에 따라 내부 컴포넌트의 위치가 결정된다.
		</ul></td>
    </tr>
</table>
</body>
</html>