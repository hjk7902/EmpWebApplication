<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">7.2</P></td>
        <td width="518">
        <p class="TitleTitle">예외 처리</td>
   </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>
		<P> 예외처리(Exception Handling)는 오류발생에 대한 대처 방법 중의 하나로 시스템 스스로 오류를 복구하는게 아니고 오류발생 가능성이 있는 부분에 대한 처리를 미리 프로그램 해주는 것이다. 오류의 종류는 강한오류(serious error)와 약한오류(mild error)로 나눌 수 있다.<P>강한오류는 메모리가 부족할 때 발생하는 OutOfMemouyError 등으로 오류를 복구할 수 없으며 프로그램은 중지된다. 자바에서는 이런 경우만 오류라고 한다.
		<P>약한오류는 일종의 오류로 취급되지만 프로그램이 중지되지는 않는 오류를 말한다. 예를 들면 없는 파일을 읽을 때 발생하는 FileNotFoundException 오류 등이다. 파일이 없어도 프로그램은 멈추지 않고 파일이 없음을 알리는 오류 메시지를 출력하고 계속 진행되는 것이다. 
		<P>이와 같은 오류 방생에 대한 조치 사항을 예외처리라고 한다.
		<P>다음 프로그램은 오류를 발생하도록 만든 예이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ExceptionProblem.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class ExceptionProblem {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">int i = 0;
			<P class="CStep3">String[] greetings = {&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;};
			<P class="CStep3">while (i &lt; 4) {
			<P class="CStep4">System.out.println (greetings[i]);
			<P class="CStep4">i++;
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>이 프로그램은 오류가 발생하는데 컴파일 오류가 아니고 실행오류이다. 5번째 줄에서 i값이 3이 될 때까지 while문을 수행하면 6번째 줄에서 greetings[3]까지 출력한다. 그러나 4번째 줄을 자세히 보면, 배열 greetings는 greetings[2]까지(greeting[0]=&quot;One&quot;, greeting[1]=&quot;Two&quot;, greeting[2]=&quot;Three&quot;)만  지정했기 때문에 배열의 범위를 넘었다. 이와같은 경우 C언어에서는 오류가 발생하지 않지만, 자바에서는 발생한다.
		<P>프로그램의 실행결과는 다음과 같다.<br>&nbsp;
		<table width="450" cellpadding="0" cellspacing="0">
		<tr>
			<td width="450"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="450" cellpadding="0" cellspacing="0">
		<tr>
			<td width="450">
			<P class="Result">One
			<P class="Result">Two
			<P class="Result">Three
			<P class="Result">Exception in thread &quot;main&quot;
			<P class="Result">java.lang.ArrayIndexOutOfBoundsException
			<P class="Result">at ExceptionProblem.main(ExceptionProblem.java:6)</td>
		</tr>
		</table>
		<P>실행 결과를 보면, greetings[2](Three)까지 출력하고 greetings[3]을 실행하다 ArrayIndexOutOf BoundsException이 발생했음을 알 수 있다. 예외처리는 자바 프로그램을 개발하는 도중에 종종 만나게된다.<P>앞의 프로그램을 수정하여 오류가 발생하지 않게하려면 5번째 줄을 다음과 같이 기술한다. 
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<p class="CStep1">while (i &lt; 3) {</TD>
		</tr>
		</TABLE>
		<P>예외처리가 발생하는 이유는 대부분 프로그램을 잘못 작성했기 때문인데 이를 자세하게 설명하면 다음과 같다. 
		<P>예외처리는 예외사항을 찾아내 이를 처리한 다음 계속 프로그램이 진행되도록 하는 것이다. 예외 상황을 처리하기 위해 받아들이는 것을 예외를 잡는다(catch)라고 표현하고, 예외 처리를 자신을 부른 메소드로 넘기는 것을 예외를 던진다(throw)고 표현한다. 
		<P>예외처리 방법은 크게 두 가지로 나눌 수 있는데, 첫 번째는 try ∼ catch 문을 사용하는 방법과, 두 번째는 throws 선언을 통하여 처리하는 방식이다. 예외 처리에서 기억해야할 점은 예외처리를 사용하면 오류가 발생했을 때 프로그램의 오류처리 루틴을 자동적으로 호출해 주지만 이러한 루틴은 프로그래머가 직접 작성해야 한다는 것이다.
		</ul>
		<P class="TSubmenu">7.2.1 try ∼ catch
		<ul>
		<P>try∼catch 문을 이용하여 예외를 처리해 보자. 
		<P>다음 프로그램은 try∼catch문을 이용하여 앞에서 설명한 예외처리 예를 보인 것이다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ExceptionTryCatch.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber"><B>6:</B>
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber"><B>9:</B>
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber"><B>14:</B>
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class ExceptionTryCatch {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">int i = 0;
			<P class="CStep3">String[] greetings = {&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;};
			<P class="CStep3">while (i &lt; 4) {
			<P class="CStep4"><B>try </B>{
			<P class="CStep5">System.out.println(greetings[i]);
			<P class="CStep4">}
			<P class="CStep4"><B>catch</B> <B>(ArrayIndexOutOfBoundsException e)</B> {
			<P class="CStep5">System.out.println(&quot;예외 발생!&quot;);
			<P class="CStep5">i = -1;
			<P class="CStep5">System.out.println(&quot;예외 처리 완료됨!&quot;);
			<P class="CStep4">}
			<P class="CStep4"><B>finally</B> {
			<P class="CStep5">System.out.println(&quot;항상 실행됨&quot;);
			<P class="CStep4">}
			<P class="CStep4">i++;
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>try∼catch문은 크게 3부분(try, catch, finally)으로 나눌 수 있다.
		<P>첫 번째 부분은 try 블록으로 예외상황이 발생할 만한 문장을 적으면 된다. 7번째 줄에서 greeting[3]을 출력하다 예외상황이 발생할 것이다. try 블록은 단독으로 사용할 수 없고, catch나 finally블록과 함께 사용한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber"><B>6:</B>
			<P class="CNumber">7:
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1"><B>try </B>{
			<P class="CStep1">System.out.println(greetings[i]);
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>두 번째 부분은 catch 블록으로 발생한 예외상황을 감지하여 적절한 조치를 취하기 위해 사용한다. 실행 시점은 예외가 발생했을 때인데 예외가 발생하지 않으면 catch 블록은 실행되지 않는다. 만약 기술한 예외와 다른 상황이 발생하면 무시된다. 이 프로그램에서는 ArrayIndexOutOfBoundsException이 발생하면 catch 블록이 실행된다. 만약 NullPointerException과 같이 다른 예외상황이 발생하면 catch 블록은 실행되지 않는다. 예외 상황이 많을 경우에는 catch블록을 중복해서 사용할 수도 있다. 일반적인 예외가 먼저 처리될 수 없는데 예를 들면 Exception 계층 구조에서 상위 클래스가 하위 클래스보다 먼저 catch블록의 인자값으로 선언되어서는 안된다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber"><B>9:</B>
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:</TD>
			<TD WIDTH=92%>
			<P class="CStep1"><B>catch</B> <B>(ArrayIndexOutOfBoundsException e)</B> {
			<P class="CStep2">System.out.println(&quot;예외 발생!&quot;);
			<P class="CStep2">i = -1;
			<P class="CStep2">System.out.println(&quot;예외 처리 완료됨!&quot;);
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>세 번째는 finally 블록이 있는데, 이 블록은 catch 블록과는 다르게 예외상황의 발생여부에 관계없이 무조건 실행된다. 
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber"><B>14:</B>
			<P class="CNumber">15:
			<P class="CNumber">16:</TD>
			<TD WIDTH=92%>
			<P class="CStep1"><B>finally</B> {
			<P class="CStep2">System.out.println(&quot;항상 실행됨&quot;);
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>finally는 try 블록 또는 catch 블록에서 return문을 만나더라도 무조건 실행된다. 다음의 경우에만 finally 블록이 실행되지 않는다.
		<P>  &middot; System.exit()를 호출했을 때.
		<P>  &middot; 전원이 꺼져 시스템이 멈추었을 때.
		<P>  &middot; finally 블록 내부에서 예외상황이 발생했을 때.
		<P>  &middot; 쓰레드가 죽었을 때.
		<P>앞의 예제는 ArrayIndexOutOfBoundsException라는 예외 상황이 방생한다. 모든 예외상황의 부모 클래스는 Exception이며 ArrayIndexOutOfBoundsException도 역시 Exception 클래스의 자손 클래스이다. 이렇게 try블록 안에서 예외상황이 발생하면 catch 블록이 수행되며, 발생한 예외는 ArrayIndexOut OfBoundsException 타입의 인스턴스(instance)라는 사실이다. 따라서 e 라는 변수를 이용해 생성된 인스턴스를 가리킨 것이다. 그 다음 화면에 &quot;예외 처리 완료됨&quot;을 출력한 후, i를 -1로 바꾼다. 물론 try 문이 실행되면 finally 블록은 무조건 수행됨으로 이미 화면에 &quot;항상 실행됨&quot;이 계속 출력된다. 이렇게 i가 -1로 바뀌면 while 조건이 true임으로 무한 loop를 수행하게 되므로 프로그램은 멈추지 않고 진행된다. 이렇게 오류가 발생해도 프로그램이 계속 실행되는 이유는 프로그래머가 예외상황을 직접 다룰 수 있기 때문이다.
		<P>다음 그림은 예외상황의 종류를 도식한 것이다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV281.GIF" BORDER=0 WIDTH="563" HEIGHT="267" HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
		<P>앞의 그림은 개략적인 형태로 전부 클래스 이름이다. 여기에 나타나 있지 않은 클래드도 많이 있으므로 API문서를 참조하면 된다. 이 중 Error클래스의 자손이 발생하면 치명적인 오류이므로 프로그램이 종료되는 것이 당연하다. 그 밑에 Exception이 있는데 바로 이것들이 예외 처리의 대상이다. 보통 예외가 발생하면 오류 메시지를 내보내고 종료하지만 예외 상황이 발생하는 대부분의 이유가 프로그램을 잘못 작성하였기 때문이므로 이러한 예외상황이 발생하지 않게 작성해야하고, 부득이하게 발생하는 경우라면 예외 처리 부분을 기술해 주어야 한다.
		<P>RuntimeException은 설계상의 문제 또는 구현 코드 문제를 가리킨다. 즉, 프로그램이 정상적으로 실행되고 있으면 발생해서는 안 되는 실행 중 상태를 알려준다. 예를 들어, 한계 값을 벗어난 배열이나 null 변수의 레퍼런스 해제를 들 수 있다. 올바르게 설계되어 구현된 프로그램에서는 절대로 이런 종류의 예외가 발생하지 않으므로 처리하지 않고 그대로 두는 것이 보통이다. 이 예외가 발생하면 실행 중에 메시지가 나오므로 오류를 수정할 수 있다. 
		<P>이 외의 Exception은 실행환경에 따라 발생할 수 있고 또 처리할 수 있다. 예를 들면 파일을 찾을 수 없거나 URL을 잘못 지정한 경우가 있다. 이런 것은 사용자가 잘못 입력할 때 발생하며 프로그래머가 처리해야 한다. 
		<P>위의 예외 중에서 IOException과 하위 클래스들인 EOFException 그리고, FileNotFoundException은 오류메시지 없이 프로그램이 중단되므로 반드시 예외 처리를 해 주어야 한다. API에서 제공되는 메소드를 사용할 때는 그 메소드가 throws 되어 있는지 확인하고 throws할 경우에는 반드시 예외 처리를 해 주어야 한다.
		<P>다음은 자바 언어에서 미리 정의된 몇 가지 예외 중에서 발생빈도가 높은 항목을 설명한 것이다. 
		<P>  &middot; ArithmeticException
		<P>- 일반적으로 정수를 0(zero)로 나눗셈을 할 때 발생한다.
		<P>  &middot; NullPointerException
		<P>- 인스턴스를 만들기 전에 객체나 메소드를 액세스하면 발생한다.
		<P>- Image[] in = new Image[4];
		<P>  System.out.println(im[0].toString());
		<P>  &middot; NegativeArraySizeException
		<P>- 음수로 배열크기를 지정할 때 발생한다.
		<P>  &middot; ArrayIndexOutOfBoundException
		<P>- 배열의 크기를 벗어난 배열의 구성요소를 액세스할 때 발생한다.
		</ul>
		<P class="TSubmenu">7.2.2 throws
		<ul>
		<P>예외 상황을 다루는 방법으로 try∼catch문 외에 throws이 있다. 예외상황이 여러 개 있을 때는 &quot;,&quot;(comma)로 구분하여 나열한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=2%></td>
			<TD WIDTH=97%>
			<p class="TStep1">modifier return-type <I>methodName</I>() <B>throws</B> <I>Exception1, Exception2</I> ...{
			<p class="TStep1">	<I>method-body;</I>
			<p class="TStep1">}</TD>
		</tr>
		</TABLE>
		<P>먼저 다음의 예제를 보자.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<p class="TStep1">public void exceptionOccur()
			<p class="TStep2">throws ArrayIndexOutOfBoundsException {
			<p class="TStep1">... // 이 안에서 Exception이 발생했다고 가정.
			<p class="TStep1">}</TD>
		</tr>
		</TABLE>
		<P>exceptionOccur() 메소드 안에서 ArrayIndexOutOfBoundsException이 발생하면, try∼catch문을 처리할 수 있지만 try∼catch문을 사용하지 않고 메소드의 선언부에 throws를 사용해도 처리 가능하다. 이 경우는 exceptionOccur()를 호출한 메소드에게 발생한 예외를 던지는 것이다.
		<P>다음 프로그램은 예외상황을 처리하는 방법을 보인 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ExceptionThrows.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber"><B>5:</B>
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber"><B>14:</B>
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class ExceptionThrows {
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">ExceptionThrows et = new ExceptionThrows();
			<P class="CStep3">try {
			<P class="CStep4"><B>et.go();</B>
			<P class="CStep3">}
			<P class="CStep3">catch (ArrayIndexOutOfBoundsException e) {
			<P class="CStep4">System.out.println(&quot;예외가 발생됨&quot;);
			<P class="CStep3">}
			<P class="CStep3">finally {
			<P class="CStep4">System.out.println(&quot;항상 실행됨&quot;);
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep2"><B>void go() throws  ArrayIndexOutOfBoundsException {</B>
			<P class="CStep3">int i = 0;
			<P class="CStep3">String[] greetings = {&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;};
			<P class="CStep3">while (i &lt; 4) {
			<P class="CStep4">System.out.println (greetings[i]);
			<P class="CStep4">i++;
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>프로그램을 보면 main() 메소드에서 go() 메소드를 호출했는데 go() 메소드의 18번째 줄에서 예외가 발생한다. 그런데, go() 메소드의 선언부인 14번째 줄에서 throws를 사용하고 있으므로 ArrayIndexOutOf BoundsException이 발생할 경우, 자신을 호출한 메소드에게 이 예외를 던져버려라(throws)라는 의미이다. 따라서 이 경우, go()를 호출한 main() 메소드의 5번째 줄로 예외가 던져지게 된다. main() 메소드의 입장에서는 결국, 5번째 줄에서 예외가 발생한 것이고, 이를 try∼catch를 이용해서 해결할 수 있다. 
		<P>throws로 선언된 메소드를 재정의 할 때 throws되는 예외가 다르면 예외 수가 더 적어지거나 하위클래스의 예외가 올 경우만 가능하다.
		</ul>
		<P class="TSubmenu">7.2.3 사용자 정의 예외
		<ul>
		<P>앞에서 살펴본 바와 같이 예외는 시스템에서 자동으로 발생시켜주기 때문에 발생된 예외를 try∼catch 혹은 throws를 이용해 처리하면 된다. 반대로 우리가 직접 예외를 만들 수 있고, 이를 원하는 시점에 발생시킬 수도 있다. 이를 보고 사용자 정의 예외(user defined exception)라고 한다.
		<P>먼저 예외를 만드는 것부터 살펴보자. 예외는 클래스이므로 예외를 만든다는 것은 클래스를 만드는 것과 동일하다. 하지만 유의할 점은 반드시 예외 클래스를 상속받아서 만들어야 한다는 점이다.
		<P>다음 프로그램은 예외 클래스를 직접 만들어 사용하는 예를 보인 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ServerTimedOutException.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber"><B>1:</B>
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class ServerTimedOutException <B>extends Exception</B> {
			<P class="CStep1">private int port;
			<P class="CStep1">public ServerTimedOutException(String reason, int port) {
			<P class="CStep2">super(reason);
			<P class="CStep2">this.port = port;
			<P class="CStep1">}
			<P class="CStep1">public int getPort() {
			<P class="CStep2">return port;
			<P class="CStep1">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>1 : Exception 클래스를 상속받은 후 ServerTimedOutException 클래스를 정의하고, 나머지는 일반적인 클래스선언과 동일하다. 
		<P>2 : 멤버 변수를 나타낸다. 
		<P>3 : 생성자를 나타낸다.
		<P>7 : 멤버 메소드를 나타낸다.
		<P>이처럼 사용자가 직접 선언한 예외 클래스를 가지고 예외를 발생시키려면 다음과 같이 Exception 클래스의 인스턴스를 만든 후, &quot;throw&quot;(throws가 아니라 throw이다.) 키워드를 이용해 던지면 된다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=2%></td>
			<TD WIDTH=97%>
			<p class="TStep1"><B>throw </B>new ServerTimedOutException(&quot;Could not connect&quot;, 80);</TD>
		</tr>
		</TABLE>
		<P>사용자가 자신의 예외를 정의하고 발생시키는 것은 간단하다. 이제 이를 이용한 예제를 보도록 하자.
		<P>다음 프로그램은 사용자가 예외를 정의하고 발생시키는 예를 보인 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestUserException.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">&nbsp;
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber"><B>9:</B>
			<p class="CNumber">10:
			<p class="CNumber">&nbsp;
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">&nbsp;
			<p class="CNumber">23:
			<p class="CNumber">24:
			<p class="CNumber">25:
			<p class="CNumber">26:
			<p class="CNumber">27:
			<p class="CNumber">28:
			<p class="CNumber">29:
			<p class="CNumber">30:
			<p class="CNumber">31:
			<p class="CNumber">32:
			<p class="CNumber">33:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestUserException {
			<P class="CStep2">String defaultServer = &quot;my_server&quot;;
			<P class="CStep2">String alternativeServer = &quot;your_server&quot;;
			<P class="CStep2">public void connectMe(String serverName) throws
			<P class="CStep3">ServerTimedOutException {</p>
			<P class="CStep3">int success;
			<P class="CStep3">int portToConnect = 80;
			<P class="CStep3">success = open(serverName, portToConnect);
			<P class="CStep3">if (success == -1) {
			<P class="CStep4"><B>throw</B> new ServerTimedOutException
			<P class="CStep4">(&quot;Could not connect&quot;, 80);
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep2">public void findServer() {
			<P class="CStep3">try {
			<P class="CStep4">connectMe(defaultServer);
			<P class="CStep3">}
			<P class="CStep3">catch (ServerTimedOutException e) {
			<P class="CStep4">System.out.println( &quot;Server timed out, trying alternative...&quot;);
			<P class="CStep3">try {
			<P class="CStep4">connectMe(alternativeServer);
			<P class="CStep3">}
			<P class="CStep4">catch (ServerTimedOutException e1) {
			<P class="CStep5">System.out.println( &quot;Error : &quot; + e1.getMessage() + 
			<P class="CStep6">&quot;connecting to port &quot; + e1.getPort());
			<P class="CStep4">}
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep2">public int open (String serverName, int port) {
			<P class="CStep3">return -1;
			<P class="CStep2">}
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">TestUserException tue = new TestUserException();
			<P class="CStep3">tue.findServer();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>앞 예제의 시작점은 29번째 줄의 main()이다. 이 예제는 서버에 접속을 시도하다 접속에 문제가 발생하면 이미 정의한 ServerTimedOutException을 발생시킨다. 
		<P>유의할 부분은 4번째 줄인데 connectMe() 메소드는 7번째 줄의 open() 메소드를 통해 접속을 시도한다. 접속에 실패하여 -1을 반환하면 9번째 줄에서 예외를 만들고 이를 throw한다. 그러면 connectMe()를 호출한 메소드로 가서 16번째 줄의 catch문을 이용 예외상황을 처리하게 된다.
		</ul>
		<P class="TSubmenu">7.2.4 Assertion
		<ul>
		<P>프로그래머가 자신의 프로그램에 대한 가정을 확신시키는 문장으로 boolean 수식을 가지고 주어진 조건을 만족하지 않으면, 즉 수식의 결과가 false이면 예외를 발생시키는 키워드이다. 이는 프로그래머가 오류에 대해 좀더 자유롭게 프로그램을 작성하도록 해준다. assertion 문장은 assert 키워드를 이용하며 다음과 같은 두 가지 사용법이 있다. 이 기능은 JDK 1.4 버전에서 추가되었다.
		<P>다음과 같은 형태에서 <I>Expression<SUB>1</SUB></I>의 결과는 boolean형이며, <I>Expression<SUB>1</SUB></I>의 결과 값이 false이면 실행시 메시지가 없는 AssertionError를 발생시킨다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=539>
			<TD>
				<p class="TStep1">assert <I>Expression 1</I>;
			</TD>
</tr>
		</TABLE>
		<P>다음과 같은 형태 즉, 두 개의 Expression을 가질 때는 먼저 <I>Expression<SUB>1</SUB></I>의 결과는 boolean형이어야 하며, <I>Expression<SUB>1</SUB></I>의 결과 값이 false이면 실행시에 <I>Expression<SUB>2</SUB></I>의 결과를 메시지로 갖는 AssertionError를 발생시킨다. 여기서 주의해야 할 점은 <I>Expression<SUB>2</SUB></I>에는 void형 메소드 호출이 올 수 없다.	
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=539>
			<TD WIDTH=100%>
			<p class="TStep1">assert <I>Expression 1</I> : <I>Expression 2</I>;</TD>
		</tr>
		</TABLE>
		<P>7.2.4.1 assertion 코드 컴파일
		<P>assert문이 있는 프로그램은 버전이 1.4임을 알려주기 위해 컴파일시 다음과 같이 옵션을 넣어서 컴파일 한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=539>
			<TD WIDTH=100%>
			<p class="TStep1"> &gt; <B>javac</B> -source 1.4 <I>FileName.java</I></TD>
		</tr>
		</TABLE>
		<P>7.2.4.2 assertion 코드 실행
		<P>실행시킬 때 -enableassertions 또는 -ea 옵션을 사용한다. 해제하려면 -disableassertion 또는 -da 옵션을 사용한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=539>
			<TD WIDTH=100%>
			<p class="TStep1"> &gt; <B>java</B> -ea <I>FileName</I></TD>
		</tr>
		</TABLE>
		<P>7.2.4.3 assertion 코드 예
		<P>다음 프로그램은 assert키워드의 사용법을 익히기 위한 예제이다. 먼저 assert 키워드가 사용되지 않은 예이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>AssertionExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class AssertionExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int i = Integer.parseInt(args[0]);
			<P class="CStep3">System.out.println(&quot;넘어온 값 : &quot; + doIt(i));
			<P class="CStep2">}
			<P class="CStep2">public static int doIt(int a) {
			<P class="CStep3">switch(a) {
			<P class="CStep4">case 1:
			<P class="CStep5">System.out.println(&quot;1이 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep4">case 2:
			<P class="CStep5">System.out.println(&quot;2가 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep4">case 3:
			<P class="CStep5">System.out.println(&quot;3이 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep3">}
			<P class="CStep3">return a;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>이 프로그램에서 switch문이 사용되었는데 조건을 만족하는 case문이 없으면 실행되는 문장이 없다. 따라서 프로그램을 작성하면서 처리할 문장이 없음을 간과할 수 있는데, 이럴 경우 해당 메소드가 예외를 발생시키고 프로그램 실행을 멈추게 하려면 다음과 같은 프로그램을 작성한다. 
		<P>다음 프로그램은 앞의 예제에서 조건을 만족하지 않으면 실행되는 문장이 없는 예외상황을 처리하기 위한 기능을 부여한 예이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>AssertionExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550 HEIGHT=253>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber"><B>17:</B>
			<p class="CNumber"><B>18:</B>
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">23:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class AssertionExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int i = Integer.parseInt(args[0]);
			<P class="CStep3">System.out.println(&quot;넘어온 값 : &quot; + doIt(i));
			<P class="CStep2">}
			<P class="CStep2">public static int doIt(int a) {
			<P class="CStep3">switch(a) {
			<P class="CStep4">case 1:
			<P class="CStep5">System.out.println(&quot;1이 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep4">case 2:
			<P class="CStep5">System.out.println(&quot;2가 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep4">case 3:
			<P class="CStep5">System.out.println(&quot;3이 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep4">default:
			<P class="CStep5"><B>assert false : a;</B>
			<P class="CStep3">}
			<P class="CStep3">return a;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>이 프로그램에서는 assert문이 사용되었다. 실행할 때 입력 값이 case문의 값과 일치하는 값이 없을 경우에는 실행시의 옵션에 따라 예외를 발생시킬 수도 있고,  그렇지 않을 수도 있다. 이렇게 하면 사용자가 메소드 호출시 예외 상황에 대하여 좀더 자유롭게 프로그램을 작성할 수 있다.
		<P>다음은 앞의 예제를 컴파일하고 실행한 결과를 나타낸 것이다.
		<P><B>컴파일 (javac -source 1.4 AssertExample.java)</B>
		<table width="450" cellpadding="0" cellspacing="0">
		<tr>
			<td width="450" height="31">					
			<P class="RResult">실행 결과 1 (java -ea AssertExample 5)</td>
		</tr>
		</table>
		<table width="450" cellpadding="0" cellspacing="0">
		<tr>
			<td width="450">
			<P class="Result">Exception in thread &quot;main&quot; java.lang.AssertionError: 5
			<P class="Result">at AssertExample.doIt(AssertExample.java:18)
			<P class="Result">at AssertExample.main(AssertExample.java:4)</td>
		</tr>
		</table>
		<table width="450" cellpadding="0" cellspacing="0">
		<tr>
			<td width="450" height="31">
			<P class="RResult">실행 결과2 (java AssertExample 5)</td>
		</tr>
		</table>
		<table width="450" cellpadding="0" cellspacing="0">
		<tr>
			<td width="450">
			<P class="Result">넘어온 값 : 5</td>
		</tr>
		</table>
		<P>다음 프로그램은 앞의 assertion문장을 throw문으로 수정한 예이다. 이렇게 throw문을 이용하면 값이 없을 경우 예외가 발생하여 더 이상 수행되지 않는다.
		<p>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>AssertionExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550 HEIGHT=214>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class AssertionExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">int i = Integer.parseInt(args[0]);
			<P class="CStep3">System.out.println(&quot;넘어온 값 : &quot; + doIt(i));
			<P class="CStep2">}
			<P class="CStep2">public static int doIt(int a) {
			<P class="CStep3">switch(a) {
			<P class="CStep4">case 1:
			<P class="CStep5">System.out.println(&quot;1이 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep4">case 2:
			<P class="CStep5">System.out.println(&quot;2가 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep4">case 3:
			<P class="CStep5">System.out.println(&quot;3이 입력되었습니다.&quot;);
			<P class="CStep5">break;
			<P class="CStep4">default:
			<P class="CStep3">//		assert false : a;
			<P class="CStep4"><B>throw new AssertionError(a);</B>
			<P class="CStep3">}
			<P class="CStep3">return a;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="450" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242" height="31"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="450" cellpadding="0" cellspacing="0">
		<tr>
			<td width="438">
			<P class="Result">Exception in thread &quot;main&quot; java.lang.AssertionError: 5
			<P class="Result">at AssertionExample.doIt(AssertionExample.java:19)
			<P class="Result">at AssertionExample.main(AssertionExample.java:4)</td>
		</tr>
		</table>
		<P>Assertion에 대한 자세한 내용은 썬사의 자바 웹사이트 
		<P>http://java.sun.com/j2se/1.4/docs/guide/lang/assert.html을 참고하기 바란다.
	    </ul></td>
    </tr>
	</table>
</body>
</html>