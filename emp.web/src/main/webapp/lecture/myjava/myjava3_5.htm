<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>ead>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">3.5</P></td>
        <td width="518">
        <p class="TitleTitle" align="left">&nbsp;static Modifier</td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>		
		<P>&nbsp;static은 변수, 메소드, 변수범위에 적용되어 특별한 의미를 갖게 한다.
		</ul>
		<P class="TSubmenu">3.5.1 static variables
		<ul>
		<P>static변수는 모든 객체들이 공유하는 공유변수가 된다. 다음 예에서 변수 a의 경우 객체 c1과 c2에 따로 잡히지만 b의 경우에는 같은 장소를 참조하게 된다. 뿐만 아니라  16번째 줄에서 처럼 멤버 참조시에 해당 클래스의 인스턴스 없이도 참조가 가능하다.
		<P>다음은 변수가 static으로 선언되었을 때를 나타내고 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Count.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Count {
			<P class="CStep2">public int a=0;
			<P class="CStep2">public <B>static</B> int b=0;
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestCount.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">16:
			<P class="CNumber">17:
			<P class="CNumber">18:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestCount {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">Count c1 = new Count();
			<P class="CStep3">c1.a++;
			<P class="CStep3">c1.b++;
			<P class="CStep3">System.out.println(&quot;Non-static a : &quot; + c1.a);
			<P class="CStep3">System.out.println(&quot;static b : &quot; + c1.b);
			<P class="CStep3">Count c2 = new Count();
			<P class="CStep3">c2.a++;
			<P class="CStep3">c2.b++;
			<P class="CStep3">System.out.println(&quot;Non-static a : &quot; + c2.a);
			<P class="CStep3">System.out.println(&quot;static b : &quot; + c2.b);
			<P class="CStep3">Count.b++;
			<P class="CStep3">System.out.println(&quot;c1.b : &quot; + c1.b);
			<P class="CStep3">System.out.println(&quot;c2.b : &quot; + c2.b);
			<P class="CStep3">System.out.println(&quot;Count.b : &quot; + Count.b);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">Non-static a : 1
			<P class="Result">static b : 1
			<P class="Result">Non-static a : 1
			<P class="Result">static b : 2
			<P class="Result">c1.b : 3
			<P class="Result">c2.b : 3
			<P class="Result">Count.b : 3</td>
		</tr>
		</table>
		</ul>
		<P class="TSubmenu">3.5.2 static methods
		<ul>
		<P>static메소드는 변수와 마찬가지로 다음 예 TestStatic.java의 4번째 줄에서처럼 해당 클래스의 인스턴스 없이 참조가 가능하게 해준다. 또한 Count클래스의 6번째 줄에서처럼 static 메소드 안에서는 non-static 멤버(변수 또는 메소드)를 객체생성 없이 직접 참조할 수 없고, 메소드 안에서는 static변수를 선언할 수 없다.
		<P>다음은 static 메소드 예를 나타내고 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Count.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Count {
			<P class="CStep2">public int a=0;
			<P class="CStep2">public static int b=0;
			<P class="CStep2">public <B>static</B> int doIt() {
			<P class="CStep3">//return ++a;	<B>//Error</B>
			<P class="CStep3">return ++b;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestCount.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestCount {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">System.out.println(&quot;Count.doIt() : &quot; + <B>Count.doIt()</B>);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">Count.doIt() : 1</td>
		</tr>
		</table>
		</ul>
		<P class="TSubmenu">3.5.3 static initializer
		<ul>
		<P>정적 블록(static block)또는 정적 초기화자라고도 하며, static initializer는 클래스가 로딩될 때 main()메소드에 앞서 한번만 실행된다.  자바에서 JDBC를 이용하여 데이터베이스 연결시 드라이버 로딩에 사용될 수도 있다.
		<P>다음은 클래스 안에 static블록을 두는 static initializer예를 나타내고 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>StaticInit.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class StaticInit {
			<P class="CStep2">static {
			<P class="CStep3">System.out.println(&quot;static initializer가 수행됨&quot;);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestInitializer.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestInitializer {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">StaticInit c1 = new StaticInit();
			<P class="CStep3">System.out.println(&quot;***********************&quot;);
			<P class="CStep3">StaticInit c2 = new StaticInit();
			<P class="CStep3">System.out.println(&quot;***********************&quot;);
			<P class="CStep3">System.out.println(&quot;main() 메소드 종료&quot;);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">static initializer가 수행됨
			<P class="Result">***********************
			<P class="Result">***********************
			<P class="Result">main() 메소드 종료</td>
		</tr>
		</table>
		<P>▒ static 키워드의 기능을 정리하면 다음과 같다.
		<P>- 변수, 메소드, 범위에만 적용된다.
		<P>- static 메소드나 변수는 해당 클래스의 인스턴스 없이도 사용할 수 있다.
		<P>- static 메소드 안에서는 static 변수만 사용해야하고, static 메소드만 호출할 수 있다. 즉 static 메소드에서 non-static 멤버를 객체생성 없이 직접 참조할 수 없다.
		<P>- static 제한자는 지정된 변수와 메소드를 인스턴스와 무관하게 만들어 주기 때문에 this를 가질 수 없다.
		<P>- static 메소드는 non-static 메소드로 재정의(overriding)될 수 없다.
		<P>- scope({와 })에 사용할 경우에는 static initializer라하며, 이는 클래스가 로딩될 때 main()이 있더라도 main() 메소드보다 앞서 딱 한번만 수행된다.
		<P>- 대표적인 static 메소드는 애플리케이션의 main() 메소드이다.
		</ul>
		<P class="TSubmenu">3.5.4 Singleton Design Pattern
		<ul>
		<P>Singleton Design Pattern은 객체를 하나만 만들도록 하는 일종의 프로그래밍 방법이다. 다음 예를 보면 Company 클래스에서는 생성자를 private으로 선언하여 외부에서 생성자를 이용하여 객체 생성이 불가능하게 하였다. 그리고 멤버 변수에서는 자신의 객체를 생성하고, 이를 또한 private으로 선언하여 외부에서 직접 참조가 불가능하게 하고 static을 붙여서 static 메소드에서 객체생성 없이 직접 참조가 가능하게 하였다. 마지막으로 멤버변수에서 만들어진 인스턴스를 참조하기 위해 public 메소드를 이용하였는데, 메소드도 객체 생성 없이 참조가 가능하도록 static으로 선언했다. 실행 결과를 보면 두 개의 인스턴스가 같은 해시코드(hashcode)를 가지고있는 것을 볼 수 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Company.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">class Company{
			<P class="CStep2">private String str;
			<P class="CStep2"><B>private static</B> <B>Company c = new Company();</B>
			<P class="CStep2"><B>private Company(){</B>
			<P class="CStep3">str = &quot;company&quot;;
			<P class="CStep3">System.out.println(str);
			<P class="CStep2">}
			<P class="CStep2"><B>public static Company getCompany(){</B>
			<P class="CStep3">return c;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestSingleton.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestSingleton {
			<P class="CStep2">public static void main(String [] args){
			<P class="CStep3">Company c1 = Company.getCompany();
			<P class="CStep3">Company c2 = Company.getCompany();
			<P class="CStep3">System.out.println(c1);
			<P class="CStep3">System.out.println(c1 == c2);
			<P class="CStep3">System.out.println(c2);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">company
			<P class="Result">Company@372a1a
			<P class="Result">true
			<P class="Result">Company@372a1a</td>
		</tr>
		</table>
		</ul></td>
    </tr>
	</table>
</body>

</html>
