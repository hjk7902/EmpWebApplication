<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">3.4</P></td>
        <td width="518">
        <p class="TitleTitle">다형성(polymorphism)</td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>		
		<P>&nbsp;다형성은 임의의 객체가 다른 객체를 참조하는 것을 말한다. 다형성은 상속을 전제조건으로 하는데, 상속을 통해서 생성된 클래스는 계층 내에서는 동일한 메시지라도 어떤 객체에게 전달되느냐에 따라 다양한 동작이 발생한다. 다형성이란 &quot;poly(多)&quot;와 &quot;morph(形)&quot;가 합쳐진 합성어로 &quot;여러 형태를 가진다&quot;는 뜻이다.<P>이와 같은 다형성은 확장이 가능한 시스템을 설계할 수 있도록 해주는데, 프로그램의 개발 시점에서는 존재하지 않았던 클래스를 기존 시스템의 수정 없이 시스템에 추가되도록 해 준다. 이는 모든 상속의 계층구조에서 서브클래스의 객체를 슈퍼클래스의 참조로 처리함으로써 가능하다.
		<P>앞의 Person과 그 하위 클래스에서 예를 만들어 보도록 하자.
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestPolymorphism {
			<P class="CStep2">public static void main(String[] args) 	{
			<P class="CStep3">Person p = new Person(&quot;홍길동&quot;, 29);
			<P class="CStep3">Student s = new Student(&quot;허준&quot;, 25, &quot;10007890&quot;);
			<P class="CStep3"><B>Person ps = new Student(&quot;이순신&quot;, 30, &quot;20001234&quot;);</B>
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
		<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1"><B>Person ps = new Student(&quot;이순신&quot;, 30, &quot;20001234&quot;);</B></TD>
		</tr>
		</TABLE>
		<P>5번째 줄에서 객체를 선언한 부분이 좀 어색해 보이는데 원래대로라면 3번째 줄이나 4번째 줄처럼 나타내야 올바른 표현이다.
		<P>한가지 중요한 점은 앞에서 다형성은 임의의 객체가 다른 객체를 참조하는 것이라고 하였는데 상속을 전제로 한다고 하였다. 다시 말하면 부모를 참조하는 reference변수는 자손 객체도 참조할 수 있음을 나타낸다. 따라서 5번째 줄에서 객체 ps는 부모와 자손 모두 참조할 수 있다. 이러한 점이 자바에서 다형성 구현을 가능하게 해주는 기능이다. 
		</ul>
		<P class="TSubmenu">3.4.1 Virtual Method Invocation
		<ul>
		<P>우선 다음의 예를 먼저 살펴보자. 앞의 Person클래스와 Student클래스를 다시 보인 프로그램이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Person.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Person {
			<P class="CStep2">private String name;
			<P class="CStep2">private int age;
			<P class="CStep2">public Person(String init_name, int init_age) {
			<P class="CStep3">name = init_name;
			<P class="CStep3">age = init_age;
			<P class="CStep2">}
			<P class="CStep2">public String getDetails() {
			<P class="CStep3">return &quot;이름: &quot; + name + &quot;\t나이: &quot; + age;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Student.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">&nbsp;
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Student extends Person{
			<P class="CStep2">private String studentId;
			<P class="CStep2">public Student(String init_name, int init_age,
			<P class="CStep2">String init_studentID) {
			<P class="CStep3">super(init_name, init_age);
			<P class="CStep3">studentId = init_studentID;
			<P class="CStep2">}
			<P class="CStep3">public String getDetails() {
			<P class="CStep3">return super.getDetails() +
			<P class="CStep3">&quot;\t학번: &quot; + studentId;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestPolymorphism.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestPolymorphism {
			<P class="CStep2">public static void main(String[] args) 	{
			<P class="CStep3"><B>Person ps = new Student(&quot;이순신&quot;, 30, &quot;20001234&quot;);</B>
			<P class="CStep3">System.out.println( <B>ps.getDetails()</B> );
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400">
			<P class="Result">이름: 이순신    나이: 30        학번: 20001234</td>
		</tr>
		</table>
		<P>위의 예는 다형성에서의 메소드 호출을 보여주고 있다. 7번째 줄에서 호출하고 있는 getDetails() 메소드는 Person클래스의 메소드를 Student클래스에서 재정의 하고 있다. 객체 ps는 Person 클래스를 이용하여 선언했지만 실제로 만들어진 것은 Student 객체이다. 따라서, 실제 호출되는 메소드는 Person의 것이 아니고 Student의 것이다. 결국 Student의 getDetails() 메소드가 호출된다. 즉, 객체 p가 참조하는 getDetails() 메소드는 컴파일시에는 Person의 것을, 실행시에는 Student의 것을 참조한다. 이를 보고 Virtual method invocation이라 한다.
		<P>여기서 주의할 점은 부모의 참조변수가 자손을 참조한다고 해서 그 변수가 자손의 모든 것을 호출할 수 있는 것은 아니다. 부모의 참조변수가 자손을 참조할 때는 부모로부터 상속받은 것이나 부모의 메소드를 재정의한 것만 가능하다. 따라서, 부모로부터 상속받지 않거나, 재 정의되지 않은 것을 호출할 때는 오류가 발생하게 된다. 
		</ul>
		<P class="TSubmenu">3.4.2 이종모음(Heterogeneous Collection)
		<ul>
		<P>다형성의 개념은 약간 복잡하지만 강력한 기능을 가지고 있다. 따라서, 다형성에 대해 좀더 자세히 알아보도록 하자.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Person.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Person {
			<P class="CStep2">private String name;
			<P class="CStep2">private int age;
			<P class="CStep2">public Person(String init_name, int init_age) {
			<P class="CStep3">name = init_name;
			<P class="CStep3">age = init_age;
			<P class="CStep2">}
			<P class="CStep2">public String getDetails() {
			<P class="CStep3">return &quot;이름: &quot; + name + &quot;\t나이: &quot; + age;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Student.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">&nbsp;
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Student extends Person{
			<P class="CStep2">private String studentId;
			<P class="CStep2">public Student(String init_name, int init_age,
			<P class="CStep2">String init_studentID) {
			<P class="CStep3">super(init_name, init_age);
			<P class="CStep3">studentId = init_studentID;
			<P class="CStep2">}
			<P class="CStep2">public String getDetails() {
			<P class="CStep3">return super.getDetails() + &quot;\t학번: &quot; + studentId;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<p>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Teacher.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">&nbsp;
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Teacher extends Person{
			<P class="CStep2">protected String subject;
			<P class="CStep2">public Teacher(String init_name, int init_age,
			<P class="CStep2">String init_subject) {
			<P class="CStep3">super(init_name, init_age);
			<P class="CStep3">subject = init_subject;
			<P class="CStep2">}
			<P class="CStep2">public String getDetails() {
			<P class="CStep3">return super.getDetails() + &quot;\t과목: &quot; + subject;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<p>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Employee.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">&nbsp;
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Employee extends Person{
			<P class="CStep2">protected String department;
			<P class="CStep2">public Employee(String init_name, int init_age,
			<P class="CStep2">String init_department)
			<P class="CStep3">{</p>
			<P class="CStep3">super(init_name, init_age);
			<P class="CStep2">department = init_department;
			<P class="CStep2">}
			<P class="CStep2">public String getDetails() {
			<P class="CStep3">return super.getDetails() + &quot;\t부서: &quot; + department;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>앞의 예제를 보면 Student, Teacher, Employee 클래스가 Person 클래스를 상속받았는데, 다형성을 배열에 적용하면 다음 프로그램과 같다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestHetero.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestHetero {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3"><B>Person[] p = new Person[4];</B>
			<P class="CStep3"><B>p[0] = new Person(&quot;홍길동&quot;, 30);</B>
			<P class="CStep3"><B>p[1] = new Student(&quot;허준&quot;, 25, &quot;20001233&quot;);</B>
			<P class="CStep3"><B>p[2] = new Teacher(&quot;박승규&quot;, 40, &quot;JAVA&quot;);</B>
			<P class="CStep3"><B>p[3] = new Employee(&quot;이국&quot;, 30, &quot;교무처&quot;);</B>
			<P class="CStep3">for(int i=0; i&lt;p.length; i++) {
			<P class="CStep4">System.out.println( p[i].getDetails() );
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400">
			<P class="Result">이름: 홍길동    나이: 30
			<P class="Result">이름: 허준      나이: 25        학번: 20001233
			<P class="Result">이름: 박승규    나이: 40        과목: JAVA
			<P class="Result">이름: 이국      나이: 30        부서: 교무처</td>
		</tr>
		</table>
		<P>앞의 예를 보고 이상한 점을 발견했을 것이다. 배열은 같은 유형의 자료만 저장할 수 있는 것으로 알고 있었지만, 이 예는 다른 유형의 객체들이 하나의 배열에 저장되어 있다. 이러한 기능이 바로 부모의 참조 변수는 자손도 참조할 수 있다는 다형성의 원리이다. 이와 같이 배열에 다형성이 적용되어 서로 다른 자료형을 저장하는 것을 이종모음이라고 한다.
		<P>자바의 모든 객체는 Object라는 클래스를 자동 상속받게 되므로 다음과 같이 배열을 Object 타입으로 생성하면 자바의 모든 객체를 참조할 수도 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestHetero2.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">class TestHetero2 {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3"><B>Object arr[] = new Object[5];</B>
			<P class="CStep3">arr[0] = new Person(&quot;홍길동&quot;, 30);
			<P class="CStep3">arr[1] = new Student(&quot;허준&quot;, 25, &quot;20001233&quot;);
			<P class="CStep3">arr[2] = new Integer(100);
			<P class="CStep3">arr[3] = new String(&quot;Hello&quot;);
			<P class="CStep3">arr[4] = new java.util.Date();
			<P class="CStep3">for(int i=0; i&lt;arr.length; i++) {
			<P class="CStep4">System.out.println( arr[i] );
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">Person@26b249
			<P class="Result">Student@82f0db
			<P class="Result">100
			<P class="Result">Hello
			<P class="Result">Mon Apr 08 18:56:20 KST 2002</td>
		</tr>
		</table>
		</ul>
		<P class="TSubmenu">3.4.3 Wrapper Class
		<ul>
		<P>앞의 예에서 arr[]이 reference형이면 모든 자료형을 저장할 수 있지만 primitive 자료형은 저장할 수 없는 단점이 있다. 
		<P>다음은 primitive 자료형을 클래스로 구현해 놓은 것인데, 이러한 클래스를 Wrapper 클래스라고 한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=404>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Primitive Data Type</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Wrapper Class</TD>
		</tr>
		<TR>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>byte</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Byte</TD>
		</tr>
		<TR>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>short</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Short</TD>
		</tr>
		<TR>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>int</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Integer</TD>
		</tr>
		<TR>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>long</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Long</TD>
		</tr>
		<TR>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>float</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Float</TD>
		</tr>
		<TR>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>double</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Double</TD>
		</tr>
		<TR>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>boolean</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Boolean</TD>
		</tr>
		<TR>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>char</TD>
			<TD WIDTH=50%>
			<P ALIGN=CENTER>Character</TD>
		</tr>
		</TABLE>
		<P>다음은 Wrapper클래스를 이용하여 배열에 서로 다른 자료형을 저장하는 예를 보인 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestWrapper.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">16:
			<P class="CNumber">17:
			<P class="CNumber">18:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestWrapper {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">Object[] obj = new Object[10];
			<P class="CStep3">obj[0] = new Byte((byte)127);
			<P class="CStep3">obj[1] = new Short((short)32767);
			<P class="CStep3">obj[2] = new Integer(2147483647);
			<P class="CStep3">obj[3] = new Long(2136484836482L);
			<P class="CStep3">obj[4] = new Float(3.5F);
			<P class="CStep3">obj[5] = new Double(3.7);
			<P class="CStep3">obj[6] = new Boolean(true);
			<P class="CStep3">obj[7] = new Character('J');
			<P class="CStep3">obj[8] = new String(&quot;Hello Java&quot;);
			<P class="CStep3">obj[9] = new java.util.Date();
			<P class="CStep3">for(int i=0; i&lt;obj.length ; i++) {
			<P class="CStep4">System.out.println(obj[i]);
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">127
			<P class="Result">32767
			<P class="Result">2147483647
			<P class="Result">2136484836482
			<P class="Result">3.5
			<P class="Result">3.7
			<P class="Result">true
			<P class="Result">J
			<P class="Result">Hello Java
			<P class="Result">Mon Apr 08 18:57:00 KST 2002</td>
			</tr>
		</table>
		</ul>
		<P class="TSubmenu">3.4.4 Polymorphic Argument
		<ul>
		<P>다형성이 메소드의 인자에 적용된 것을 Polymorphic Argument라 부르는데, 메소드의 인자뿐만 아니라 메소드의 리턴타입에도 적용이 된다.
		<P>다음은 다형성이 메소드 인자와 리턴타입에 적용된 예를 나타낸 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Person.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">16:
			<P class="CNumber">17:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Person {
			<P class="CStep2">private String name;
			<P class="CStep2">private int age;
			<P class="CStep2">public Person(String init_name, int init_age) {
			<P class="CStep3">name = init_name;
			<P class="CStep3">age = init_age;
			<P class="CStep2">}
			<P class="CStep2">public String getDetails() {
			<P class="CStep3">return &quot;이름: &quot; + name + &quot;\t나이: &quot; + age;
			<P class="CStep2">}
			<P class="CStep2">public void setName(String name) {
			<P class="CStep3">this.name = name;
			<P class="CStep2">}
			<P class="CStep2">public void setAge(int age) {
			<P class="CStep3">this.age = age;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Student.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">&nbsp;
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Student extends Person{
			<P class="CStep2">private String studentId;
			<P class="CStep2">public Student(String init_name, int init_age,
			<P class="CStep2">String init_studentID) {
			<P class="CStep3">super(init_name, init_age);
			<P class="CStep3">studentId = init_studentID;
			<P class="CStep2">}
			<P class="CStep2">public String getDetails() {
			<P class="CStep3">return super.getDetails() + &quot;\t학번: &quot; + studentId;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestPolyArg.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestPolyArg {
			<P class="CStep2">public static void main(String[] args) 	{
			<P class="CStep3">Student s = new Student(&quot;허준&quot;, 25, &quot;20001233&quot;);
			<P class="CStep3">Person s2 = setPerson(s);
			<P class="CStep3">System.out.println( s2.getDetails() );
			<P class="CStep2">}
			<P class="CStep2">public static <B>Person</B> setPerson(<B>Person p</B>) {
			<P class="CStep3">p.setName(&quot;홍길동&quot;);
			<P class="CStep3">p.setAge(29);
			<P class="CStep3">return p;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400">
			<P class="Result">이름: 홍길동 나이: 29 학번: 20001233</td>
		</tr>
		</table>
		<p> 앞의 9번째 줄에서 리턴타입이 Person형으로 되어있는데 polyMethod() 메소드를 호출하여 Student형으로 선언한 자료에 대입하면 어떻게 될까? 
		<P>Primitive 자료형에서 형 변환이 발생하듯이 객체에서도 형 변환이 발생한다. 다음은 위의 5번째 줄을 Student형으로 선언했을 때 객체 형 변환한 예를 보이고 있다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">Student s2 = <B>(Student)</B> setPerson(s);</TD>
		</tr>
		</TABLE>
		<P>형 변환시 작은 유형에서 큰 유형으로는 형 변환이 가능하지만, 큰 유형에서 작은 유형으로의 형 변환은 반드시 명시해 주어야한다. 즉, polyMethod()의 Person형이 Student형보다 큰 자료형이므로 앞에 &quot;(Student)&quot;라고 명시한 것이다.
		</ul>
		<P class="TSubmenu">3.4.5 instanceof
		<ul>
		<P>instanceof는 객체가 특정 클래스의 인스턴스 인지를 검사할 때 사용하는 연산자이다.
		<P>다음 예에서 사용법이 나타나 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestInstanceof.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:
			<P class="CNumber">10:
			<P class="CNumber">11:
			<P class="CNumber">12:
			<P class="CNumber">13:
			<P class="CNumber">14:
			<P class="CNumber">15:
			<P class="CNumber">16:
			<P class="CNumber">17:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestInstanceof {
			<P class="CStep2">public static void main(String[] args) 	{
			<P class="CStep3">Student s = new Student(&quot;허준&quot;, 25, &quot;20001233&quot;);
			<P class="CStep3">Person s2 = printInfo(s);
			<P class="CStep1">System.out.println( s2.getDetails() );
			<P class="CStep2">}
			<P class="CStep2">public static Person printInfo(Person p) {
			<P class="CStep3">if( p <B>instanceof</B> Student ) {
			<P class="CStep4">System.out.println(&quot;학생 instance입니다.&quot;);
			<P class="CStep3">} else if( p instanceof Teacher ) {
			<P class="CStep4">System.out.println(&quot;선생 instance입니다.&quot;);
			<P class="CStep3">} else if( p instanceof Employee ) {
			<P class="CStep4">System.out.println(&quot;직원 instance입니다.&quot;);
			<P class="CStep3">}
			<P class="CStep3">return p;
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="400" cellpadding="0" cellspacing="0">
		<tr>
			<td width="400">
			<P class="Result">학생 instance입니다.
			<P class="Result">이름: 허준      나이: 25        학번: 20001233</td>
		</tr>
		</table>
		</ul>
		<P class="TSubmenu">3.4.6 중복(overloading)
		<ul>
		<P>중복은 메소드와 생성자를 사용할 때 하나의 이름으로 서로 다른 인자값이 같은 기능을 수행하게 한다. 즉, 중복기능을 사용하여 하나의 인터페이스로 일반적인 클래스를 사용할 수 있는 것이다.
		<P>중복 조건은 다음과 같다.
		<P>  &middot; 이름이 같아야 한다.
		<P>  &middot; 인자 유형(parameter type)이 달라야 한다.
		<P>  &middot; 인자의 개수가 달라야 한다.
		<P>  &middot; 인자의 순서가 달라야 한다.
		<P>  &middot; 리턴형은 영향을 미치지 않는다.
		<P>자바에서 가장쉽게 볼 수 있는 중복 예는 System.out.print() 메소드 인데, 실제 java.io.PrintStream클래스의 print() 메소드를 보면 다음과 같이 9개의 메소드로 구성되어 있다.
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<p class="TStep1">public void print(boolean b)
			<p class="TStep1">public void print(char c)
			<p class="TStep1">public void print(int I)
			<p class="TStep1">public void print(long l)
			<p class="TStep1">public void print(float f)
			<p class="TStep1">public void print(double d)
			<p class="TStep1">public void print(char[] s)
			<p class="TStep1">public void print(String s)
			<p class="TStep1">public void print(Object obj)</TD>
		</tr>
		</TABLE>
		<P>화면이나 콘솔에 값을 출력할 때, 위와 같이 인자에 따라서 각각의 값을 출력하도록 하는 9개 메소드가 있으므로 사용자는 인자의 종류에 따른 입력 변경이나 메소드의 이름 변경 없이 자유롭게 출력할 수 있다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Overloading.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">class Overloading {
			<P class="CStep2">public void <B>abc(int i, String str)</B> {
			<P class="CStep3">System.out.println(&quot;정수와 문자열이 입력됨&quot;);
			<P class="CStep2">}
			<P class="CStep2">public void <B>abc(String str)</B> {
			<P class="CStep3">System.out.println(&quot;문자열이 입력됨&quot;);
			<P class="CStep2">}
			<P class="CStep1">}	</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestOverloading.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">1:
			<P class="CNumber">2:
			<P class="CNumber">3:
			<P class="CNumber">4:
			<P class="CNumber">5:
			<P class="CNumber">6:
			<P class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestOverloading {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">Overloading om = new Overloading();
			<P class="CStep3">om.abc(100, &quot;자바&quot;);
			<P class="CStep3">om.abc(&quot;자바&quot;);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">정수와 문자열이 입력됨
			<P class="Result">문자열이 입력됨</td>
		</tr>
		</table>
		</ul></td>
	</tr>
	</table>
</body>
</html>