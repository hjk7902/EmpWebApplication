<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">8.1</P></td>
        <td width="518">
        <p class="TitleTitle">스트림(Streams)</td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
		<td width="1101">
		<ul>
		<P>&nbsp;먼저 입출력을 이해하기 전에 스트림이라는 용어부터 알아보자. 스트림은 source에서, sink로의 데이터 흐름을 말한다. source는 데이터 흐름의 출발점으로 입력 스트림이라고도 하며, sink는 데이터 흐름이 끝나는 지점으로 출력 스트림이라고 한다. 예를 들어 c:\temp\in.txt 파일을 읽어들이는 프로그램을 개발하려면 in.txt 파일이 입력 스트림이 되고, 반대로 out.txt 파일에 무언가를 쓰려고 하면 이 파일이 출력 스트림이 되는 것이다. source와 sink를 합해서 노드라고 하는데, 노드의 종류로는 디스크상의 파일, 메모리, 또는 쓰레드나 프로세스 사이에서 채널역할을 하는 파이프 등이 있다. 이 같은 디스크 파일이나 메모리 영역과 같은 노드에서 읽거나 쓰는 스트림을 노드 스트림(Node Stream)이라 한다. 일단 스트림에서 데이터를 읽으려면 노드 스트림이 필요한데, 노드 스트림을 통해서만 노드로부터 데이터를 읽거나 쓸 수 있기 때문이다.
		<P>자바는 입출력을 수행할 때 문자단위 스트림과 바이트단위 스트림 형식을 지원하는데 다음 표와 같이 문자자료의 입출력은 Reader와 Writer에 의해 이루어지고, 바이트자료의 입출력은 InputStream과 OutputStream에 의해 이루어진다.
		<P>
		<table BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=30%></td>
			<TD WIDTH=34%>
			<P ALIGN=CENTER><B>Byte Streams</B></TD>
			<TD WIDTH=34%>
			<P ALIGN=CENTER><B>Character Streams</B></TD>
		</tr>
		<TR>
			<TD WIDTH=30%>
			<P ALIGN=CENTER><B>Source Streams</B></TD>
			<TD WIDTH=34%>
			<P ALIGN=CENTER>InputStream</TD>
			<TD WIDTH=34%>
			<P ALIGN=CENTER>Reader</TD>
		</tr>
		<TR>
			<TD WIDTH=30%>
			<P ALIGN=CENTER><B>Sink Streams</B></TD>
			<TD WIDTH=34%>
			<P ALIGN=CENTER>OutputStream</TD>
			<TD WIDTH=34%>
			<P ALIGN=CENTER>Writer</TD>
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">8.1.1 노드스트림
		<ul>
		<P>앞에서도 잠깐 언급한바와 같이 자바에서는 3가지 종류의 노드(파일, 메모리, 파이프)를 지원하는데 각 노드와 연결될 수 있는 클래스는 다음 표와 같다. 
		<P>
		<table BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=25%></td>
			<TD WIDTH=37%>
			<P ALIGN=CENTER><B>Byte Streams</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER><B>Character Streams</B></TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>File</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>FileInputStream
			<P ALIGN=CENTER>FileOutputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>FileReader
			<P ALIGN=CENTER>FileWriter</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Memory : Array</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>ByteArrayInputStream
			<P ALIGN=CENTER>ByteArrayOutputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>CharArrayReader
			<P ALIGN=CENTER>CharArrayWriter</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Memory : String</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>-</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>StringReader
			<P ALIGN=CENTER>StringWriter</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Pipe</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>PipedInputStream
			<P ALIGN=CENTER>PipedOutputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>PipedReader
			<P ALIGN=CENTER>PipedWriter</TD>
		</tr>
		</TABLE>
		<P>입출력 수행을 위해 노드와 연결하려면 앞의 표에있는 클래스의 객체를 생성하면 된다. 그 다음 각 클래스에 정의되어 있는 메소드를 이용하여 원하는 작업을 수행한다. 
		<P>다음은 노드스트림의 사용 예를 보인 것이다.
		<P>
		<table BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=2%></td>
			<TD WIDTH=97%>
			<p class="TStep1"><B>FileReader</B> input = new FileReader(&quot;c:\in.txt&quot;);
			<p class="TStep1">input.<B>read()</B>;</TD>
		</tr>
		</TABLE>
		<P>앞의 예를 보면 &quot;c:\in.txt&quot; 파일을 읽기 위해 노드스트림인 FileReader객체를 생성했는데 이 객체를 통해 파일에서 데이터를 읽을 수 있다. 예를 들어 FileReader 클래스에는 read() 메소드가 있는데, 이를 호출하면 한 문자를 읽어올 수 있다.
		<P>다음 프로그램은 첫 번째 명령행 인자로 입력된 이름의 파일에서 문자를 읽어들여 두 번째 명령행 인자로 입력된 파일에 문자를 쓰는 예제이다. 즉, 파일을 복사하는 예를 보인 것이다.
		<P>
		<table BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>NodeStreamExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.io.*;
			<P class="CStep1">public class NodeStreamExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">try {
			<P class="CStep4"><B>FileReader</B> input = new FileReader(args[0]);
			<P class="CStep4"><B>FileWriter </B>output = new FileWriter(args[1]);
			<P class="CStep4">char[] buffer = new char[128];
			<P class="CStep4">int charsRead;
			<P class="CStep4">charsRead = input.<B>read(buffer)</B>;
			<P class="CStep4">while ( charsRead != -1 ) {
			<P class="CStep5">output.<B>write(buffer, 0, charsRead)</B>;
			<P class="CStep5">charsRead = input.read(buffer);
			<P class="CStep4">}
			<P class="CStep4">input.close();
			<P class="CStep4">output.close();
			<P class="CStep3">} catch (IOException e) {
			<P class="CStep4">e.printStackTrace();
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">8.1.2 필터스트림
		<ul>
		<P>필터스트림(Filter Stream)은 처리스트림(Processing Stream)이라고도 하며 다른 객체를 둘러싸는 역할을 한다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV311.GIF" BORDER=0 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
		<P>필터스트림들을 사용하는 이유는 노드스트림의 부족한 기능을 보완하여 좀더 정밀한 입출력을 하기 위해서다. 예들 들어 FileReader클래스의 노드스트림은 파일에서 텍스트를 읽어올 때 한 문자씩 읽는 낮은 수준의 메소드(read() 메소드)만 가지고 있는 반면, BufferedReader클래스 등의 필터스트림은 줄 단위로 읽어 String으로 반환하는 고급 메소드(readLine() 메소드)를 포함하고 있기 때문에 좀더 편리하게 입출력 작업을 할 수 있는 것이다.
		<P>다음 표는 필터스트림 클래스를 나타낸 것이다.
		<P>
		<table BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Type</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER><B>Byte Streams</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER><B>Character Streams</B></TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Buffering</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>BufferedInputStream
			<P ALIGN=CENTER>BufferedOutputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>BufferedReader
			<P ALIGN=CENTER>BufferedWriter</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Filtering</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>FilterInputStream
			<P ALIGN=CENTER>FilterOutputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>FilterReader
			<P ALIGN=CENTER>FilterWriter</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Converting </B>
			<P ALIGN=CENTER><B>bytes↔character</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>-</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>InputStreamReader
			<P ALIGN=CENTER>OutputStreamWriter</TD>
		</tr>
		</TABLE>
		<P>
		<table BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Type</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER><B>Byte Streams</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER><B>Character Streams</B></TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Object</B>
			<P ALIGN=CENTER><B>Serialization</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>ObjectInputStream
			<P ALIGN=CENTER>ObjectOutputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>-</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Data conversion</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>DataInputStream
			<P ALIGN=CENTER>DataOutputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>-</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Counting</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>LineNumberInputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>LineNumberReader</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Peeking ahead</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>PushbackInputStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>PushbackReader</TD>
		</tr>
		<TR>
			<TD WIDTH=25%>
			<P ALIGN=CENTER><B>Printing</B></TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>PrintStream</TD>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>PrintWriter</TD>
		</tr>
		</TABLE>
		<P>▒ FilterXxx 클래스는 abstract클래스로 사용자가 임의의 필터스트림을 만들 때 사용한다.
		<P>다음은 필터 스트림의 사용 예를 보인 것이다.
		<P>
		<table BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=2%></td>
			<TD WIDTH=97%>
			<p class="TStep1">FileReader input = new FileReader(&quot;c:\in.txt&quot;);
			<p class="TStep1"><B>BufferedReader</B> bufInput = new BufferedReader(input);
			<p class="TStep1">bufInput.<B>readLine()</B>;</TD>
		</tr>
		</TABLE>
		<P>앞의 예에서 BufferedReader클래스의 인자로 FileReader클래스의 객체가 사용되었다. 이렇게 Buffered -Reader클래스를 사용하면 readLine() 메소드를 이용하여  데이터를 줄 단위로 읽어들일 수가 있다.
		<P>다음 프로그램은 앞의 예제와 같이 파일을 복사하는 프로그램이다. 앞 프로그램과 다른 점은 문자단위로 읽지않고, BufferedStream을 이용하여 줄 단위로 처리한다.
		<P>
		<table BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>FilterStreamExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">&nbsp;
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">&nbsp;
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.io.*;
			<P class="CStep1">public class FilterStreamExample {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">try {
			<P class="CStep4">FileReader input = new FileReader(args[0]);
			<P class="CStep4"><B>BufferedReader</B> bufInput = 
			<P class="CStep4">new BufferedReader(input);
			<P class="CStep4">FileWriter output = new FileWriter(args[1]);
			<P class="CStep4"><B>BufferedWriter </B>bufOutput = 
			<P class="CStep4">new BufferedWriter(output);
			<P class="CStep4">String line;
			<P class="CStep4">line = bufInput.<B>readLine()</B>;
			<P class="CStep4">while ( line != null ) {
			<P class="CStep5">bufOutput.<B>write(line, 0, line.length())</B>;
			<P class="CStep5">bufOutput.newLine();
			<P class="CStep5">line = bufInput.readLine();
			<P class="CStep4">}
			<P class="CStep4">bufInput.close();
			<P class="CStep4">bufOutput.close();
			<P class="CStep3">} catch (IOException e) {
			<P class="CStep4">e.printStackTrace();
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>이 예제에서는 FileReader와 FileWriter클래스 외에 BufferedReader와 BufferedWriter클래스가 사용되었는데 BufferedReader와 BufferedWriter클래스가 필터스트림이다.
		<P>사용자가 원하는 필터스트림 클래스를 만들려면 FilterXxx(예 : FilterReader)형식의 abstract 클래스를 상속받아 구현한다.
		<P>자바에서의 입출력은 노드스트림이나 필터스트림 중에서 상황에 맞는 스트림을 선택하여 사용한다. 특히 자바에서는 다양한 입출력 API를 제공하기 때문에 자주 API 문서를 참고해야 한다. 또, 어떤 클래스가 노드스트림이고 어떤 클래스가 필터스트림인지 암기할 필요는 없고 API문서에서 사용할 클래스 생성자가 노드스트림 역할을 하는지 필터스트림 역할을 하는지를 구별하면 된다.
		<P>다음 표는 두 생성자의 특징을 요약한 것이다.
		<P>
		<table BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=100%>
			<P>FileInputStream클래스의 생성자 요약 </TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<P><U>FileInputStream</U> (<U>File</U> file)
			<P>Creates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system.</TD>
		</tr>
			<TR>
			<TD WIDTH=100%>
			<P><U>FileInputStream</U> (<U>FileDescriptor</U> fdobj)
			<P>Creates a FileInputStream by using the file descriptor fdObj, which represents an existing connection to an actual file in the file system.</TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<P><U>FileInputStream</U> (<U>String</U> name)
			<P>Creates a FileInputStream by opening a connection to an actual file, the file named by the path name name in the file system.</TD>
		</TR>
		</TABLE> 
		<P>
		<table BORDER=1 CELLPADDING=2 WIDTH="550">
		<TD WIDTH=100%>
			<P>DataInputStream클래스의 생성자 요약 </TD>
		</tr>
		<TR>
			<TD WIDTH=100%>
			<P><U>DataInputStream</U> (<U>InputStream</U> in)
			<P>          Creates a FilterInputStream and saves its argument, the input stream in, for later use.</TD>
		</tr>
		</TABLE>
		<P>앞의 FileInputStrem클래스의 경우 3개의 생성자가 있는데, 첫 번째와 두 번째 생성자에서 파일을 접근할 수 있으므로 노드스트림임을 알 수 있다. 그러나 DataInputStream클래스의 생성자는 필터스트림임을 쉽게 알 수 있다. 생성자의 인자로 노드스트림인 InputStream클래스의 객체가 사용되었는데, 이렇게 필터스트림의 생성인자로 올 수 있는 것은 노드스트림이나 또 다른 필터스트림 만이 가능하고, 파일 같은 스트림은 지정할 수 없다.
	    </ul></td>
    </tr>
	</table>
</body>
</html>