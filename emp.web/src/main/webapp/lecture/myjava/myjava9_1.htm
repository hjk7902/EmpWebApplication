<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">9.1</P></td>
        <td width="518">
        <p class="TitleTitle">TCP 네트워크 프로그램</td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>
		<P>&nbsp;TCP 통신은 가장 많이 이용하는 통신 방식으로 &quot;양방향의 스트림 통신을 제공하는, 신뢰성 있는 연결 지향형 통신방식&quot;을 말하며, 양방향은 &quot;클라이언트와 서버가 동시에 존재해야만 통신이 이루어짐&quot;을 의미하고, 신뢰성은 &quot;양단에서 데이터를 주고받을 때 데이터의 손실없이 정확히 주고받을 수 있음&quot;을 의미한다. 연결 지향형은 &quot;클라이언트와 서버가 상호 연결되야 비로소 통신이 이루어짐&quot;을 나타내는 말이다.<P>TCP 통신을 이해하기 위한 예로, 전화연결이 있다. 누군가에게 전화를 걸려면 상대가 있어야 하고(양방향이 존재), 상대방이 전화를 받아야 말을 한다(연결이 되면 정보교환이 이루어짐). 그리고 상대방의 말을 잘 못 들었을 때, 다시 말하라고 요청하여 정확한 내용을 다시 듣고자 한다. 이런 면에서 TCP 통신은 전화통신과 매우 유사하다.
		<P>TCP/IP 소켓 연결은 java.net 패키지의 클래스를 사용하여 구현한다.
		<P>다음 그림은 서버와 클라이언트에서 어떤 일이 일어나는 지를 보여주는 예이다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV326.GIF" BORDER=0 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
		<P>앞의 그림에서 서버는 java.net 패키지의 ServerSocket클래스를 이용하여 포트 번호를 할당한다. 클라이언트가 소켓객체를 생성하여 연결을 요청하면 서버는 accept() 메소드를 사용하여 소켓을 열어주고, 클라이언트는 서버주소의 포트번호로 연결한다.
		<P>서버와 클라이언트의 프로세스가 정보를 교환할 때 스트림모델을 사용하는데, 이 때 소켓에는 두 개의 스트림 즉, 입력스트림(InputStream)과 출력스트림(OutputStream)이 들어 있다. 임의의 프로세스가 다른 프로세스에게 데이터를 보내려면 소켓과 연관된 출력스트림에 기록하면 된다. 상대측 프로세서가 데이터를 읽을 때도 소켓과 연관된 입력 스트림을 읽기만하면 된다.
		</ul>
		<P class="TSubmenu">9.1.1 TCP 서버
		<ul>
		<P>TCP/IP 서버 응용 프로그램은 ServerSocket과 Socket 네트워크 클래스를 이용한다. ServerSocket클래스는 서버를 설정하는 일을 한다.
		<P>다음 프로그램은 통신에 필요한 서버의 역할을 작성한 예이다.
		<P>
		<table BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>SimpleServer.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:
			<p class="CNumber">24:
			<p class="CNumber">25:
			<p class="CNumber">26:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.net.*;
			<P class="CStep1">import java.io.*;
			<P class="CStep1">public class SimpleServer {
			<P class="CStep2">public static void main(String args[]) {
			<P class="CStep3"><B>ServerSocket serverSocket = null</B>;
			<P class="CStep3">try {
			<P class="CStep4"><B>serverSocket = new ServerSocket(5432)</B>;
			<P class="CStep3">} catch (IOException e) {
			<P class="CStep4">e.printStackTrace();
			<P class="CStep3">}
			<P class="CStep3">while (true) {
			<P class="CStep3">try {
			<P class="CStep4">System.out.println(&quot;클라이언트 대기중...&quot;);
			<P class="CStep5"><B>Socket newSocket = serverSocket.accept()</B>;
			<P class="CStep5">System.out.println(&quot;클라이언트 접속&quot;);
			<P class="CStep5">OutputStream os = <B>newSocket.getOutputStream()</B>;
			<P class="CStep5">DataOutputStream dos = 					new DataOutputStream(os);
			<P class="CStep5">dos.<B>writeUTF</B>(&quot;Hello Net World!&quot;);
			<P class="CStep5"><B>dos.close()</B>;
			<P class="CStep5"><B>newSocket.close()</B>;
			<P class="CStep4">} catch (IOException e) {
			<P class="CStep5">e.printStackTrace();
			<P class="CStep4">}
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>5 : 소켓을 선언한다(ServerSocket). 앞에서 언급했듯이 자바에서 통신을 하려면 소켓을 만들어야 하는데 이런 통식 방식을 소켓통신이라고 한다. 
		<P>13 : 소켓을 선언했는데 선언한 소켓의 이름이 다르다. 이렇게 서버에서 다른 두개의 소켓을 선언한 이유를 알아보기 위해 다음 그림을 참고로 설명하기로 한다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV327.GIF" BORDER=0 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
		<P>서버는 동시에 여러 클라이언트를 수용할 수 있어야 한다. 따라서 앞의 그림처럼 여러 클라이언트가 서버에 접속하고 이를 처리할 있도록 ServerSocket를 둔다. 이것은 일종의 Listener역할을 한다.(접수창구정도로 이해하면 된다.) 
		<P>  ① 부분 : ServerSocket은 클라이언트의 접속을 기다리고 있고 클라이언트는 ServerSocket으로 접속을 시도한다. 
		<P>  ② 부분 : ServerSocket과 클라이언트 Socket의 접속이 이루어지면, ServerSocket은 새로운 Socket을 생성해서 클라이언트의 요청을 그쪽으로 돌린다. 그리고 나서 ServerSocket은 다른 클라이언트의 요청을 기다린다. <P>이러한 방식을 이용하기 때문에 서버에서는 여러 클라이언트의 요청을 처리할 수 있는 것이다. 15번째 줄에서 ServerSocket을 만들고, ServerSocket생성자의 인자는 포트번호를 준다. 즉, &quot;서버가 5432번 포트를 열고 클라이언트의 접속을 기다린다.&quot;
		<P>11 : while 문이 무한 반복을 하는데, 이는 서버 프로그램을 계속 수행시키겠다는 의미이고, 
		<P>13 : serverSocket.accept()를 호출했는데, 클라이언트가 접속할 때까지 프로그램을 멈추겠다는 의도이다. 이렇게 프로그램을 잠시 멈추는 것을 block 혹은 blocking이라한다. 이때 서버는 클라이언트의 접속을 실제로 기다린다. 클라이언트가 접속하게 되면, 앞의 그림에서 설명한 것처럼 새로운 소켓이 생성되어 newSocket이라는 reference 변수에 저장된다. 
		<P>14 : 화면에 누군가가 접속했다는 내용을 출력하고, 
		<P>15 : 소켓의 OutputStream을 얻어낸다. 
		<P>16 : 필터스트림인 DataOutputStream을 생성하고, 
		<P>17 : DataOutpuStream의 writeUTF() 메소드를 호출해 &quot;Hello Net world!&quot;라는 문자열을 저장한다. 
		<P>이렇게 저장한 문자열은 다음그림의 경로를 따라 클라이언트로 전송된다. 
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV328.GIF" BORDER=0 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
		<P>18 : 서버는 클라이언트가 접속한 소켓을 일방적으로 끊는다.
		</ul>
		<P class="TSubmenu">9.1.2 TCP 클라이언트
		<ul>
		<P>클라이언트 프로그램은 위의 서버처럼 복잡하지 않다. 그리고 서버에 접속하면 문자열이 전송된다는 사실을 기억하고 프로그래밍 해야 한다. (이를 프로토콜이라고 하며 일종의 서버와 클라이언트간의 통신규약 즉, 약속을 말한다.)
		<P>다음 프로그램은 통신에 필요한 클라이언트의 역할을 작성한 예이다. 
		<P>
		<table BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>SimpleClient.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.net.*;
			<P class="CStep1">import java.io.*;
			<P class="CStep1">public class SimpleClient {
			<P class="CStep2">public static void main(String args[]) {
			<P class="CStep3">try {
			<P class="CStep4"><B>Socket newSocket = new Socket(&quot;127.0.0.1&quot;, 5432);</B>
			<P class="CStep4">InputStream is = <B>newSocket.getInputStream()</B>;
			<P class="CStep4">DataInputStream dis = new DataInputStream(is);
			<P class="CStep4">System.out.println(<B>dis.readUTF()</B>);
			<P class="CStep4">dis.close();
			<P class="CStep4"><B>newSocket.close();</B>
			<P class="CStep3">} catch (ConnectException connExc) {
			<P class="CStep4">System.err.println(&quot;서버연결 실패&quot;);
			<P class="CStep3">} catch (IOException e) {
			<P class="CStep4">e.printStackTrace();
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>6 : 클라이언트도 소켓을 생성해야하므로 Socket객체를 만들었다. 이때 생성자의 인자로 서버의 IP 주소와 포트번호를 주고있다. 127.0.0.1은 loopback 주소를 말하는데 자기 컴퓨터의 IP 주소를 가리킬 때 사용한다(이렇게 지정한 이유는 자기 컴퓨터에서 수행되기 때문이다.). 포트번호 5432를 기술한 이유는 서버에서 그 포트를 열어놓았기 때문이다. 만약 다른 포트로 접속하면 접속되지 않는다. 이 부분이 실행되면 바로 서버에 접속된다. 서버에 접속했기 때문에 접속과 동시에 서버는 &quot;Hello Net World&quot; 문자열을 클라이언트 소켓으로 보낸다. 즉, 접속하는 순간 서버는 문자열을 보내고 클라이언트는 이 문자열을 소켓에서 읽기만 하면 된다. 
		<P>7 : 소켓에서 InputStream을 얻고, DataInputStream을 통해 문자열을 읽는다.
		<P>9 : readUTF() 메소드를 통해 문자열을 읽어들여 화면에 출력한다.
		<P>앞의 예제 프로그램을 실행시키려면 도스상태로 나가서 서버용 프로그램을 실행시킨 다음 도스창을 열어 클라이언트를 실행하면 결과를 볼 수 있다.
		<P>
		<table BORDER=1 CELLPADDING=2 WIDTH=539>
			<TD WIDTH=100%>
			<p class="TStep1"> &gt; <B>java</B> SimpleServer</TD>
		</tr>
		</TABLE>
		<P>
		<table BORDER=1 CELLPADDING=2 WIDTH=539>
			<TD WIDTH=100%>
			<p class="TStep1"> &gt; <B>java</B> SimpleClient</TD>
		</tr>
		</TABLE>
		</ul></td>
    </tr>
	</table>
</body>
</html>