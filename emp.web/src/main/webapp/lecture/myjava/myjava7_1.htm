<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">

	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">7.1</P></td>
        <td width="518">
        <p class="TitleTitle">내부 클래스</p></td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>
		<P>&nbsp;클래스 내의 클래스로 JDK 1.1에서 포함되었으며 내포(nested) 클래스라고도 한다. 내부 클래스는 존재 위치에 따른 멤버클래스, 메소드 안의 이름이 있는 내부클래스, 메소드 안의 이름이 없는 내부클래스 3가지로 나뉘어진다.
		</ul>
		<P class="TSubmenu">7.1.1 멤버 클래스(Inner Class)
		<ul>
		<P>클래스의 멤버로 필드나 메소드가 아닌 클래스가 올 수 있는데, 이를 내부(Inner) 클래스라고 한다. 필드나 메소드처럼 public, private, protected, static, final 등의 접근 제한자가 올 수 있으며, 클래스 선언부를 주 클래스 안으로 옮겨 놓으면 된다. 내부클래스는 컴파일시 주 클래스 이름과 내부클래스 이름을 &quot;$&quot;　문자로 연결한 파일을 생성한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>InnerExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber"><B>10:</B>
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber"><B>18:</B>
			<p class="CNumber"><B>19:</B>
			<p class="CNumber"><B>20:</B>
			<p class="CNumber"><B>21:</B>
			<p class="CNumber"><B>22:</B>
			<p class="CNumber">23:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">import java.awt.event.*;
			<P class="CStep1">public class InnerExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">public InnerExample() {
			<P class="CStep3">f = new Frame(&quot;Inner 클래스&quot;);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.addWindowListener( <B>new MyWindowAdapter()</B> );
			<P class="CStep3">f.setSize(300, 200);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">InnerExample ie = new InnerExample();
			<P class="CStep3">ie.launchFrame();
			<P class="CStep2">}
			<P class="CStep3"><B>private class MyWindowAdapter extends WindowAdapter {</B>
			<P class="CStep3"><B>public void windowClosing(WindowEvent e) {</B>
			<P class="CStep4"><B>System.exit(0);</B>
			<P class="CStep3"><B>}</B>
			<P class="CStep2"><B>}</B>
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>앞의 프로그램을 컴파일하면 클래스인 InnerExample.class파일과 내부 클래스인 InnerExample $MyWindowAdapter.class파일이 생성된다.
		<P>Inner클래스는 static멤버를 가질 수 없으나, static으로 선언하면 Top-Level클래스가 되어 static멤버를 가질 수 있다.
		</ul>
		<P class="TSubmenu">7.1.2 지역 클래스
		<ul>
		<P>메소드나 해당 블록 내에서만 유효하다. 클래스의 영역 범위가 블록의 영역 범위와 같으므로 다른 접근제한자가 없다. 컴파일하면 주 클래스 이름과 블록번호, 그리고 내부 클래스 이름을　&quot;$&quot;　문자로 연결한 파일을 생성한다.
		<P>다음 프로그램은 메소드 내에서 이름을 부여하여 클래스를 정의한 것으로 컴파일 하면 Top-Level 클래스인 InnerLocalExample.class파일과 내부 클래스인 InnerLocalExample$1$MyWindowAdapter.class파일을 생성하는 예이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>InnerLocalExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber"><B>9:</B>
			<p class="CNumber"><B>10:</B>
			<p class="CNumber"><B>11:</B>
			<p class="CNumber"><B>12:</B>
			<p class="CNumber"><B>13:</B>
			<p class="CNumber"><B>14:</B>
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">import java.awt.event.*;
			<P class="CStep1">public class InnerLocalExample {
			<P class="CStep1">private Frame f;
			<P class="CStep1">public InnerLocalExample() {
			<P class="CStep2">f = new Frame(&quot;Local Class&quot;);
			<P class="CStep1">}
			<P class="CStep1">public void launchFrame() {
			<P class="CStep2"><B>class MyWindowAdapter extends WindowAdapter {</B>
			<P class="CStep3"><B>public void windowClosing(WindowEvent we){</B>
			<P class="CStep4"><B>System.exit(0);</B>
			<P class="CStep3"><B>}</B>
			<P class="CStep2"><B>}</B>
			<P class="CStep2">f.addWindowListener( <B>new MyWindowAdapter() </B>);
			<P class="CStep2">f.setSize(300, 200);
			<P class="CStep2">f.setVisible(true);
			<P class="CStep1">}
			<P class="CStep1">public static void main(String[] args) {
			<P class="CStep2">InnerLocalExample ile = new InnerLocalExample();
			<P class="CStep2">ile.launchFrame();
			<P class="CStep1">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">7.1.3 익명 클래스(Anonymous Class)
		<ul>
		<P>블록 내부에 존재하는 지역 클래스에서 이름을 생략한 것이다. 이름을 생략한 지역 클래스는 new 키워드로 클래스를 생성하는 부분에서 메소드를 구현한다. 주 클래스 이름에 지역 클래스의 번호를 &quot;$&quot; 문자로 연결한 파일을 생성한다.
		<P>다음 프로그램은 메소드 내에서 이름 없는 클래스를 정의한 것으로 컴파일하면 Anonymous Example.class파일과 AnonymousExample$1.class파일을 생성한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>AnonymousExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber"><B>9:</B>
			<p class="CNumber"><B>10:</B>
			<p class="CNumber"><B>11:</B>
			<p class="CNumber"><B>12:</B>
			<p class="CNumber"><B>13:</B>
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">import java.awt.event.*;
			<P class="CStep1">public class AnonymousExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">public AnonymousExample() {
			<P class="CStep3">f = new Frame(&quot;Anonymous Class&quot;);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.addWindowListener( <B>new WindowAdapter() {</B>
			<P class="CStep4"><B>public void windowClosing(WindowEvent we){</B>
			<P class="CStep5"><B>System.exit(0);</B>
			<P class="CStep4"><B>}</B>
			<P class="CStep3"><B>}</B> );
			<P class="CStep3">f.setSize(300, 200);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">AnonymousExample ae = new AnonymousExample();
			<P class="CStep3">ae.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">7.1.4 Inner 클래스의 사용
		<ul>
		<P>내부 클래스의 사용법을 익히기 위해 다음 프로그램을 살펴보기로 한다.
		<P>다음 프로그램은 testTheInner()메소드에서 Inner1 클래스를 참조하는 예이다. Inner1클래스와 testTheInner()메소드는 모두 Outer1이라는 동일한 클래스의 범위 안에 있다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Outer1.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:</TD>
			<TD WIDTH=92%>
			<P class="CStep1"><B>public class Outer1 {</B>
			<P class="CStep2">private int data;
			<P class="CStep2"><B>public class MyInner1 {</B>
			<P class="CStep3">public void doIt() {
			<P class="CStep4">data++;
			<P class="CStep4">System.out.println(&quot;Inner 클래스의 메소드 호출됨&quot;);
			<P class="CStep4">System.out.println(&quot;data : &quot; + data);
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep2">public void testTheInner() {
			<P class="CStep3"><B>MyInner1 in = new MyInner1();</B>
			<P class="CStep3"><B>in.doIt();</B>
			<P class="CStep1">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">Outer1 out = new Outer1();
			<P class="CStep3">out.testTheInner();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">Inner 클래스의 메소드 호출됨
			<P class="Result">data : 1</td>
		</tr>
		</table>
		<P>다음 프로그램은 내부클래스를 별도의 클래스에서 참조하는 예를 보인 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Outer2.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1"><B>public class Outer2 {</B>
			<P class="CStep2">private int data;
			<P class="CStep2"><B>public class MyInner2 {</B>
			<P class="CStep3">public void doIt() {
			<P class="CStep4">data++;
			<P class="CStep4">System.out.println(&quot;Inner 클래스의 메소드 호출됨&quot;);
			<P class="CStep4">System.out.println(&quot;data : &quot; + data);
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestInner2.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestInner2 {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3"><B>Outer2 out = new Outer2();</B>
			<P class="CStep3"><B>Outer2.MyInner2 in = out.new MyInner2();</B>
			<P class="CStep3">in.doIt();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">Inner 클래스의 메소드 호출됨
			<P class="Result">data : 1</td>
		</tr>
		</table>
		<P>앞의 예에서처럼 다른 클래스에서 내부 클래스를 참조하려면 외부클래스를 이용한다. 4번째와 5번째 줄은 다음과 같이 표현해도 된다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD VALIGN="middle" WIDTH=7%></td>
			<TD VALIGN="middle" WIDTH=92%>
			<P>Outer2.MyInner2 in = new Outer2().new MyInner2();</TD>
		</tr>
		</TABLE>
		</ul>
		<P class="TSubmenu">7.1.5 Inner 클래스의 변수참조
		<ul>
		<P>다음 프로그램은 내부클래스에서 변수를 참조하는 예를 보인 것이다. 내부클래스를 포함한 클래스의 멤버변수와 내부클래스의 멤버변수 이름이 같으면 어느 변수를 참조하는지를 구분해야 한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Outer3.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Outer3 {
			<P class="CStep2">private int data=10;
			<P class="CStep2">public class MyInner3 {
			<P class="CStep3">private int data=20;
			<P class="CStep3">public void doIt(int data) {
			<P class="CStep4">System.out.println( <B>data</B> );
			<P class="CStep4">System.out.println( <B>this.data</B> );
			<P class="CStep4">System.out.println( <B>Outer3.this.data</B> );
			<P class="CStep3">}
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TestInner3.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class TestInner3 {
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">Outer3.MyInner3 in = new Outer3().new MyInner3();
			<P class="CStep3">in.doIt(30);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242"><P class="RResult">실행 결과</td>
		</tr>
		</table>
		<table width="300" cellpadding="0" cellspacing="0">
		<tr>
			<td width="242">
			<P class="Result">30
			<P class="Result">20
			<P class="Result">10</td>
		</tr>
		</table>
		<P>다음 프로그램은 내부클래스가 메소드 안에 선언된 경우 변수 참조 예를 보인 예이다. 메소드 내에 클래스가 선언되면 지역클래스(Local class)라고 하는데, 지역클래스에서는 자신을 포함하는 메소드의 변수들 중에서 지역클래스 내부에 선언된 변수가 아니면 final변수를 제외한 어떤 변수도 참조할 수 없다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Outer4.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">9-1:
			<p class="CNumber">9-2:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public class Outer4 {
			<P class="CStep2"><B>private int data=10;</B>
			<P class="CStep2">public Object makeTheInner(<B>int localData</B>) {
			<P class="CStep3"><B>final int FINAL_LOCAL_DATA=20;</B>
			<P class="CStep3"><B>class MyInner4 {</B>
			<P class="CStep4">public String toString() {
			<P class="CStep5">return ( &quot;data=&quot; + data +
			<P class="CStep4">//&quot;\nlocalData=&quot; + localData + //Error
			<P class="CStep5">&quot;\nFINAL_LOCAL_DATA=&quot; + FINAL_LOCAL_DATA );
			<P class="CStep4">}
			<P class="CStep3">}
			<P class="CStep3">return new MyInner4();
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">Outer4 out = new Outer4();
			<P class="CStep3">Object in = out.makeTheInner(30);
			<P class="CStep3">System.out.println(in);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>내부클래스는 모든 접근제한 모드를 사용할 수 있으며, abstract로 선언하여 사용할 수도 있다. 또, static 멤버를 가질 수 없지만 static으로 선언하면 top-level 클래스가 되어 static 멤버를 가질 수 있다. 즉, static 멤버를 갖는 내부클래스를 선언하려면 그 내부클래스도 static으로 선언해야 한다.
		</ul></td>
    </tr>
	</table>
</body>
</html>