<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<table cellpadding="0" cellspacing="0" width="650">
    <tr>
		<td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">9.2</P></td>
        <td width="518">
            <p class="TitleTitle">UDP 네트워크 프로그램</td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>
		<P>&nbsp;TCP/IP가 연결 중심의 프로토콜이라면 UDP(User Datagram Protocol) 통신방식은 &quot;비 신뢰적, 비 연결지향형 통신&quot;이라고 할 수 있다. TCP 통신과는 달리 우편 엽서와 유사하다. TCP에서는 전화를 사용하는 것처럼 메시지를 순서대로 보내고 받을 수 있지만 UDP는 보낸 순서와 받는 순서가 다를 수 있다. 또 상대방의 주소가 잘못되면 데이터가 잘못 전달되거나 아예 데이터를 읽지 못할 수도 있다.<P>UDP는 DatagramSocket과 DatagramPacket이라는 두 개의 클래스를 지원한다. 패킷은 송신자의 정보와 메시지길이, 메시지 등으로 구성되는 독립적인 메시지 단위이다.
		</ul>
		<P class="TSubmenu">9.2.1 DatagramPacket
		<ul>
		<P>DatagramPacket에는 다음 네 가지의 생성자가 있는데, 2개는 데이터를 수신하는데 사용하고 나머지 2개는 데이터를 보내는데 사용된다.
		<P>▒ DatagramPacket(byte[] buf, int length)
		<P>   DatagramPacket(byte[] buf, int offset, int length) 
		<P>- UDP 패킷을 수신할 수 있도록 바이트 배열을 설정한다. 생성자로 사용되는 바이트 배열은 비워두고, 읽을 바이트의 크기를 설정한다. 이때 배열의 크기보다 작게 지정한다.
		<P>▒ DatagramPacket(byte[] buf, int length, InetAddress address, int port) 
		<P>   DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port) 
		<P>- 전송할 수 있도록 UDP 패킷을 설정하는 데 사용된다.
		</ul>
		<P class="TSubmenu">9.2.2 DatagramSocket
		<ul>
		<P>DatagramSocket은 UDP 패킷을 읽고 쓰는데 사용된다. 이 클래스에는 연결할 포트와 인터넷 주소를 지정하는데 사용하는 세 개의 생성자를 가지고있다.
		<P>▒ DatagramSocket() 
		<P>- 로컬 호스트에서 이용할 수 있는 포트로 연결한다.
		<P>▒ DatagramSocket(int port) 
		<P>- 로컬 호스트에서 지정된 포트로 연결한다.
		<P>▒ DatagramSocket(int port, InetAddress laddr) 
		<P>- 지정된 주소의 지정된 포트 번호로 연결한다.
		<P>다음 프로그램은 UDP방식을 이용하여 메신저 프로그램을 만든 예를 보인 것이다.
		<P>
		<table BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>Messenger.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">&nbsp;
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">&nbsp;
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:
			<p class="CNumber">24:
			<p class="CNumber">25:
			<p class="CNumber">26:
			<p class="CNumber">27:
			<p class="CNumber">28:
			<p class="CNumber">&nbsp;
			<p class="CNumber">29:
			<p class="CNumber">30:
			<p class="CNumber">31:
			<p class="CNumber">32:
			<p class="CNumber">33:
			<p class="CNumber">34:
			<p class="CNumber">35:
			<p class="CNumber">36:
			<p class="CNumber">37:
			<p class="CNumber">38:
			<p class="CNumber">39:
			<p class="CNumber">40:
			<p class="CNumber">41:
			<p class="CNumber">42:
			<p class="CNumber">43:
			<p class="CNumber">44:
			<p class="CNumber">45:
			<p class="CNumber">46:
			<p class="CNumber">47:
			<p class="CNumber">48:
			<p class="CNumber">49:
			<p class="CNumber">50:
			<p class="CNumber">51:
			<p class="CNumber">52:
			<p class="CNumber">53:
			<p class="CNumber">54:
			<p class="CNumber">55:
			<p class="CNumber">56:
			<p class="CNumber">57:
			<p class="CNumber">58:
			<p class="CNumber">59:
			<p class="CNumber">60:
			<p class="CNumber">61:
			<p class="CNumber">62:
			<p class="CNumber">63:
			<p class="CNumber">64:
			<p class="CNumber">&nbsp;
			<p class="CNumber">65:
			<p class="CNumber">&nbsp;
			<p class="CNumber">66:
			<p class="CNumber">67:
			<p class="CNumber">68:
			<p class="CNumber">69:
			<p class="CNumber">70:
			<p class="CNumber">71:
			<p class="CNumber">72:
			<p class="CNumber">73:
			<p class="CNumber">74:
			<p class="CNumber">75:
			<p class="CNumber">76:
			<p class="CNumber">77:
			<p class="CNumber">78:
			<p class="CNumber">79:
			<p class="CNumber">80:
			<p class="CNumber">81:
			<p class="CNumber">82:
			<p class="CNumber">83:
			<p class="CNumber">84:
			<p class="CNumber">85:
			<p class="CNumber">&nbsp;
			<p class="CNumber">86:
			<p class="CNumber">87:
			<p class="CNumber">&nbsp;
			<p class="CNumber">88:
			<p class="CNumber">89:
			<p class="CNumber">90:
			<p class="CNumber">91:
	</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*; 
			<P class="CStep1">import java.awt.event.*; 
			<P class="CStep1">import java.io.*; 
			<P class="CStep1">import java.net.*; 
			<P class="CStep1">public class Messenger implements Runnable, ActionListener
			<P class="CStep1">{ 
			<P class="CStep2">private Frame f; 
			<P class="CStep2">private TextArea outputArea;
			<P class="CStep2">private TextField addressField, inputField;
			<P class="CStep2">private DatagramSocket server, client; 
			<P class="CStep2">private DatagramPacket sinData, soutData; 
			<P class="CStep2">private byte[] data = new byte[500]; 
			<P class="CStep2">public Messenger() { 
			<P class="CStep3">try { 
			<P class="CStep4">server = new DatagramSocket(8000); 
			<P class="CStep4">client = new DatagramSocket(7000,
			<P class="CStep4">InetAddress.getLocalHost());
			<P class="CStep3">}catch(IOException e) { 
			<P class="CStep4">e.printStackTrace(); 
			<P class="CStep3">} 
			<P class="CStep2">} //end of constructor
			<P class="CStep2">public static void main(String[] args) { 
			<P class="CStep3">Messenger m = new Messenger(); 
			<P class="CStep3">m.go(); 
			<P class="CStep3">Thread t = new Thread(m); 
			<P class="CStep3">t.start(); 
			<P class="CStep2">} //end of main
			<P class="CStep2">public void go() { 
			<P class="CStep3">try { 
			<P class="CStep4">f = new Frame(InetAddress.getLocalHost().
			<P class="CStep4">getHostAddress()); 
			<P class="CStep3">}catch(UnknownHostException e) { 
			<P class="CStep4">e.printStackTrace();
			<P class="CStep2">}
			<P class="CStep2">f.addWindowListener(new WindowAdapter() { 
			<P class="CStep3">public void windowClosing(WindowEvent e) { 
			<P class="CStep4">System.exit(0); 
			<P class="CStep3">} 
			<P class="CStep2">}); 
			<P class="CStep2">outputArea = new TextArea(); 
			<P class="CStep2">outputArea.setEditable(false);
			<P class="CStep2">addressField = new TextField();
			<P class="CStep2">inputField = new TextField();
			<P class="CStep2">inputField.addActionListener(this); 
			<P class="CStep2">Panel p1 = new Panel();
			<P class="CStep2">p1.setLayout(new BorderLayout());
			<P class="CStep2">p1.add(new Label(&quot;Address&quot;), BorderLayout.WEST);
			<P class="CStep2">p1.add(addressField, BorderLayout.CENTER);
			<P class="CStep2">Panel p2 = new Panel();
			<P class="CStep2">p2.setLayout(new BorderLayout());
			<P class="CStep2">p2.add(new Label(&quot;Message&quot;), BorderLayout.WEST);
			<P class="CStep2">p2.add(inputField, BorderLayout.CENTER);
			<P class="CStep2">f.add(p1, BorderLayout.NORTH);
			<P class="CStep2">f.add(outputArea, BorderLayout.CENTER);
			<P class="CStep2">f.add(p2, BorderLayout.SOUTH);
			<P class="CStep2">f.setSize(300,200); 
			<P class="CStep2">f.setVisible(true); 
			<P class="CStep1">} //end of go
			<P class="CStep2">public void actionPerformed(ActionEvent e) { 
			<P class="CStep3">String mssg = inputField.getText(); 
			<P class="CStep3">String ip = addressField.getText();
			<P class="CStep3">outputArea.append(&quot;&gt;&gt; &quot; + mssg+&quot;\n&quot;); 
			<P class="CStep3">InetAddress inet = null; 
			<P class="CStep3">soutData = null; 
			<P class="CStep3">try {
			<P class="CStep3">inet = InetAddress.getByName(ip);
			<P class="CStep3">soutData = new DatagramPacket(mssg.getBytes(),
			<P class="CStep3">mssg.getBytes().length,
			<P class="CStep3">inet, 8000); 
			<P class="CStep3">client.send(soutData); 
			<P class="CStep2">} catch(Exception ex) { 
			<P class="CStep3">ex.printStackTrace(); 
			<P class="CStep3">} 
			<P class="CStep2">inputField.setText(&quot;&quot;); 
			<P class="CStep2">if(ip==null) { 
			<P class="CStep3">try { 
			<P class="CStep4">ip = InetAddress.getLocalHost().getHostName(); 
			<P class="CStep3">}catch(UnknownHostException ex) { 
			<P class="CStep4">ex.printStackTrace(); 
			<P class="CStep4">} 
			<P class="CStep3">} 
			<P class="CStep1">} //end of actionPerformed
			<P class="CStep2">public void run() { 
			<P class="CStep2">while(true) { 
			<P class="CStep3">sinData = new DatagramPacket(data, data.length); 
			<P class="CStep3">try { 
			<P class="CStep4">System.out.println(&quot;8000번 포트로 대기중...&quot;); 
			<P class="CStep4">server.receive(sinData); 
			<P class="CStep3">}catch(IOException e) { 
			<P class="CStep4">e.printStackTrace(); 
			<P class="CStep3">} 
			<P class="CStep3">String addr = sinData.getAddress().getHostName(); 
			<P class="CStep3">String rsvData = new String(sinData.getData(), 0,
			<P class="CStep3">sinData.getLength()); 
			<P class="CStep3">outputArea.append(&quot;[&quot; + addr + &quot;]&quot; + rsvData + &quot;\n&quot;); 
			<P class="CStep2">} //end of while
			<P class="CStep1">} //end of run
			<P class="CStep1">} //end of class</TD>
		</tr>
		</TABLE>
		</ul></td>
    </tr>
</table>
</body>
</html>