<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="java.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
	<table cellpadding="0" cellspacing="0" width="650">
    <tr>
        <td width="76" bgcolor="#CCCCCC">
		<P class="TitleNumber" align="center">4.1</P></td>
        <td width="518">
        <p class="TitleTitle"> AWT 컴포넌트</td>
    </tr>
	</table>
	<table class="frame" border="0" cellpadding="0" cellspacing="2" width="650">
    <tr>
        <td width="1101">
		<ul>
		<P>&nbsp;AWT(Abstract Window Toolkit)는 GUI와 관련된 클래스의 묶음인데, GUI와 관련된 모든 클래스를 말하지는 않지만 최근 많이 사용하는 스윙(SWING)도 여기에 포함된다. 즉, AWT는 기본적인 GUI와 관련된 클래스의 묶음을 말한다. 자바 AWT의 기본 구성요소는 컴포넌트와 컨테이너이다. 컴포넌트는 일반적으로 GUI에서 버튼(Button)이나 레이블(Label), 또는 텍스트 필드(TextField)와 같이 보여지도록 나타나는 부분이며, 컴포넌트는 컨테이너에 포함되어 화면에 출력된다. 일반적으로 컨테이너에는 하나 이상의 컴포넌트를 포함할 수 있으며, 컴포넌트뿐만 아니라 다른 컨테이너도 포함 가능하다.
		<P>다음의 예를 보며 이해하기로 한다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>SampleWindow.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
		<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class SampleWindow {
			<P class="CStep2">private Frame f;
			<P class="CStep2">public SampleWindow() {
			<P class="CStep3">f = new Frame(&quot;자바 윈도우&quot;);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setSize(300, 200);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}	
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">SampleWindow sw = new SampleWindow();
			<P class="CStep3">sw.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">1:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;</TD>
		</tr>
		</TABLE>
		<P>AWT와 관련된 클래스를 사용하기 위해 java.awt 패키지를 import.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">private Frame f;</TD>
		</tr>
		</TABLE>
		<P>Frame클래스의 객체변수를 선언.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">7:
			<P class="CNumber">8:
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public SampleWindow() {
			<P class="CStep2">f = new Frame(&quot;자바 윈도우&quot;);
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>생성자를 만들고 그 안에 Frame클래스의 객체를 생성한다. 여기서 윈도우를 만들면서 Window클래스를 사용하지 않고 Frame클래스를 사용한 것은 Window클래스는 경계선과 타이틀 바를 갖지 않는 네모난 창에 불과하지만, Frame클래스는 Window클래스의 하위 클래스로서 프레임과 타이틀 바를 갖는 윈도우를 생성하기 때문이다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public void launchFrame() {
			<P class="CStep2">f.setSize(300, 200);
			<P class="CStep2">f.setVisible(true);
			<P class="CStep1">}	</TD>
		</tr>
		</TABLE>
		<P>객체 생성과 관련된 부분은 생성자를 이용하고 이 메소드에서는 그 이외의 부분을 기술하였다. 
		<P>12 : setSize() 메소드는 컴포넌트 객체의 크기를 픽셀단위로 지정한다. 여기서는 프레임의 크기를 가로 300픽셀, 세로 200픽셀로 설정하였다. 
		<P>13 : setVisible() 메소드는 주어진 논리형 변수 값이 false면 화면에 나타나지 않고, true면 나타난다. 만약 이 줄이 없으면 실행은 되지만 화면에는 아무것도 나타나지 않는다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">16:
			<P class="CNumber">17:
			<P class="CNumber">18:
			<P class="CNumber">19:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">public static void main (String[] args) {
			<P class="CStep2">SampleWindow sw = new SampleWindow();
			<P class="CStep2">sw.launchFrame();
			<P class="CStep2">}</TD>
		</tr>
		</TABLE>
		<P>main() 메소드의 선언부로 개체생성 후 launchFrame() 메소드를 호출하여 화면에 윈도우를 출력시킨다.
		<P>여기서 launchFrame() 메소드 안의 내용이 생성자 안에 기술돼도 실행에는 지장이 없지만, 생성자 안에서 객체 생성 이외의 작업을 진행하도록 프로그래밍 하는 방법은 권장할만한 기법은 아니다.
		<P>다음은 앞의 프로그램을 실행시켰을 때 나타나는 화면이다. 물론 이벤트를 다루지 않았기 때문에 윈도우의 종료버튼을 눌러도 프로그램이 종료되지 않는다.(강제로 프로그램을 종료시키기 위해서는 Ctrl+C를 누른다.)
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV154.GIF" BORDER=0 WIDTH=306 HEIGHT=204 HSPACE=3 VSPACE=3 ALIGN=BOTTOM>
		<P>다음은 자바 컴포넌트 계층 구조를 나타낸 것이다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV155.GIF" BORDER=0 WIDTH=487 HEIGHT=263 HSPACE=3 ALIGN=BOTTOM>
		<P>이상의 모든 컴포넌트는 컴포넌트클래스에서 상속받는다. 특성에 따라 컴포넌트를 분류하면 다음과 같이 3가지로 분류할 수 있다.
		<P>▒ 기본 컴포넌트 : Button, Label, Checkbox, Choice, List, Scrollbar, Canvas
		<P>▒ 텍스트 컴포넌트 :  TextField, TextArea
		<P>▒ 컨테이너 컴포넌트 : Panel, Applet, Window, Frame, Dialog, FileDialog
		<P>컴포넌트 클래스가 제공하는 주요 메소드를 살펴보면 다음과 같다.
		<P>  &middot; Rectangle getBounds() : 컴포넌트의 테두리(바운드) 정보를 얻는다.
		<P>  &middot; Rectangle getBounds(Rectangle r) : 컴포넌트의 바운드 정보를 주어진 Rectangle 객체 r에 저장하고 이 객체를 반환한다.
		<P>  &middot; int getX() : 컴포넌트의 x 축 시작좌표 값을 얻는다.
		<P>  &middot; int getY() : 컴포넌트의 y축 시작좌표 값을 얻는다.
		<P>  &middot; Point getLocation() : 컴포넌트의 현재 위치 좌표를 얻는다.
		<P>  &middot; Point getLocation(Point p) : 컴포넌트의 현재 위치 좌표를 주어진 Point객체 p에 저장하고 이 객체를 반환한다.
		<P>  &middot; Point getLocationOnScreen() : 컴포넌트의 화면상에서의 현재 좌표위치를 얻는다.
		<P>  &middot; int getWidth() : 컴포너트의 가로(폭)값을 얻는다.
		<P>  &middot; int getHeight() : 컴포넌트의 세로(높이)값을 얻는다.
		<P>  &middot; Dimension getSize() : 컴포넌트의 크기를 얻는다.
		<P>  &middot; Dimension getSize(Dimension d) : 컴포넌트의 크기를 얻어 Dimension객체 d에 저장하고 이 객체를 반환한다.
		<P>  &middot; void setLocation(int x, int y) : 컴포넌트를 새로운 위치로 옮긴다.
		<P>  &middot; void setLocation(Point p) : 컴포넌트를 새로운 위치로 옮긴다.
		<P>  &middot; void setSize(Dimension d) : 컴포넌트의 폭과 높이를 각각 d.width와 d.height로 설정한다.
		<P>  &middot; void setSize(int width, int height) : 컴포넌트의 폭과 높이를 각각 width와 height로 설정한다.
		<P>  &middot; void setBounds(int x, int y, int width, int height) : 컴포넌트를 주어진 위치로 옮기고 크기를 변경한다.
		<P>  &middot; void setBounds(Rectangle r) : 컴포넌트를 주어진 위치로 옮기고 크기를 변경한다.
		<P>  &middot; void setName(String name) : 컴포넌트의 이름을 설정한다.
		<P>  &middot; Dimension getMaximumSize() : 컴포넌트의 최대 크기를 얻는다.
		<P>  &middot; Dimension getMinimumSize() : 컴포넌트의 최소 크기를 얻는다.
		<P>  &middot; Dimension getPreferredSize() : 컴포넌트의 적당한 크기를 얻는다.
		<P>  &middot; Component getComponentAt(int x, int y) : 주어진 좌표를 포함하고 있는 컴포넌트를 얻는다.
		<P>  &middot; Component getComponentAt(Point p) : 주어진 좌표를 포함하고 있는 컴포넌트를 얻는다.
		<P>  &middot; boolean contains(int x, int y) : 주어진 위치 좌표를 포함하고 있는 컴포넌트가 있는지의 여부를 얻는다.
		<P>  &middot; boolean contains(Point p) : 주어진 위치 좌표를 포함하고 있는 컴포넌트가 있는지의 여부를 얻는다.
		<P>  &middot; boolean isDisplayable() : 이 컴포넌트가 디스플레이 가능한 지를 얻는다.
		<P>  &middot; boolean isShowing() : 이 컴포넌트가 보여지고 있는지를 얻는다.
		<P>  &middot; boolean isValid() : 이 컴포넌트가 유효한지를 얻는다.
		<P>  &middot; boolean isVisible() : 컴포넌트가 보여질 수 있는지를 얻는다.
		<P>  &middot; void setVisible(boolean b) : 컴포넌트를 보이거나 보이지 않게 설정한다.
		<P>  &middot; void invalidate() : 컴포넌트를 무효화한다.
		<P>  &middot; void validate() : 이 컴포넌트가 유효한 레이아웃을 갖도록 만든다.
		</ul>
		<P class="TSubmenu">4.1.1 기본 컴포넌트
		<ul>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=433>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>컴포넌트 이름</TD>
			<TD WIDTH=62%>
			<P ALIGN=CENTER>컴포넌트 기능</TD>
		</tr>
		<TR>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>Button</TD>
			<TD WIDTH=62%>
			<P ALIGN=CENTER>버튼 생성</TD>
		</tr>
		<TR>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>Label</TD>
			<TD WIDTH=62%>
			<P ALIGN=CENTER>고정된 문자열 표시</TD>
		</tr>
		<TR>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>Checkbox</TD>
			<TD WIDTH=62%>
			<P ALIGN=CENTER>체크박스나 라디오 박스 생성</TD>
		</tr>
		<TR>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>Choice</TD>
			<TD WIDTH=62%>
			<P ALIGN=CENTER>드롭다운 메뉴 생성</TD>
		</tr>
		<TR>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>List</TD>
			<TD WIDTH=62%>
			<P ALIGN=CENTER>리스트 생성</TD>
		</tr>
		<TR>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>Scrollbar</TD>
			<TD WIDTH=62%>
			<P ALIGN=CENTER>스크롤바 생성</TD>
		</tr>
		<TR>
			<TD WIDTH=37%>
			<P ALIGN=CENTER>Canvas</TD>
			<TD WIDTH=62%>
			<P ALIGN=CENTER>그래픽객체를 그릴 때 사용</TD>
		</tr>
		</TABLE>
		<P>4.1.1.1 Button
		<P>java.awt.Button 컴포넌트 클래스는 사용자가 버튼을 누를 때 취해야할 동작할  생성하는 간단한 제어다. 버튼컴포넌트도 클래스객체를 생성한 후에 반드시 add() 메소드를 사용하여 컨테이너에 추가해야 한다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV156.GIF" BORDER=0 WIDTH=306 HEIGHT=102 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 예제는 앞의 설명을 실행하는 Button컴포넌트 프로그램이다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ButtonExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<P class="CNumber">>1:
			<P class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:
			<p class="CNumber">24:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class ButtonExample {
			<P class="CStep2">private Frame f;
			<P class="CStep3">private Button b1, b2;
			<P class="CStep3">public ButtonExample(){
			<P class="CStep4">f = new Frame(&quot;Button Example&quot;);
			<P class="CStep4">b1 = new Button(&quot;버튼 1&quot;);
			<P class="CStep4">b2 = new Button(&quot;버튼 2&quot;);
			<P class="CStep3">}
			<P class="CStep3">public void launchFrame() {
			<P class="CStep4">f.setLayout(new FlowLayout());
			<P class="CStep3">b1.setBackground(Color.yellow);
			<P class="CStep3">b1.setForeground(Color.blue);
			<P class="CStep3">b2.setEnabled(false);
			<P class="CStep3">f.add(b1);
			<P class="CStep3">f.add(b2);
			<P class="CStep3">f.setSize(300, 100);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">ButtonExample be = new ButtonExample();
			<P class="CStep3">be.launchFrame();
			<P class="CStep3">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">private Button b1, b2;</TD>
		</tr>
		</TABLE>
		<P>버튼객체를 선언.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">10:
			<P class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">b1 = new Button(&quot;버튼 1&quot;);
			<P class="CStep1">b2 = new Button(&quot;버튼 2&quot;);</TD>
		</tr>
		</TABLE>
		<P>생성자 내에서 레이블을 가진 버튼과 그렇지 않은 버튼 객체를 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.setLayout(new FlowLayout());</TD>
		</tr>
		</TABLE>
		<P>레이아웃 관리자를 FlowLayout으로 지정한 것이다. 레이아웃 관리자는 컴포넌트의 배치를 다루는 것으로 자세한 내용은 다음 장에서 설명하기로 한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">18:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">b2.setEnabled(false);</TD>
		</tr>
		</TABLE>
		<P>setEnabled() 인자값을 false로 지정하면 입력에 반응하지 않는 비 활성 상태가 된다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">17:
			<P class="CNumber">18:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(myButton);
			<P class="CStep1">f.add(yourButton);</TD>
		</tr>
		</TABLE>
		<P>두 개의 버튼객체를 add() 메소드를 사용하여 컨테이너에 추가한다.
		<P>Button 클래스가 제공하는 객체 생성자와 주요 메소드를 살펴보면 다음과 같다.
		<P> ▒ 생성자
		<P>  &middot; public Button() : 레이블 없는 버튼을 생성한다.
		<P>  &middot; public Button(String label) : 주어진 레이블의 버튼을 생성한다.
		<P>▒ 메소드
		<P>  &middot; public String getLabel() : 버튼의 레이블을 얻는다.
		<P>  &middot; public void setLabel(String label) : 버튼의 레이블을 주어진 문자열로 설정한다.
		<P>4.1.1.2 Label
		<P>java.awt.Label 컴포넌트 클래스는 원하는 문장을 입력하는데 사용한다. 사용법은 레이블 객체를 생성한 후 add() 메소드를 이용하여 컨테이너에 추가시킨다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV157.GIF" BORDER=0 WIDTH=306 HEIGHT=102 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 예는 Label컴포넌트를 이용하는 방법을 기술한 프로그램이다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>LabelExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class LabelExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private Label myLabel;
			<P class="CStep2">public LabelExample(){
			<P class="CStep3">f = new Frame(&quot;Label Example&quot;);
			<P class="CStep3">myLabel = new Label(&quot;Hello World!&quot;, Label.RIGHT);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">myLabel.setBackground(Color.yellow);
			<P class="CStep3">myLabel.setForeground(Color.blue);
			<P class="CStep3">f.add(myLabel, BorderLayout.SOUTH);
			<P class="CStep3">f.setSize(300, 100);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">LabelExample le = new LabelExample();
			<P class="CStep3">le.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">private Label myLabel;</TD>
		</tr>
		</TABLE>
		<P>레이블 객체를 선언.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myLabel = new Label(&quot;Hello World!&quot;, Label.RIGHT);</TD>
		</tr>
		</TABLE>
		<P>&quot;Hello World!&quot; 문자열을 오른쪽 정렬방식을 가진 레이블 객체로 생성.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">14:
			<P class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myLabel.setBackground(Color.red);
			<P class="CStep1">myLabel.setForeground(Color.blue);</TD>
		</tr>
		</TABLE>
		<P>레이블의 색상을 지정하는 부분으로 setBackground() 메소드는 배경색(여기서는 레이블의 배경색)을, setForeground() 메소드는 전경색(여기서는 글자의 색)을 설정할 수 있다. 
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">16:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(myLabel, BorderLayout.SOUTH);</TD>
		</tr>
		</TABLE>
		<P>객체 myLabel을 add() 메소드를 이용하여 컨테이너 아래쪽에 추가시킨다.
		<P>Label 클래스가 제공하는 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 속성
		<P>  &middot; static int CENTER : 가운데 정렬
		<P>  &middot; static int LEFT : 왼쪽 정렬
		<P>  &middot; static int RIGHT : 오른쪽 정렬
		<P>▒ 생성자
		<P>  &middot; Label() : 레이블을 생성한다.
		<P>  &middot; Label(String text) : 주어진 이름의 레이블을 생성하고, 기본적으로 왼쪽 정렬 상태를 갖는다.
		<P>  &middot; Label(String text, int alignment) : 주어진 이름의 레이블을 생성하고, 주어진 정렬방식으로 정렬한다. 정렬값은 Label.LEFT, Label.CENTER, Label.RIGHT가 있다.
		<P>▒ 메소드
		<P>  &middot; int getAlignment() : 현재 정렬 방식을 얻는다.
		<P>  &middot; void setAlignment(int alignment) : 정렬 방식을 설정한다.
		<P>  &middot; String getText() : 레이블의 텍스트를 얻는다.
		<P>  &middot; void setText(String text) : 레이블의 텍스트를 주어진 텍스트로 설정한다.
		<P>4.1.1.3 Checkbox
		<P>java.awt.Checkbox는 다양한 옵션을 선택하는데 사용된다. &quot;on&quot; 또는 &quot;off&quot; 두가지 중 한가지 상태를 나타낸다. 체크박스를 누르면 설정상태가 변하며 처리할 동작이 일어난다. 이와 비슷하게 항목을 선택할 수 있는 컴포넌트에는 Choice, List, Menu 컴포넌트 등이 있다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV158.GIF" BORDER=0 WIDTH=357 HEIGHT=102 HSPACE=3 ALIGN=BOTTOM>
		<P>앞의 그램에서 처럼 체크박스에는 두 종류가 있는데 먼저, 위 줄에 있는 세 개의 체크박스는 서로 독립적으로 선택될 수 있어, 동시에 모두 선택할 수도 있고, 하나도 선택하지 않을 수도 있다. 
		<P>아래 세 개의 체크박스는 그룹으로 관리되므로 그룹에 속한 체크박스 중 하나만 선택된다. 
		<P>이들 두 그룹의 체크박스는 외형상으로도 차이가 있는데, 위 줄의 체크박스는 일반적인 체크박스 형태인 반면 아래 줄의 체크박스들은 라디오 버튼의 형태를 갖고있다.
		<P>여러 개의 체크박스 중 하나만 선택하려면 체크박스그룹(CheckboxGroup) 객체에 추가해준다. 
		<P>다음 예제는 앞에서 설명한 두 가지 형태의 체크박스에 대한 프로그램이다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>CheckboxExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:
			<p class="CNumber">24:
			<p class="CNumber">25:
			<p class="CNumber">26:
			<p class="CNumber">27:
			<p class="CNumber">28:
			<p class="CNumber">29:
			<p class="CNumber">30:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class CheckboxExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private Checkbox check1, check2, check3;
			<P class="CStep2">private Checkbox radio1, radio2, radio3;
			<P class="CStep2">private CheckboxGroup group1;
			<P class="CStep2">public CheckboxExample() {
			<P class="CStep3">f = new Frame(&quot;Checkbox Example&quot;);
			<P class="CStep3">check1 = new Checkbox(&quot;Checkbox 1&quot;);
			<P class="CStep3">check2 = new Checkbox(&quot;Checkbox 2&quot;, true);
			<P class="CStep3">check3 = new Checkbox(&quot;Checkbox 3&quot;);
			<P class="CStep3">group1 = new CheckboxGroup();
			<P class="CStep3">radio1 = new Checkbox(&quot;Checkbox 4&quot;, group1, false);
			<P class="CStep3">radio2 = new Checkbox(&quot;Checkbox 5&quot;, group1, false);
			<P class="CStep3">radio3 = new Checkbox(&quot;Checkbox 6&quot;, group1, true);
			<P class="CStep1">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setLayout(new FlowLayout());
			<P class="CStep3">check3.setState(true);
			<P class="CStep3">f.add(check1);  f.add(check2);  f.add(check3);
			<P class="CStep3">f.add(radio1);  f.add(radio2);  f.add(radio3);
			<P class="CStep3">f.setSize(350, 100);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep3">}
			<P class="CStep3">public static void main(String[] args) {
			<P class="CStep4">CheckboxExample ce = new CheckboxExample();
			<P class="CStep4">ce.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:
			<P class="CNumber">6:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">	private Checkbox check1, check2, check3;
			<P class="CStep1">	private Checkbox radio1, radio2, radio3;</TD>
		</tr>
		</TABLE>
		<P>Checkbox 클래스로부터 객체 선언.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">private CheckboxGroup group1</TD>
		</tr>
		</TABLE>
		<P>라디오버튼을 만들기 위해 체크박스 그룹객체를 선언.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">check1 = new Checkbox(&quot;Checkbox 1&quot;);
			<P class="CStep1">check2 = new Checkbox(&quot;Checkbox 2&quot;, true);
			<P class="CStep1">check3 = new Checkbox(&quot;Checkbox 3&quot;);</TD>
		</tr>
		</TABLE>
		<P>11 : 체크박스에 이름 부여. 
		<P>12 : 체크박스 이름을 부여하면서 초기 선택값으로 true를 주어 미리 선택이 되도록 한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">14:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">group1 = new CheckboxGroup();</TD>
		</tr>
		</TABLE>
		<P>라디오버튼을 만들기 위해 7번째 줄에서 선언된 체크박스 그룹객체를 생성.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">15:
			<P class="CNumber">16:
			<P class="CNumber">17:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">radio1 = new Checkbox(&quot;Checkbox 4&quot;, group1, false);
			<P class="CStep1">radio2 = new Checkbox(&quot;Checkbox 5&quot;, group1, false);
			<P class="CStep1">radio3 = new Checkbox(&quot;Checkbox 6&quot;, group1, true);</TD>
		</tr>
		</TABLE>
		<P>라디오버튼을 만들기 위해 체크박스를 그룹화하여 객체를 생성.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">22:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">check3.setState(true);</TD>
		</tr>
		</TABLE>
		<P>setState() 메소드에 인자값으로 true를 주어 체크박스를 선택상태로 설정. 선택 해제를 하려면 인자값으로 false를 지정한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">23:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(check1);  f.add(check2);  f.add(check3);</TD>
		</tr>
		</TABLE>
		<P>체크박스 객체를 add() 메소드를 이용하여 컨테이너에 추가시킨다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">24:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(radio1);  f.add(radio2);  f.add(radio3);</TD>
		</tr>
		</TABLE>
		<P>체크박스 객체를 add() 메소드를 이용하여 컨테이너에 추가시킨다.
		<P>Checkbox 클래스가 제공하는 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 생성자
		<P>  &middot; Checkbox() : 레이블이 없는 체크박스를 생성한다.
		<P>  &middot; Checkbox(String label) : 주어진 레이블의 체크박스를 생성한다.
		<P>  &middot; Checkbox(String label, boolean state) : 주어진 레이블의 체크박스를 생성하며, 체크박스의 초기 선택 여부를 설정한다.
		<P>  &middot; Checkbox(String label, boolean state, CheckboxGroup group) : 주어진 레이블의 체크박스를 생성하며, 체크박스의 초기 선택 여부를 설정하고, 체크박스 그룹을 설정한다.
		<P>  &middot; Checkbox(String label, CheckboxGroup group, boolean state) : 주어진 레이블의 체크박스를 생성하며, 체크박스의 초기 선택 여부를 설정하고, 체크박스 그룹을 설정한다.
		<P>▒ 메소드
		<P>   &middot; String getLabel() : 체크박스의 레이블을 구한다.
		<P>   &middot; void setLabel(String label) : 체크박스의 레이블을 설정한다.
		<P>   &middot; boolean getState() : 체크박스의 상태가 &quot;on&quot; 또는 &quot;off&quot; 상태인지를 얻는다.
		<P>   &middot; void setState(boolean state) : 체크박스의 상태를 설정한다.(true이면 &quot;on&quot;)
		<P>   &middot; CheckboxGroup getCheckboxGroup() : 설정된 체크박스 그룹을 얻는다.
		<P>   &middot; void setCheckboxGroup(CheckboxGroup g) : 체크박스 그룹을 설정한다.
		<P>CheckboxGroup 클래스가 제공하는 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 생성자
		<P>  &middot; CheckboxGroup() : 체크박스 그룹 객체를 생성한다.
		<P>▒ 메소드
		<P>  &middot; Checkbox getSelectedCheckbox() : 체크박스 그룹 중에서 현재 선택된 체크박스를 얻는다.
		<P>  &middot; void setCurrent(Checkbox box) : setSelectedCheckbox(Checkbox)으로 바뀌었다.
		<P>  &middot; void setSelectedCheckbox(Checkbox box) : 현재 주어진 체크박스가 선택되도록 설정한다.
		<P>4.1.1.4 Choice
		<P>java.awt.Choice 컴포넌트 클래스는 다음 그림과 같이 드롭다운(drop-down) 리스트를 제공해주는 컴포넌트이다. 이 컴포넌트는 제한된 공간에 많은 내용을 나타낼 때 유용하다. 
		<P ALIGN=CENTER>  
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV159.GIF" BORDER=0 WIDTH=204 HEIGHT=204 HSPACE=3 ALIGN=BOTTOM>
		<IMG SRC="images/FYXIV160.GIF" BORDER=0 WIDTH=204 HEIGHT=204 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 프로그램은 Choice 컴포넌트를 사용하는 예를 보인 것이다.  
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ChoiceExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:
			<p class="CNumber">24:
			<p class="CNumber">25:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class ChoiceExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private Choice myChoice;
			<P class="CStep2">public ChoiceExample(){
			<P class="CStep3">f = new Frame(&quot;Choice Example&quot;);
			<P class="CStep3">myChoice = new Choice();
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setLayout(new FlowLayout());
			<P class="CStep3">myChoice.add(&quot;Windows 95/98&quot;);
			<P class="CStep3">myChoice.add(&quot;Windows NT&quot;);
			<P class="CStep3">myChoice.add(&quot;Windows 2000&quot;);
			<P class="CStep3">myChoice.add(&quot;Solaris&quot;);
			<P class="CStep3">myChoice.add(&quot;OS/2&quot;);
			<P class="CStep3">myChoice.add(&quot;Mac&quot;);
			<P class="CStep3">f.add(myChoice);
			<P class="CStep3">f.setSize(200, 200);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">ChoiceExample ce = new ChoiceExample();
			<P class="CStep3">ce.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myChoice = new Choice();</TD>
		</tr>
		</TABLE>
		<P>6번째 줄에서 선언된 Choice 객체를 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myChoice.add(&quot;Windows 95/98&quot;);</TD>
		</tr>
		</TABLE>
		<P>15번째 줄에서 20번째 줄까지는 메뉴 항목을 Choice 컴포넌트에 추가한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">21:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(myChoice);</TD>
		</tr>
		</TABLE>
		<P>생성된 레이블 객체를 add() 메소드를 이용하여 컨테이너에 추가한다.
		<P>Choice 클래스의 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 생성자
		<P>  &middot; Choice() : 선택 메뉴를 생성한다.
		<P>▒ 메소드
		<P>  &middot; void add(String item) : 아이템을 추가한다.
		<P>  &middot; void addItem(String item) : 아이템을 추가한다. JDK1.2버전에서 자주 보던 것이다. Choice클래스에서는 사용되지만 대부분의 클래스에서는 사용하지 않고 있다.
		<P>  &middot; int getItemCount() : 아이템의 개수를 얻는다.
		<P>  &middot; String getItem(int index) : 주어진 인덱스에 해당하는 아이템을 얻는다.
		<P>  &middot; int getSelectedIndex() : 선택된 아이템의 인덱스를 얻는다.
		<P>  &middot; String getSelectedItem() : 선택된 아이템의 이름을 얻는다.
		<P>  &middot; void insert(String item, int index) : 주어진 이름의 아이템을 주어진 인덱스에 추가한다.
		<P>  &middot; void remove(int position) : 주어진 위치의 아이템을 제거한다.
		<P>  &middot; void remove(String item) : 주어진 이름의 아이템을 제거한다.
		<P>  &middot; void removeAll() : 선택 메뉴에 있는 모든 아이템을 제거한다.
		<P>  &middot; void select(int pos) : 주어진 위치의 아이템이 선택되도록 한다.
		<P>  &middot; void select(String str) : 주어진 이름의 아이템이 선택되도록 한다.
		<P>4.1.1.5 List
		<P>java.awt.List 컴포넌트 클래스는 다수의 선택항목이 리스트에 나타나고 사용자가 이를 선택하고자 할 때 사용한다. 원하는 아이템을 클릭하여 선택하고 더블 클릭하거나 리턴하여 액션 이벤트를 발생시킬 수 있다. List 컴포넌트는 동시에 여러 개를 선택할 수도 있고 하나의 아이템만 선택할 수도 있다.
		<P ALIGN=CENTER>  
		<IMG SRC="images/FYXIV161.GIF" BORDER=0 WIDTH=306 HEIGHT=102 HSPACE=3 ALIGN=BOTTOM>
		<P>앞의 예에서 왼쪽리스트는 동시에 여러 개의 아이템을 선택할 수 있고, 오른쪽리스트는 하나의 아이템만 선택할 수 있는 것이다.
		<P>다음 프로그램은 List컴포넌트를 사용하는 예를 보인 것이다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ListExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
		<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:
			<p class="CNumber">24:
			<p class="CNumber">25:
			<p class="CNumber">26:
			<p class="CNumber">27:
			<p class="CNumber">28:
			<p class="CNumber">29:
			<p class="CNumber">30:
			<p class="CNumber">31:
			<p class="CNumber">32:
			<p class="CNumber">33:
			<p class="CNumber">34:
			<p class="CNumber">35:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class ListExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private List myList, yourList;
			<P class="CStep2">public ListExample(){
			<P class="CStep3">f = new Frame(&quot;List Example&quot;);
			<P class="CStep3">myList = new List(3, true);
			<P class="CStep3">yourList = new List();
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setLayout(new FlowLayout());
			<P class="CStep3">myList.add(&quot;Windows 95/98&quot;);
			<P class="CStep3">myList.add(&quot;Windows NT&quot;);
			<P class="CStep3">myList.add(&quot;Windows 2000&quot;);
			<P class="CStep3">myList.add(&quot;Solaris&quot;);
			<P class="CStep3">myList.add(&quot;OS/2&quot;);
			<P class="CStep3">myList.add(&quot;Machintosh&quot;);
			<P class="CStep3">myList.add(&quot;MS-DOS&quot;);
			<P class="CStep3">yourList.add(&quot;Windows 95/98&quot;);
			<P class="CStep3">yourList.add(&quot;Windows NT&quot;);
			<P class="CStep3">yourList.add(&quot;Windows 2000&quot;);
			<P class="CStep3">yourList.add(&quot;Solaris&quot;);
			<P class="CStep3">yourList.add(&quot;OS/2&quot;);
			<P class="CStep3">yourList.add(&quot;Machintosh&quot;);
			<P class="CStep3">yourList.add(&quot;MS-DOS&quot;);
			<P class="CStep3">f.add(myList);
			<P class="CStep3">f.add(yourList);
			<P class="CStep3">f.setSize(300, 100);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main (String[] args) {
			<P class="CStep3">ListExample le = new ListExample();
			<P class="CStep3">le.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">9:
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myList = new List(3, true);
			<P class="CStep1">yourList = new List();</TD>
		</tr>
		</TABLE>
		<P>9 : 리스트 아이템이 3줄씩 보이게 하면서 여러 개의 아이템을 동시에 선택 가능(true)하게 하는 객체를 지정한다.
		<P>10 : 스크롤 가능한 리스트 컴포넌트를 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myList.add(&quot;Windows 95/98&quot;);</TD>
		</tr>
		</TABLE>
		<P>15번째 줄에서 29번째 줄까지는 주어진 이름의 아이템을 각각 해당 리스트에 추가한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber">31:
			<p class="CNumber">32:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(myList);
			<P class="CStep1">f.add(yourList);</TD>
		</tr>
		</TABLE>
		<P>생성된 레이블 객체를 add() 메소드를 사용하여 컨테이너에 추가한다.
		<P>List 클래스가 제공하는 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 생성자
		<P>  &middot; List() : 스크롤 가능한 리스트 컴포넌트를 생성한다. 기본값으로 4개 줄이 설정된다.
		<P>  &middot; List(int rows) : 주어진 개수만큼의 줄을 보이는 스크롤 가능한 리스트 컴포넌트를 생성한다.
		<P>  &middot; List(int rows, boolean multipleMode) : 주어진 개수만큼의 줄을 보이게 하는 스크롤 가능한 리스트 컴포넌트를 생성하면서, 다수의 아이템을 동시에 선택가능하게 할것인지의 여부를 설정한다.
		<P>▒ 메소드
		<P>  &middot; void add(String item) : 주어진 이름의 아이템을 추가한다.
		<P>  &middot; void add(String item, int index) : 주어진 이름의 아이템을 해당 인덱스에 추가한다.
		<P>  &middot; void deselect(int index) : 주어진 인덱스의 아이템을 선택 해제한다.
		<P>  &middot; String getItem(int index) : 주어진 인덱스의 아이템을 얻는다.
		<P>  &middot; int getItemCount() : 리스트 내의 아이템 개수를 얻는다.
		<P>  &middot; String[] getItems() : 리스트 내의 아이템 배열을 얻는다.
		<P>  &middot; int getRows() : 리스트에서 보이는 아이템의 개수를 얻는다.
		<P>  &middot; int getSelectedIndex() : 선택된 아이템의 개수를 얻는다.
		<P>  &middot; int[] getSelectedIndexes() : 선택된 아이템의 인덱스 배열을 얻는다.
		<P>  &middot; String getSelectedItem() : 선택된 아이템의 배열을 얻는다.
		<P>  &middot; String[] getSelectedItems() : 선택된 아이템의 배열을 얻는다.
		<P>  &middot; Object[] getSelectedObjects() : 선택된 아이템을 Object 객체 배열로 얻는다.
		<P>  &middot; int getVisibleIndex() : makeVisible() 메소드에 의해 마지막으로 보여진 아이템의 인덱스를 얻는다.
		<P>  &middot; boolean isIndexSelected(int index) : 인덱스에 해당하는 아이템이 선택되었는지 여부를 얻는다.
		<P>  &middot; boolean isMultipleMode() : 여러 개의 아이템이 선택가능한지 여부를 얻는다.
		<P>  &middot; void makeVisible(int index) : 주어진 인덱스에 해당하는 아이템을 보이게 한다.
		<P>  &middot; void remove(int position) : 주어진 위치의 아이템을 제거한다.
		<P>  &middot; void remove(String item) : 주어진 이름의 아이템을 제거한다.
		<P>  &middot; void removeAll() : 모든 아이템을 제거한다.
		<P>  &middot; void replaceItem(String newValue, int index) : 주어진 인덱스에 해당하는 아이템을 새로운 이름으로 변경한다.
		<P>  &middot; void select(int index) : 인덱스에 해당하는 아이템을 선택한다.
		<P>  &middot; void setMultipleMode(boolean b) : 여러 개의 아이템을 선택 가능하도록 설정한다.
		<P>   
		<P>4.1.1.6 Scrollbar
		<P>java.awt.Scrollbar 컴포넌트 클래스는 연속적인 값을 선택하거나, 다른 컴포넌트의 옆에 붙어서 수평, 수직 스크롤바와 같이 실제 보여지는 영역을 지정하는 역할을 한다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV162.GIF" BORDER=0 WIDTH=306 HEIGHT=102 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 프로그램은 Scrollbar컴포넌트를 사용하는 예를 보인것이다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>ScrollbarExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">&nbsp;
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class ScrollbarExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private Scrollbar mySlider;
			<P class="CStep2">public ScrollbarExample() {
			<P class="CStep3">f = new Frame(&quot;Scrollbar Example&quot;);
			<P class="CStep3">mySlider = new Scrollbar(Scrollbar.HORIZONTAL,
			<P class="CStep3">100,20,0,255);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.add(mySlider);
			<P class="CStep3">f.setSize(300, 100);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">ScrollbarExample se = new ScrollbarExample();
			<P class="CStep3">se.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">mySlider = new Scrollbar(Scrollbar.
			<P class="CStep1">HORIZONTAL,100,20,0,255);</TD>
		</tr>
		</TABLE>
		<P>최소값 0, 최대값 255, 초기값 100, 스크롤바 포인터(bubble)의 크기가 20픽셀인 수평 스크롤 바를 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">13:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(mySlider);</TD>
		</tr>
		</TABLE>
		<P>생성된 객체를 add() 메소드를 이용하여 컨테이너에 추가시킨다.
		<P>Scrollbar 클래스가 제공하는 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 속성
		<P>  &middot; static int HORIZONTAL : 수평 스크롤바를 나타낸다.
		<P>  &middot; static int VERTICAL : 수직 스크롤바를 나타낸다.
		<P>▒ 생성자
		<P>  &middot; Scrollbar() : 스크롤바를 생성한다.
		<P>  &middot; Scrollbar(int orientation) : 주어진 값에 따라 수평.수직 스클롤바를 생성한다.
		<P>  &middot; Scrollbar(int orientation, int value, int visible, int minimum, int maximum) : 주어진 스크롤바의 속성값에 해당하는 스크롤바를 생성한다. 각 값은 다음과 같은 의미를 갖는다.
		<P>- int orientation : 스크롤바가 수평이면 Scrollbar.HORIZONTAL으로, 스클롤바가 수직이면 Scrollbar.VERTICAL으로 설정해준다.
		<P>- int value : 스크롤바의 초기값을 나타낸다. 일반적인 초기값은 0이다.
		<P>- int visible : 스크롤 가능한 영역의 보이는 부분에 대한 픽셀 단위의 크기를 나타낸다. 
		<P>- int minimum : 스크롤바가 가질 수 있는 최소값을 나타낸다. 스크롤 영역을 설정하기 위한 스크롤바의 경우에는 0이 된다.
		<P>- int maximum : 스크롤바가 가질 수 있는 최대값을 나타낸다. 스크롤 영역을 설정하기 위한 스크롤바의 경우 픽셀 단위의 width 또는 height 값이 된다.
		<P>▒ 메소드
		<P>  &middot; int getBlockIncrement() : 스크롤바의 블록 증가량을 얻는다.
		<P>  &middot; int getMaximum() : 스크롤바의 최대값을 얻는다.
		<P>  &middot; int getMinimum() : 스크롤바의 최소값을 얻는다.
		<P>  &middot; int getOrientation() : 스클롤바의 방향성 값을 얻는다.
		<P>  &middot; int getUnitIncrement() : 스크롤바의 단위 증가량을 얻는다.
		<P>  &middot; int getValue() : 스크롤바의 현재 값을 얻는다.
		<P>  &middot; int getVisibleAmount() : 스크롤바의 보이는 부분의 양을 얻는다.
		<P>  &middot; void setBlockIncrement(int v) : 스크롤바의 블록 증가량을 설정한다.
		<P>  &middot; void setMaximum(int newMaximum) : 스크롤바의 최대값을 설정한다.
		<P>  &middot; void setMinimum(int newMinimum) : 스크롤바의 최소값을 설정한다.
		<P>  &middot; void setOrientation(int orientation) : 스크롤바의 방향성을 설정한다.
		<P>  &middot; void setUnitIncrement(int v) : 스크롤바의 단위 증가량을 설정한다.
		<P>  &middot; void setValue(int newValue) : 스크롤바의 현재 값을 설정한다.
		<P>  &middot; void setValues(int value, int visible, int minimum, int maximum) : 스크롤바의 속성 값을 설정한다.
		<P>  &middot; void setVisibleAmount(int newAmount) : 스크롤바의 보이는 부분의 양을 설정한다.
		<P>4.1.1.7 Canvas
		<P>java.awt.Canvas 컴포넌트 클래스는 특정한 모습이 없으며, 그림을 그리는 등 영상처리 작업을 하는데 유용한 컴포넌트이다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV163.GIF" BORDER=0 WIDTH=306 HEIGHT=102 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 프로그램은 Canvas컴포넌트의 사용 예를 보인 것이다.  
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>CanvasExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class CanvasExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private Canvas myCanvas;
			<P class="CStep2">public CanvasExample() {
			<P class="CStep3">f = new Frame(&quot;Canvas Example&quot;);
			<P class="CStep3">myCanvas = new Canvas();
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setLayout(new FlowLayout());
			<P class="CStep3">myCanvas.setBackground(Color.red);
			<P class="CStep3">myCanvas.setSize(100, 50);
			<P class="CStep3">f.add(myCanvas);
			<P class="CStep3">f.setSize(300, 100);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">CanvasExample ce = new CanvasExample();
			<P class="CStep3">ce.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myCanvas = new Canvas();</TD>
		</tr>
		</TABLE>
		<P>캔버스 컴포넌트를 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">14:
			<P class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myCanvas.setBackground(Color.red);
			<P class="CStep1">myCanvas.setSize(100, 50);</TD>
		</tr>
		</TABLE>
		<P>캔버스의 배경을 빨간색으로 지정하고, 크기를 가로 100픽셀, 세로 50픽셀로 지정한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">17:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(myCanvas);</TD>
		</tr>
		</TABLE>
		<P>생성된 레이블 객체를 add() 메소드를 사용하여 컨테이너에 추가한다.
		<ul>
		<P class="TSubmenu">4.1.2 텍스트 컴포넌트
		</ul>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=380>
			<TD WIDTH=40%>
			<P ALIGN=CENTER>컴포넌트 이름</TD>
			<TD WIDTH=59%>
			<P ALIGN=CENTER>컴포넌트 기능</TD>
		</tr>
		<TR>
			<TD WIDTH=40%>
			<P ALIGN=CENTER>TextField</TD>
			<TD WIDTH=59%>
			<P ALIGN=CENTER>한 줄 문자입력</TD>
		</tr>
		<TR>
			<TD WIDTH=40%>
			<P ALIGN=CENTER>TextArea</TD>
			<TD WIDTH=59%>
			<P ALIGN=CENTER>여러 줄 문자입력</TD>
		</tr>
		</TABLE>
		<P>TextComponent 클래스가 제공하는 주요 메소드는 다음과 같다.
		<P>  &middot; int getCaretPosition() : 텍스트 삽입 캐럿(I자 형태)의 위치를 얻는다.
		<P>  &middot; String getSelectedText() : 선택 영역의 텍스트를 얻는다.
		<P>  &middot; int getSelectionEnd() : 선택된 텍스트의 끝 위치를 얻는다.
		<P>  &middot; int getSelectionStart() : 선택된 텍스트의 시작 위치를 얻는다.
		<P>  &middot; String getText() : 현재의 텍스트를 얻는다.
		<P>  &middot; boolean isEditable() : 편집 가능한 상태인지를 얻는다.
		<P>  &middot; void select(int selectionStart, int selectionEnd) : 시작 위치부터 끝 위치까지 선택한다.
		<P>  &middot; void selectAll() : 모든 텍스트를 선택한다.
		<P>  &middot; void setCaretPosition(int position) : 삽입 위치(캐럿)를 설정한다.
		<P>  &middot; void setEditable(boolean b) : 편집 상태를 설정한다.
		<P>  &middot; void setSelectionEnd(int selectionEnd) : 선택 영역의 끝 위치를 설정한다.
		<P>  &middot; void setSelectionStart(int selectionStart) : 선택 영역의 시작 위치를 설정한다.
		<P>  &middot; void setText(String t) : 현재 텍스트를 설정한다.
		<P>4.1.2.1 TextField
		<P>java.awt.TextField 컴포넌트 클래스는 한 줄 내에서 사용자의 문자 입력을 받는다. java.awt.TextComponent가 이 클래스의 상위 클래스이며, TextComponent 클래스는 텍스트 입력과 관련된 메소드를 처리해 주는 기능을 가지고 있다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV164.GIF" BORDER=0 WIDTH=306 HEIGHT=102 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 프로그램은 TextField컴포넌트를 사용하는 예를 보인 것이다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TextFieldExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class TextFieldExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private TextField myTextField;
			<P class="CStep2">public TextFieldExample() {
			<P class="CStep3">f = new Frame(&quot;TextField Example&quot;);
			<P class="CStep3">myTextField = new TextField(&quot;Hello!&quot;, 25);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setLayout(new FlowLayout());
			<P class="CStep3">f.add(myTextField);
			<P class="CStep3">f.setSize(300, 100);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">TextFieldExample te = new TextFieldExample();
			<P class="CStep3">te.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myTextField = new TextField(&quot;Hello!&quot;, 25);</TD>
		</tr>
		</TABLE>
		<P>TextField 클래스로부터 새로운 텍스트 필드 컴포넌트를 생성한다. 숫자 25는 텍스트 필드의 폭이 25열임을 나타낸다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">14:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(myTextField);</TD>
		</tr>
		</TABLE>
		<P>생성된 객체를 add() 메소드를 사용하여 컨테이너에 추가시킨다.
		<P>TextField 클래스의 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 생성자
		<P>  &middot; TextField() : 텍스트 필드를 생성한다.
		<P>  &middot; TextField(int columns) : 주어진 열의 크기(개수)를 갖는 텍스트 필드를 생성한다.
		<P>  &middot; TextField(String text) : 주어진 텍스트를 갖는 텍스트 필드를 생성한다.
		<P>  &middot; TextField(String text, int columns) : 주어진 텍스트와 열의 크기(개수)를 갖는 텍스트 필드를 생성한다. 
		<P>▒ 메소드
		<P>  &middot; boolean echoCharIsSet() : 에코 문자가 설정되어 있는지 여부를 얻는다. 패스워드를 입력받을 때 이 컴포넌트를 이용한다. 패스워드 대신 화면상에 나타날 문자를 에코 문자라고 한다.
		<P>  &middot; int getColumns() : 열의 크기(개수)를 얻는다.
		<P>  &middot; char getEchoChar() : 에코 문자를 얻는다.
		<P>  &middot; void setColumns(int columns) : 텍스트 필드의 크기인 열의 크기(개수)를 설정한다.
		<P>  &middot; void setEchoChar(char c) : 에코 문자를 설정한다.
		<P>  &middot; void setText(String t) : 텍스트를 설정한다.
		<P> 
		<P>4.1.2.2 TextArea
		<P>java.awt.TextArea 컴포넌트 클래스는 여러줄의 문자입력을 받을 때 사용한다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV165.GIF" BORDER=0 WIDTH=306 HEIGHT=153 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 프로그램은 TextArea컴포넌트를 사용하는 예를 보인것이다. 
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TextAreaExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">&nbsp;
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class TextAreaExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private TextArea myTextArea;
			<P class="CStep2">public TextAreaExample() {
			<P class="CStep3">f = new Frame(&quot;TextArea Example&quot;);
			<P class="CStep3">myTextArea = new TextArea(&quot;안녕하세요.\n
			<P class="CStep3">반갑습니다.&quot;, 5, 25);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setLayout(new FlowLayout());
			<P class="CStep3">f.add(myTextArea);
			<P class="CStep3">f.setSize(300, 150);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">TextAreaExample te = new TextAreaExample();
			<P class="CStep3">te.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myTextArea = new TextArea(&quot;안녕하세요.\n반갑습니다.&quot;, 5, 25);</TD>
		</tr>
		</TABLE>
		<P>TextArea 클래스로부터 새로운 텍스트영역 컴포넌트를 생성한다. 숫자 5와 25는 각각 5행 25열을 의미하며, &quot;\n&quot;은 개행기능(return)을 의미한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">14:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.add(myTextArea);</TD>
		</tr>
		</TABLE>
		<P>생성된 객체를 add() 메소드를 이용하여 컨테이너에 추가시킨다.
		<P>TextArea 클래스의 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 속성
		<P>  &middot; static int SCROLLBARS_BOTH : 수직.수평 스크롤바를 생성하고 보여준다.
		<P>  &middot; static int SCROLLBARS_HORIZONTAL_ONLY : 수평 스크롤바를 생성하고 보여준다.
		<P>  &middot; static int SCROLLBARS_VERTICAL_ONLY : 수직 스크롤바를 생성하고 보여준다
		<P>  &middot; static int SCROLLBARS_NONE : 스크롤바를 생성하지 않는다. 
		<P>   
		<P>▒ 생성자
		<P>  &middot; TextArea() : 텍스트영역을 생성한다.
		<P>  &middot; TextArea(int rows, int columns) : 주어진 행과 열을 갖는 텍스트 영역을 생성한다.
		<P>  &middot; TextArea(String text) : 주어진 텍스트를 갖는 텍스트 영역을 생성한다.
		<P>  &middot; TextArea(String text, int rows, int columns) : 주어진 행, 열, 텍스트를 갖는 텍스트영역을 생성한다.
		<P>  &middot; TextArea(String text, int rows, int columns, int scrollbars) : 주어진 행, 열, 텍스트, 그리고 스크롤바를 갖는 텍스트 영역을 생성한다.
		<P>   
		<P>▒ 메소드
		<P>  &middot; void append(String str) : 문자열을 텍스트 영역에 추가한다.
		<P>  &middot; int getColumns() : 열의 크기(개수)를 얻는다.
		<P>  &middot; int getRows() : 행의 크기(개수)를 얻는다.
		<P>  &middot; void insert(String str, int pos) : 주어진 위치(라인)에 문자열을 삽입한다.
		<P>  &middot; void replaceRange(String str, int start, int end) : 시작 위치부터 끝 위치 사이의 문자열을 주어진 문자열로 대체한다.
		<P>  &middot; void setColumns(int columns) : 열의 크기(개수)를 설정한다.
		<P>  &middot; void setRows(int rows) : 행의 크기(개수)를 설정한다. 
		</ul>
		<P class="TSubmenu">4.1.3 컨테이너 컴포넌트
		<ul>
		<P>컨테이너(Container) 컴포넌트는 자신의 영역 안에 다른 컴포넌트를 포함할 수 있으며, 혼자서는 특별한 동작을 할 수 없고 다른 컴포넌트를 포함할 때만 의미가 있다. 컨테이너 클래스도 컴포넌트 클래스의 하위 클래스이기 때문에 그 자체도 컴포넌트로 취급되며, 다른 컨테이너 내에 포함될 수 있다.
		<P>컴포넌트는 컨테이너에 포함되지 않으면 독자적으로 화면에 나타낼 수가 없다. 컨테이너에 컴포넌트를 포함시키기 위해서는 컨테이너 클래스의 add() 메소드를 이용한다. 
		<P>컨테이너 컴포넌트의 종류와 기능은 다음과 같다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=496>
			<TD WIDTH=32%>
			<P ALIGN=CENTER>컴포넌트 이름</TD>
			<TD WIDTH=67%>
			<P ALIGN=CENTER>컴포넌트 기능</TD>
		</tr>
		<TR>
			<TD WIDTH=32%>
			<P ALIGN=CENTER>Panel</TD>
			<TD WIDTH=67%>
			<P ALIGN=CENTER>컴포넌트 배치</TD>
		</tr>
		<TR>
			<TD WIDTH=32%>
			<P ALIGN=CENTER>Applet</TD>
			<TD WIDTH=67%>
			<P ALIGN=CENTER>애플릿 생성</TD>
		</tr>
		<TR>
			<TD WIDTH=32%>
			<P ALIGN=CENTER>Window</TD>
			<TD WIDTH=67%>
			<P ALIGN=CENTER>윈도우 생성(경계선과 타이틀바가 없음)</TD>
		</tr>
		<TR>
			<TD WIDTH=32%>
			<P ALIGN=CENTER>Frame</TD>
			<TD WIDTH=67%>
			<P ALIGN=CENTER>경계선과 타이틀바를 갖는 윈도우 생성</TD>
		</tr>
		<TR>
			<TD WIDTH=32%>
			<P ALIGN=CENTER>Dialog</TD>
			<TD WIDTH=67%>
			<P ALIGN=CENTER>대화상자 생성</TD>
		</tr>
		<TR>
			<TD WIDTH=32%>
			<P ALIGN=CENTER>FileDialog</TD>
			<TD WIDTH=67%>
			<P ALIGN=CENTER>파일 대화상자 생성</TD>
		</tr>
		</TABLE>
		<P>컨테이너 클래스가 제공하는 주요 메소드는 다음과 같다.
		<P>  &middot; public Component add(Component comp) : 주어진 컴포넌트를 컴포넌트의 끝에 추가한다. 
		<P>  &middot; public void setLayout(LayoutManager mgr) : 레이아웃 관리자를 설정한다.
		<P>4.1.3.1 Panel
		<P>java.awt.Panel 컨테이너 클래스는 컨테이너의 하위 클래스로서 독립적인 모양이 없고 독립적인 창으로 사용할 수는 없지만 주요용도를 보면 다른 컴포넌트를 포함하거나 배치시키는데 사용한다. 또, 패널이 포함하고 있는 컴포넌트에 대한 이벤트를 처리할 수 있는 특별한 기능을 가지고 있다.
		<P>다음 프로그램은 서로 다른 Panel객체를 이용하여 버튼 컴포넌트를 배치시키는 예를 나타낸 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>PanelExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:
			<p class="CNumber">24:
			<p class="CNumber">25:
			<p class="CNumber">26:
			<p class="CNumber">27:
			<p class="CNumber">28:
			<p class="CNumber">29:
			<p class="CNumber">30:
			<p class="CNumber">31:
			<p class="CNumber">32:
			<p class="CNumber">33:
			<p class="CNumber">34:
			<p class="CNumber">35:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep2">public class PanelExample {
			<P class="CStep3">private Frame f;
			<P class="CStep3">private Panel p1, p2;
			<P class="CStep3">private Button b1, b2, b3, b4, b5, b6;
			<P class="CStep3">public PanelExample() {
			<P class="CStep4">f = new Frame(&quot;Panel Example&quot;);
			<P class="CStep4">p1 = new Panel();
			<P class="CStep4">p2 = new Panel();
			<P class="CStep4">b1 = new Button(&quot;Button 1&quot;);
			<P class="CStep4">b2 = new Button(&quot;Button 2&quot;);
			<P class="CStep4">b3 = new Button(&quot;Button 3&quot;);
			<P class="CStep4">b4 = new Button(&quot;Button 4&quot;);
			<P class="CStep4">b5 = new Button(&quot;Button 5&quot;);
			<P class="CStep4">b6 = new Button(&quot;Button 6&quot;);
			<P class="CStep3">}
			<P class="CStep3">public void launchFrame() {
			<P class="CStep4">p1.setBackground(Color.yellow);
			<P class="CStep4">p1.add(b1);
			<P class="CStep4">p1.add(b2);
			<P class="CStep4">p1.add(b3);
			<P class="CStep4">p2.setBackground(Color.red);
			<P class="CStep4">p2.add(b4));
			<P class="CStep4">p2.add(b5));
			<P class="CStep4">p2.add(b6));
			<P class="CStep4">f.add(p1, BorderLayout.EAST);
			<P class="CStep4">f.add(p2, BorderLayout.CENTER);
			<P class="CStep4">f.setSize(300, 150);
			<P class="CStep4">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">PanelExample pe = new PanelExample();
			<P class="CStep3">pe.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<p>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">Panel p1, p2;</TD>
		</tr>
		</TABLE>
		<P>Panel 클래스로부터 새로운 패널 객체 2개(p1, p2)를 정의한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber">10:
			<p class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">p1 = new Panel();
			<P class="CStep1">p2 = new Panel();</TD>
		</tr>
		</TABLE>
		<P>5번째 줄에서 정의된 패널 객체 p1과 p2를 생성자를 이용하여 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">21:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">p1.setBackground(Color.yellow);</TD>
		</tr>
		</TABLE>
		<P>패널 객체 p1의 바탕색을 노란색으로 지정한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">22:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">p1.add(b1);</TD>
		</tr>
		</TABLE>
		<P>버튼 객체를 add() 메소드를 이용하여 패널 객체 p1에 부착시킨다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=9%>
			<P class="CNumber">31:</TD>
			<TD WIDTH=90%>
			<P class="CStep1">f.add(p1, BorderLayout.EAST);</TD>
		</tr>
		</TABLE>
		<P>패널객체 p1을 프레임에 추가한다. add() 메소드의 인자값 중에서 BorderLayout.EAST는 BorderLayout클래스에서 객체를 오른쪽에 배치하라는 뜻이다. 레이아웃 관리자에 대해서는 다음 장에서 설명하기로 한다.
		<P>다음은 앞의 프로그램을 실행한 결과 화면이다. 패널을 이용하면 컴포넌트의 배치를 좀 더 쉽고 다양하게 할 수 있다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV166.GIF" BORDER=0 WIDTH=306 HEIGHT=153 HSPACE=3 ALIGN=BOTTOM>
		<P>4.1.3.2 Applet
		<P>java.awt.Applet 컨테이너 클래스는 Panel클래스의 하위 클래스로 애플릿 프로그램을 만드는데 사용한다. 애플릿이란 웹 브라우저에서 실행되는 자바 프로그램으로 자세한 내용은 6장에서 설명하기로 한다.
		<P>4.1.3.3 Window
		<P>java.awt.Window 컨테이너 클래스는 윈도우가 가져야 할 기본적인 기능을 제공하는 클래스로서, Dialog 와 Frame 클래스를 하위 클래스로 갖고, 경계선과 타이틀 바가 없는 윈도우를 생성한다. Window 클래스를 상속받아 하위클래스를 정의하면 독립된 윈도우로 동작할 수 있다. 실제 윈도우를 생성할 때는 Window 클래스을 사용하지 않고 하위  클래스인 Frame 클래스를 이용한다. 
		<P>다음 프로그램은 Frame을 이용하여 윈도우를 만들고 그 위에 Window객체를 이용하여 윈도우를 나타내는 예를 보인 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>WindowExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
		<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class WindowExample extends Frame {
			<P class="CStep2">private Window myWindow;
			<P class="CStep2">public WindowExample() {
			<P class="CStep3">myWindow = new Window(this);
			<P class="CStep3">myWindow.setLayout(new FlowLayout());
			<P class="CStep3">myWindow.add(new Label(&quot;New Window&quot;));
			<P class="CStep2">}
			<P class="CStep2">public void launchWindow() {	
			<P class="CStep3">myWindow.setLocation(150,150);
			<P class="CStep3">myWindow.setBackground(Color.cyan);
			<P class="CStep3">myWindow.setSize(250, 150);
			<P class="CStep3">myWindow.show();
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">WindowExample we = new WindowExample();
			<P class="CStep3">we.setLocation(100,100);
			<P class="CStep3">we.setSize(250, 150);
			<P class="CStep3">we.setVisible(true);
			<P class="CStep3">we.launchWindow();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">5:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">private Window myWindow;</TD>
		</tr>
		</TABLE>
		<P>Window 클래스로부터 새로운 윈도우 객체를 정의한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">8:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myWindow = new Window(this);</TD>
		</tr>
		</TABLE>
		<P>윈도우 객체를 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">9:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myWindow.setLayout(new FlowLayout());</TD>
		</tr>
		</TABLE>
		<P>생성된 윈도우 객체의 레이아웃 관리자를 지정한다. 레이아웃 관리자에 대해서는 다음 장에서 자세하게 설명하기로 한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%>
			<P class="CNumber">10:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">myWindow.add(new Label(&quot;New Window&quot;));</TD>
		</tr>
		</TABLE>
		<P>생성된 윈도우 객체에 &quot;New Window&quot;라는 문자열을 가진 레이블을 생성하여 포함시킨다.
		<P>다음 그림은 앞의 프로그램을 실행시켰을 때 나타나는 결과화면이다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV167.GIF" BORDER=0 WIDTH=281 HEIGHT=180 ALIGN=BOTTOM>
		<P>Window 클래스의 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 생성자
		<P>  &middot; Window(Frame owner) : 주어진 프레임에 속하는 새로운 윈도우를 보이지 않게 한다
		<P>  &middot; Window(Window owner) : 주어진 윈도우에 속하는 새로운 윈도우를 보이게 한다. 
		<P>▒ 메소드
		<P>  &middot; void dispose() : 윈도우에 속한 컴포넌트가 사용하는 모든 네이티브 스크린 자원의 할당을 해제한다.
		<P>  &middot; Component getFocusOwner() : 윈도우가 활성화되어 있을 때, 현재 포커스를 가지고 있는 윈도우의 자손 컴포넌트를 얻는다.
		<P>  &middot; InputContext getInputContext() : 윈도우의 입력 문장을 얻는다.
		<P>  &middot; Locale getLocale() : 윈도우에 연결되어 있는 로케일 객체(Locale Object)를 얻는다.
		<P>  &middot; Window[] getOwnedWindows() : 이 윈도우에 속한 모든 윈도우를 포함하는 배열을 얻는다.
		<P>  &middot; Window getOwner() : 윈도우의 부모윈도우를 얻는다.
		<P>  &middot; Toolkit getToolkit() : 이 프레임의 툴킷을 얻는데 사용한다.
		<P>  &middot; String getWarningString() : 윈도우에 출력될 경고 문자열을 얻는다.
		<P>  &middot; boolean isShowing() : 이 윈도우가 스크린 상에 보여지고 있는지를 얻는다.
		<P>  &middot; void pack() : 윈도우를 적당한 크기로 조정하고 자신에 속한 컴포넌트를 배치한다.
		<P>  &middot; void show() : 윈도우가 보여지도록 한다.
		<P>  &middot; void toBack() : 윈도우를 뒤로 보낸다.
		<P>  &middot; void toFront() : 윈도우를 앞으로 가져온다.
		<P> 
		<P>4.1.3.4 Frame
		<P>java.awt.Frame 클래스는 Window의 하위 클래스로서 경계선과 타이틀바를 갖는 윈도우를 사용할 수 있게 해준다. 앞에서 예를 든 컴포넌트 프로그램은 모두 Frame 클래스를 상속하여 나타낸 것이다. 이로 미루어 알 수 있는 것은 윈도우를 이용하는 모든 프로그램은 적어도 하나의 프레임을 필요로 한다.
		<P>다음 그림은 Frame 클래스를 이용하여 윈도우를 나타낸 것이다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV168.GIF" BORDER=0 WIDTH=306 HEIGHT=153 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 프로그램은 Frame을 이용하여 윈도우를 나타내는 예를 든 것이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>FrameExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class FrameExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">public FrameExample() {
			<P class="CStep3">f = new Frame(&quot;Frame Example&quot;);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setSize(300, 150);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">FrameExample fe = new FrameExample();
			<P class="CStep3">fe.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f = new Frame(&quot;Frame Example&quot;);</TD>
		</tr>
		</TABLE>
		<P>새로운 윈도우 객체를 생성한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<p class="CNumber">11:
			<p class="CNumber">12:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">f.setSize(300, 150);
			<P class="CStep1">f.setVisible(true);</TD>
		</tr>
		</TABLE>
		<P>11 : 윈도우의 크기를 가로 300픽셀, 세로 150픽셀로 설정. 
		<P>12 : 윈도우를 실제로 화면에 나타나게 한다.
		<P>프레임 클래스의 객체 생성자와 주요 메소드를 살펴보면 다음과 같다.
		<P>▒ 생성자
		<P>  &middot; Frame() : 새로운 프레임을 생성한다. 초기값은 보이지 않게 설정된다.
		<P>  &middot; Frame(String title) : 주어진 이름을 갖는 새로운 프레임을 생성한다. 초기값은 보이지 않게 설정된다.
		<P>▒ 메소드
		<P>  &middot; static Frame[] getFrames() : 생성된 모든 프레임을 포함하는 배열을 얻는다.
		<P>  &middot; Image getIconImage() : 프레임이 최소화 아이콘 상태일 때, 표시될 이미지를 얻는다.
		<P>  &middot; void setIconImage(Image image) : 프레임이 최소화 아이콘 상태일 때, 표시할 이미지를 설정한다.
		<P>  &middot; MenuBar getMenuBar() : 프레임 메뉴바를 얻는다.
		<P>  &middot; void setMenuBar(MenuBar mb) : 주어진 메뉴바로 프레임의 메뉴바를 설정한다.
		<P>  &middot; int getState() : 프레임 상태를 얻는다.
		<P>  &middot; void setState(int state) : 프레임 상태를 설정한다.
		<P>  &middot; String getTitle() : 프레임 제목을 얻는다.
		<P>  &middot; void setTitle(String title) : 주어진 문자열로 프레임 제목을 설정한다.
		<P>  &middot; boolean isResizable() : 사용자에 의해 프레임의 크기가 변경가능한지를 얻는다.
		<P>  &middot; void setResizable(boolean resizable) : 사용자에 의해 프레임의 크기가 변경가능한지를 설정한다.
		<P>  &middot; void remove(MenuComponent m) : 주어진 메뉴바를 프레임에서 제거한다.
		<P>4.1.3.5 Dialog
		<P>java.awt.Dialog는 프레임 클래스와 함께 Window의 하위 클래스로서 FileDialog를 하위 클래스로 두고 있으며, AWT프로그램에서 대화상자를 생성한다. 대화상자는 윈도우에 종속되기 때문에 그 윈도우가 닫히면 대화상자도 함께 닫히게 되고, 윈도우가 최소화되면 대화상자는 사라지게 된다. 대화상자는 non-modal 또는 modalless를 기본값으로 갖는데 non-modal(또는 modalless)은 대화상자가 나타나 있을 때도 다른 작업을 할 수 있는 상태를 말하며, 그 반대의 경우 즉, 대화상자가 닫힐 때까지 대화상자 이외의 다른 작업을 할 수 없는 상태를 모달(modal)이라고 한다.
		<P>애플릿은 프레임이나 윈도우 클래스를 상속받지 않고 패널 클래스를 상속받으므로 윈도우를 가질 수 없기 때문에 대화상자를 사용할 수도 없다. 그러나 애플릿이 자신의 윈도우(또는 프레임)를 갖게되면 그 윈도우에 종속된 대화상자를 가질 수 있다.
		<P>다음 프로그램은 프레임 윈도우의 제목표시줄에 Dialog 클래스를 이용하여 제목을 지정하는 프로그램이다. 두 개의 클래스가 필요하며 TitleBox.java를 먼저 컴파하고 DialogExample.java를 컴파일한다. 실행은 DialogExample.java를 컴파한 후 만들어진 DialogExample.class파일을 이용한다. 물론 두 개의 프로그램을 하나로 만들어도 가능하지만 이럴 경우 파일명을 main() 메소드가 있는 클래스를 파일명으로 해야 한다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV169.GIF" BORDER=0 WIDTH=256 HEIGHT=103 HSPACE=3 ALIGN=BOTTOM>  
		<IMG SRC="images/FYXIV170.GIF" BORDER=0 WIDTH=255 HEIGHT=102 HSPACE=3 ALIGN=BOTTOM>
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>TitleBox.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">&nbsp;
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:
			<p class="CNumber">21:
			<p class="CNumber">22:
			<p class="CNumber">23:
			<p class="CNumber">24:
			<p class="CNumber">25:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">import java.awt.event.*;
			<P class="CStep1">public class TitleBox extends Dialog
			<P class="CStep1">implements ActionListener{
			<P class="CStep2">private TextField field;
			<P class="CStep2">private Button setButton;
			<P class="CStep2">private Frame parent;
			<P class="CStep2">public TitleBox(Frame f, String title) {
			<P class="CStep3">super(f, title, false);
			<P class="CStep3">parent = f;
			<P class="CStep3">setLayout(new FlowLayout());
			<P class="CStep3">field = new TextField(20);
			<P class="CStep3">setButton = new Button(&quot;SET&quot;);
			<P class="CStep3">setButton.addActionListener(this);
			<P class="CStep3">add(field);
			<P class="CStep3">add(setButton);
			<P class="CStep3">pack();
			<P class="CStep2">}
			<P class="CStep2">public void actionPerformed(ActionEvent e) {
			<P class="CStep3">if( e.getActionCommand().equals(&quot;SET&quot;) ) {
			<P class="CStep4">parent.setTitle(field.getText());
			<P class="CStep3">}
			<P class="CStep3">field.selectAll();
			<P class="CStep3">setVisible(false);
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>앞의 프로그램은 길이 20인 텍스트 필드와 버튼을 가진 대화상자를 나타낸다. 텍스트 필드에 특정 문자열을 입력하고 &quot;set&quot; 단추를 누르면 그 내용이 윈도우의 제목표시줄에 출력된다. 이 프로그램 하나만으로는 실행이 되지 않고 다음에 나와있는 DialogExample.java 프로그램 안에서 앞 클래스 파일의 인스턴스를 생성하여 실행시킨다. 즉 실행은 다음 프로그램을 이용한다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>DialogExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH="550">
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class DialogExample {
			<P class="CStep2">private Frame f;
			<P class="CStep2">private TitleBox myTitleBox;
			<P class="CStep2">public DialogExample() {
			<P class="CStep3">f = new Frame();
			<P class="CStep3">myTitleBox = new TitleBox(f, &quot;Input title&quot;);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">f.setLayout(new FlowLayout());
			<P class="CStep3">myTitleBox.show();
			<P class="CStep3">f.setSize(250, 100);
			<P class="CStep3">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep3">DialogExample de = new DialogExample();
			<P class="CStep3">de.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>Dialog 클래스의 객체 생성자와 주요 메소드는 다음과 같다.
		<P>▒ 생성자
		<P>  &middot; Dialog(Dialog owner), Dialog(Frame owner) : 이름이 없고, 주어진 프레임 또는 대화상자에 종속되고, non-modal인 대화상자를 생성한다. 초기값은 보이지 않도록 설정된다.
		<P>  &middot; Dialog(Frame owner, boolean modal) : 이름이 없고, 주어진 프레임에 종속되고, 주어진 modal(true이면 modal, false이면 non-modal)의 대화상자를 생성하며 초기값은 보이지 않도록 설정된다.
		<P>  &middot; Dialog(Dialog owner, String title) : 주어진 이름을 갖고, 주어진 대화상자에 종속되고, non-modal인 대화상자를 생성한다. 초기값은 보이지 않도록 설정된다.
		<P>  &middot; Dialog(Frame owner, String title) : 주어진 이름을 갖고, 주어진 프레임 에 종속되고, non-modal인 대화상자를 생성한다. 초기값은 보이지 않도록 설정된다.
		<P>  &middot; Dialog(Dialog owner, String title, boolean modal) : 주어진 이름으로 대화상자에 종속되며 modal을 갖는 대화상자를 생성한다. 초기값은 보이지 않도록 설정된다.
		<P>  &middot; Dialog(Frame owner, String title, boolean modal) : 주어진 이름으로 프레임에 종속되며 modal을 갖는 대화상자를 생성한다. 초기값은 보이지 않도록 설정된다.
		<P>▒ 메소드
		<P>  &middot; String getTitle() : 대화상자의 제목을 얻는다.
		<P>  &middot; boolean isModal() : 대화상자가 modal인지 여부를 얻는다.
		<P>  &middot; boolean isResizable() : 대화상자가 임의로 크기 변화가 가능한지 여부를 얻는다.
		<P>  &middot; void setModal(boolean b) : 대화상자의 modal을 주어진 값으로 설정한다.
		<P>  &middot; void setResizable(boolean resizable) : 대화상자의 크기변화 여부를 주어진 값으로 설정한다.
		<P>  &middot; void setTitle(String title) : 대화상자의 제목을 설정한다.
		<P>  &middot; void show() : 대화상자를 보이지 않게한다.
		<P>4.1.3.6 FileDialog
		<P>java.awt.FileDialog 클래스는 Dialog의 하위 클래스로 읽거나 쓸 파일을 선택하기 쉽게 도와준다. 윈도우 응용프로그램에서 파일을 읽거나 쓰려고 할 때 나타나는 대화상자와 같을 역할을 한다.
		<P ALIGN=CENTER>
		<IMG SRC="images/FYXIV171.GIF" BORDER=0 WIDTH=532 HEIGHT=248 HSPACE=3 ALIGN=BOTTOM>
		<P>다음 프로그램은 FileDialog를 이용하여 선택한 파일명을 출력하는 예이다.
		<P>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%></td>
			<TD WIDTH=92%>
			<P>FileDialogExample.java</TD>
		</tr>
		</TABLE>
		<TABLE BORDER=0 CELLPADDING=2 WIDTH=550>
		<TR>
			<TD WIDTH=7%>
			<p class="CNumber">1:
			<p class="CNumber">2:
			<p class="CNumber">3:
			<p class="CNumber">4:
			<p class="CNumber">5:
			<p class="CNumber">6:
			<p class="CNumber">7:
			<p class="CNumber">8:
			<p class="CNumber">&nbsp;
			<p class="CNumber">9:
			<p class="CNumber">10:
			<p class="CNumber">11:
			<p class="CNumber">12:
			<p class="CNumber">&nbsp;
			<p class="CNumber">13:
			<p class="CNumber">14:
			<p class="CNumber">15:
			<p class="CNumber">16:
			<p class="CNumber">17:
			<p class="CNumber">18:
			<p class="CNumber">19:
			<p class="CNumber">20:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">import java.io.*;
			<P class="CStep1">import java.awt.*;
			<P class="CStep1">public class FileDialogExample{
			<P class="CStep2">private Frame f;
			<P class="CStep2">private FileDialog loadDialog;
			<P class="CStep2">public FileDialogExample() {
			<P class="CStep3">f = new Frame(&quot;FileDialog Example&quot;);
			<P class="CStep3">loadDialog = new FileDialog(f, &quot;열기&quot;,
			<P class="CStep3">FileDialog.LOAD);
			<P class="CStep2">}
			<P class="CStep2">public void launchFrame() {
			<P class="CStep3">loadDialog.setVisible(true);
			<P class="CStep3">System.out.println(&quot;File &lt;&quot; + loadDialog.getFile() +
			<P class="CStep3">&quot;&gt;is Selected&quot;);
			<P class="CStep4">f.pack();
			<P class="CStep4">f.setVisible(true);
			<P class="CStep2">}
			<P class="CStep2">public static void main(String[] args) {
			<P class="CStep4">FileDialogExample fde = new FileDialogExample();
			<P class="CStep3">fde.launchFrame();
			<P class="CStep2">}
			<P class="CStep1">}</TD>
		</tr>
		</TABLE>
		<P>  
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">7:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">private FileDialog loadDialog;</TD>
		</tr>
		</TABLE>
		<P>새로운 파일대화상자 객체를 정의한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">11:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">loadDialog = new FileDialog(f, &quot;열기&quot;, FileDialog.LOAD);</TD>
		</tr>
		</TABLE>
		<P>프레임 f에 속하면서 제목 표시줄에 &quot;열기&quot;이라는 문자열을 표시하고 파일불러오기 대화상자(FileDialog.LOAD)를 생성한다. 저장하기 대화상자를 생성하기 위해서는 FileDialog.SAVE를 이용한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">15:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">loadDialog.setVisible(true);</TD>
		</tr>
		</TABLE>
		<P>파일대화상자를 보이게 한다.
		<P>
		<TABLE BORDER=1 CELLPADDING=2 WIDTH=550>
			<TD WIDTH=7%>
			<P class="CNumber">16:</TD>
			<TD WIDTH=92%>
			<P class="CStep1">System.out.println(&quot;File &lt;&quot; + loadDialog.getFile() + &quot;&gt;is Selected&quot;);</TD>
		</tr>
		</TABLE>
		<P>선택한 파일명을 출력한다.
		<P>FileDialog 클래스의 객체 생성자와 주요 메소드를 살펴보면 다음과 같다.
		<P>▒ 필드
		<P>  &middot; static int LOAD : 읽을파일을 선택하기 위해 파일대화상자 윈도우를 사용함을 나타낸다.
		<P>  &middot; static int SAVE : 저장할 파일을 선택하기 위해 파일대화상자 윈도우를 사용함을 나타낸다.
		<P>▒ 생성자
		<P>  &middot; FileDialog(Frame parent) : 주어진 프레임에 속한 파일적재용(loading a file) 대화상자를 생성한다.
		<P>  &middot; FileDialog(Frame parent, String title) : 주어진 프레임에 속하고 주어진 이름을 갖는 파일적재용(loading a file) 대화상자를 생성한다.
		<P>  &middot; FileDialog(Frame parent, String title, int mode) : 주어진 프레임에 속하고 주어진 이름을 갖고 주어진 모드(loading/saving)의 파일 대화상자를 생성한다.
		<P>▒ 메소드
		<P>  &middot; String getDirectory() : 파일 대화상자의 디렉토리를 얻는다.
		<P>  &middot; String getFile() : 파일 대화상자에서 선택한 파일을 얻는다.
		<P>  &middot; FilenameFilter getFilenameFilter() : 파일 대화상자의 파일 이름 필터를 얻는다.
		<P>  &middot; int getMode() : 파일 대화상자의 용도가 읽기용(loading)인지 쓰기용(saving)인지를 얻는다.
		<P>  &middot; void setDirectory(String dir) : 파일 대화상자의 디렉토리를 설정한다.
		<P>  &middot; void setFile(String file) : 파일 대화상자의 파일을 설정한다.
		<P>  &middot; void setFilenameFilter(FilenameFilter filter) : 파일 대화상자의 파일 이름 필터를 설정한다.
		<P>  &middot; void setMode(int mode) : 파일 대화상자의 용도(mode)를 설정한다.
		</ul></td>
    </tr>
</table>
</body>
</html>